/* tslint:disable */
/* eslint-disable */
/**
 * Grafana HTTP API.
 * The Grafana backend exposes an HTTP API, the same API is used by the frontend to do everything from saving dashboards, creating users and updating data sources.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: hello@grafana.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AlertRuleGroup,
  AlertingFileExport,
  EmbeddedContactPoint,
  ForbiddenError,
  GenericPublicError,
  MuteTimeInterval,
  NotificationTemplate,
  NotificationTemplateContent,
  ProvisionedAlertRule,
  Route,
  ValidationError,
} from '../models/index';
import {
    AlertRuleGroupFromJSON,
    AlertRuleGroupToJSON,
    AlertingFileExportFromJSON,
    AlertingFileExportToJSON,
    EmbeddedContactPointFromJSON,
    EmbeddedContactPointToJSON,
    ForbiddenErrorFromJSON,
    ForbiddenErrorToJSON,
    GenericPublicErrorFromJSON,
    GenericPublicErrorToJSON,
    MuteTimeIntervalFromJSON,
    MuteTimeIntervalToJSON,
    NotificationTemplateFromJSON,
    NotificationTemplateToJSON,
    NotificationTemplateContentFromJSON,
    NotificationTemplateContentToJSON,
    ProvisionedAlertRuleFromJSON,
    ProvisionedAlertRuleToJSON,
    RouteFromJSON,
    RouteToJSON,
    ValidationErrorFromJSON,
    ValidationErrorToJSON,
} from '../models/index';

export interface ProvisioningApiRouteDeleteAlertRuleRequest {
    uID: string;
    xDisableProvenance?: string;
}

export interface ProvisioningApiRouteDeleteAlertRuleGroupRequest {
    folderUID: string;
    group: string;
}

export interface ProvisioningApiRouteDeleteContactpointsRequest {
    uID: string;
}

export interface ProvisioningApiRouteDeleteMuteTimingRequest {
    name: string;
    version?: string;
    xDisableProvenance?: string;
}

export interface ProvisioningApiRouteDeleteTemplateRequest {
    name: string;
    version?: string;
}

export interface ProvisioningApiRouteExportMuteTimingRequest {
    name: string;
    download?: boolean;
    format?: RouteExportMuteTimingFormatEnum;
}

export interface ProvisioningApiRouteExportMuteTimingsRequest {
    download?: boolean;
    format?: RouteExportMuteTimingsFormatEnum;
}

export interface ProvisioningApiRouteGetAlertRuleRequest {
    uID: string;
}

export interface ProvisioningApiRouteGetAlertRuleExportRequest {
    uID: string;
    download?: boolean;
    format?: RouteGetAlertRuleExportFormatEnum;
}

export interface ProvisioningApiRouteGetAlertRuleGroupRequest {
    folderUID: string;
    group: string;
}

export interface ProvisioningApiRouteGetAlertRuleGroupExportRequest {
    folderUID: string;
    group: string;
    download?: boolean;
    format?: RouteGetAlertRuleGroupExportFormatEnum;
}

export interface ProvisioningApiRouteGetAlertRulesExportRequest {
    download?: boolean;
    format?: RouteGetAlertRulesExportFormatEnum;
    folderUid?: Array<string>;
    group?: string;
    ruleUid?: string;
}

export interface ProvisioningApiRouteGetContactpointsRequest {
    name?: string;
}

export interface ProvisioningApiRouteGetContactpointsExportRequest {
    download?: boolean;
    format?: RouteGetContactpointsExportFormatEnum;
    decrypt?: boolean;
    name?: string;
}

export interface ProvisioningApiRouteGetMuteTimingRequest {
    name: string;
}

export interface ProvisioningApiRouteGetTemplateRequest {
    name: string;
}

export interface ProvisioningApiRoutePostAlertRuleRequest {
    xDisableProvenance?: string;
    body?: Omit<ProvisionedAlertRule, 'updated'>;
}

export interface ProvisioningApiRoutePostContactpointsRequest {
    xDisableProvenance?: string;
    body?: Omit<EmbeddedContactPoint, 'provenance'>;
}

export interface ProvisioningApiRoutePostMuteTimingRequest {
    xDisableProvenance?: string;
    body?: MuteTimeInterval;
}

export interface ProvisioningApiRoutePutAlertRuleRequest {
    uID: string;
    xDisableProvenance?: string;
    body?: Omit<ProvisionedAlertRule, 'updated'>;
}

export interface ProvisioningApiRoutePutAlertRuleGroupRequest {
    folderUID: string;
    group: string;
    xDisableProvenance?: string;
    body?: AlertRuleGroup;
}

export interface ProvisioningApiRoutePutContactpointRequest {
    uID: string;
    xDisableProvenance?: string;
    body?: Omit<EmbeddedContactPoint, 'provenance'>;
}

export interface ProvisioningApiRoutePutMuteTimingRequest {
    name: string;
    xDisableProvenance?: string;
    body?: MuteTimeInterval;
}

export interface ProvisioningApiRoutePutPolicyTreeRequest {
    xDisableProvenance?: string;
    body?: Route;
}

export interface ProvisioningApiRoutePutTemplateRequest {
    name: string;
    xDisableProvenance?: string;
    body?: NotificationTemplateContent;
}

/**
 * 
 */
export class ProvisioningApi extends runtime.BaseAPI {

    /**
     * Delete a specific alert rule by UID.
     */
    async routeDeleteAlertRuleRaw(requestParameters: ProvisioningApiRouteDeleteAlertRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['uID'] == null) {
            throw new runtime.RequiredError(
                'uID',
                'Required parameter "uID" was null or undefined when calling routeDeleteAlertRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xDisableProvenance'] != null) {
            headerParameters['X-Disable-Provenance'] = String(requestParameters['xDisableProvenance']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/alert-rules/{UID}`.replace(`{${"UID"}}`, encodeURIComponent(String(requestParameters['uID']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a specific alert rule by UID.
     */
    async routeDeleteAlertRule(requestParameters: ProvisioningApiRouteDeleteAlertRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.routeDeleteAlertRuleRaw(requestParameters, initOverrides);
    }

    /**
     * Delete rule group
     */
    async routeDeleteAlertRuleGroupRaw(requestParameters: ProvisioningApiRouteDeleteAlertRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['folderUID'] == null) {
            throw new runtime.RequiredError(
                'folderUID',
                'Required parameter "folderUID" was null or undefined when calling routeDeleteAlertRuleGroup().'
            );
        }

        if (requestParameters['group'] == null) {
            throw new runtime.RequiredError(
                'group',
                'Required parameter "group" was null or undefined when calling routeDeleteAlertRuleGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}`.replace(`{${"FolderUID"}}`, encodeURIComponent(String(requestParameters['folderUID']))).replace(`{${"Group"}}`, encodeURIComponent(String(requestParameters['group']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete rule group
     */
    async routeDeleteAlertRuleGroup(requestParameters: ProvisioningApiRouteDeleteAlertRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.routeDeleteAlertRuleGroupRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a contact point.
     */
    async routeDeleteContactpointsRaw(requestParameters: ProvisioningApiRouteDeleteContactpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['uID'] == null) {
            throw new runtime.RequiredError(
                'uID',
                'Required parameter "uID" was null or undefined when calling routeDeleteContactpoints().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/contact-points/{UID}`.replace(`{${"UID"}}`, encodeURIComponent(String(requestParameters['uID']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a contact point.
     */
    async routeDeleteContactpoints(requestParameters: ProvisioningApiRouteDeleteContactpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.routeDeleteContactpointsRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a mute timing.
     */
    async routeDeleteMuteTimingRaw(requestParameters: ProvisioningApiRouteDeleteMuteTimingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling routeDeleteMuteTiming().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['xDisableProvenance'] != null) {
            headerParameters['X-Disable-Provenance'] = String(requestParameters['xDisableProvenance']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/mute-timings/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a mute timing.
     */
    async routeDeleteMuteTiming(requestParameters: ProvisioningApiRouteDeleteMuteTimingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.routeDeleteMuteTimingRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a template.
     */
    async routeDeleteTemplateRaw(requestParameters: ProvisioningApiRouteDeleteTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling routeDeleteTemplate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/templates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a template.
     */
    async routeDeleteTemplate(requestParameters: ProvisioningApiRouteDeleteTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.routeDeleteTemplateRaw(requestParameters, initOverrides);
    }

    /**
     * Export a mute timing in provisioning format.
     */
    async routeExportMuteTimingRaw(requestParameters: ProvisioningApiRouteExportMuteTimingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AlertingFileExport>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling routeExportMuteTiming().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['download'] != null) {
            queryParameters['download'] = requestParameters['download'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/mute-timings/{name}/export`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AlertingFileExportFromJSON(jsonValue));
    }

    /**
     * Export a mute timing in provisioning format.
     */
    async routeExportMuteTiming(requestParameters: ProvisioningApiRouteExportMuteTimingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AlertingFileExport> {
        const response = await this.routeExportMuteTimingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export all mute timings in provisioning format.
     */
    async routeExportMuteTimingsRaw(requestParameters: ProvisioningApiRouteExportMuteTimingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AlertingFileExport>> {
        const queryParameters: any = {};

        if (requestParameters['download'] != null) {
            queryParameters['download'] = requestParameters['download'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/mute-timings/export`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AlertingFileExportFromJSON(jsonValue));
    }

    /**
     * Export all mute timings in provisioning format.
     */
    async routeExportMuteTimings(requestParameters: ProvisioningApiRouteExportMuteTimingsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AlertingFileExport> {
        const response = await this.routeExportMuteTimingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a specific alert rule by UID.
     */
    async routeGetAlertRuleRaw(requestParameters: ProvisioningApiRouteGetAlertRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProvisionedAlertRule>> {
        if (requestParameters['uID'] == null) {
            throw new runtime.RequiredError(
                'uID',
                'Required parameter "uID" was null or undefined when calling routeGetAlertRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/alert-rules/{UID}`.replace(`{${"UID"}}`, encodeURIComponent(String(requestParameters['uID']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProvisionedAlertRuleFromJSON(jsonValue));
    }

    /**
     * Get a specific alert rule by UID.
     */
    async routeGetAlertRule(requestParameters: ProvisioningApiRouteGetAlertRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProvisionedAlertRule> {
        const response = await this.routeGetAlertRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export an alert rule in provisioning file format.
     */
    async routeGetAlertRuleExportRaw(requestParameters: ProvisioningApiRouteGetAlertRuleExportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AlertingFileExport>> {
        if (requestParameters['uID'] == null) {
            throw new runtime.RequiredError(
                'uID',
                'Required parameter "uID" was null or undefined when calling routeGetAlertRuleExport().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['download'] != null) {
            queryParameters['download'] = requestParameters['download'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/alert-rules/{UID}/export`.replace(`{${"UID"}}`, encodeURIComponent(String(requestParameters['uID']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AlertingFileExportFromJSON(jsonValue));
    }

    /**
     * Export an alert rule in provisioning file format.
     */
    async routeGetAlertRuleExport(requestParameters: ProvisioningApiRouteGetAlertRuleExportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AlertingFileExport> {
        const response = await this.routeGetAlertRuleExportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a rule group.
     */
    async routeGetAlertRuleGroupRaw(requestParameters: ProvisioningApiRouteGetAlertRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AlertRuleGroup>> {
        if (requestParameters['folderUID'] == null) {
            throw new runtime.RequiredError(
                'folderUID',
                'Required parameter "folderUID" was null or undefined when calling routeGetAlertRuleGroup().'
            );
        }

        if (requestParameters['group'] == null) {
            throw new runtime.RequiredError(
                'group',
                'Required parameter "group" was null or undefined when calling routeGetAlertRuleGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}`.replace(`{${"FolderUID"}}`, encodeURIComponent(String(requestParameters['folderUID']))).replace(`{${"Group"}}`, encodeURIComponent(String(requestParameters['group']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AlertRuleGroupFromJSON(jsonValue));
    }

    /**
     * Get a rule group.
     */
    async routeGetAlertRuleGroup(requestParameters: ProvisioningApiRouteGetAlertRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AlertRuleGroup> {
        const response = await this.routeGetAlertRuleGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export an alert rule group in provisioning file format.
     */
    async routeGetAlertRuleGroupExportRaw(requestParameters: ProvisioningApiRouteGetAlertRuleGroupExportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AlertingFileExport>> {
        if (requestParameters['folderUID'] == null) {
            throw new runtime.RequiredError(
                'folderUID',
                'Required parameter "folderUID" was null or undefined when calling routeGetAlertRuleGroupExport().'
            );
        }

        if (requestParameters['group'] == null) {
            throw new runtime.RequiredError(
                'group',
                'Required parameter "group" was null or undefined when calling routeGetAlertRuleGroupExport().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['download'] != null) {
            queryParameters['download'] = requestParameters['download'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}/export`.replace(`{${"FolderUID"}}`, encodeURIComponent(String(requestParameters['folderUID']))).replace(`{${"Group"}}`, encodeURIComponent(String(requestParameters['group']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AlertingFileExportFromJSON(jsonValue));
    }

    /**
     * Export an alert rule group in provisioning file format.
     */
    async routeGetAlertRuleGroupExport(requestParameters: ProvisioningApiRouteGetAlertRuleGroupExportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AlertingFileExport> {
        const response = await this.routeGetAlertRuleGroupExportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all the alert rules.
     */
    async routeGetAlertRulesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ProvisionedAlertRule>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/alert-rules`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProvisionedAlertRuleFromJSON));
    }

    /**
     * Get all the alert rules.
     */
    async routeGetAlertRules(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ProvisionedAlertRule>> {
        const response = await this.routeGetAlertRulesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Export all alert rules in provisioning file format.
     */
    async routeGetAlertRulesExportRaw(requestParameters: ProvisioningApiRouteGetAlertRulesExportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AlertingFileExport>> {
        const queryParameters: any = {};

        if (requestParameters['download'] != null) {
            queryParameters['download'] = requestParameters['download'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['folderUid'] != null) {
            queryParameters['folderUid'] = requestParameters['folderUid']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['group'] != null) {
            queryParameters['group'] = requestParameters['group'];
        }

        if (requestParameters['ruleUid'] != null) {
            queryParameters['ruleUid'] = requestParameters['ruleUid'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/alert-rules/export`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AlertingFileExportFromJSON(jsonValue));
    }

    /**
     * Export all alert rules in provisioning file format.
     */
    async routeGetAlertRulesExport(requestParameters: ProvisioningApiRouteGetAlertRulesExportRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AlertingFileExport> {
        const response = await this.routeGetAlertRulesExportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all the contact points.
     */
    async routeGetContactpointsRaw(requestParameters: ProvisioningApiRouteGetContactpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<EmbeddedContactPoint>>> {
        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/contact-points`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EmbeddedContactPointFromJSON));
    }

    /**
     * Get all the contact points.
     */
    async routeGetContactpoints(requestParameters: ProvisioningApiRouteGetContactpointsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<EmbeddedContactPoint>> {
        const response = await this.routeGetContactpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export all contact points in provisioning file format.
     */
    async routeGetContactpointsExportRaw(requestParameters: ProvisioningApiRouteGetContactpointsExportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AlertingFileExport>> {
        const queryParameters: any = {};

        if (requestParameters['download'] != null) {
            queryParameters['download'] = requestParameters['download'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['decrypt'] != null) {
            queryParameters['decrypt'] = requestParameters['decrypt'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/contact-points/export`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AlertingFileExportFromJSON(jsonValue));
    }

    /**
     * Export all contact points in provisioning file format.
     */
    async routeGetContactpointsExport(requestParameters: ProvisioningApiRouteGetContactpointsExportRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AlertingFileExport> {
        const response = await this.routeGetContactpointsExportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a mute timing.
     */
    async routeGetMuteTimingRaw(requestParameters: ProvisioningApiRouteGetMuteTimingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MuteTimeInterval>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling routeGetMuteTiming().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/mute-timings/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MuteTimeIntervalFromJSON(jsonValue));
    }

    /**
     * Get a mute timing.
     */
    async routeGetMuteTiming(requestParameters: ProvisioningApiRouteGetMuteTimingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MuteTimeInterval> {
        const response = await this.routeGetMuteTimingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all the mute timings.
     */
    async routeGetMuteTimingsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MuteTimeInterval>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/mute-timings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MuteTimeIntervalFromJSON));
    }

    /**
     * Get all the mute timings.
     */
    async routeGetMuteTimings(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MuteTimeInterval>> {
        const response = await this.routeGetMuteTimingsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the notification policy tree.
     */
    async routeGetPolicyTreeRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Route>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/policies`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RouteFromJSON(jsonValue));
    }

    /**
     * Get the notification policy tree.
     */
    async routeGetPolicyTree(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Route> {
        const response = await this.routeGetPolicyTreeRaw(initOverrides);
        return await response.value();
    }

    /**
     * Export the notification policy tree in provisioning file format.
     */
    async routeGetPolicyTreeExportRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AlertingFileExport>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/policies/export`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AlertingFileExportFromJSON(jsonValue));
    }

    /**
     * Export the notification policy tree in provisioning file format.
     */
    async routeGetPolicyTreeExport(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AlertingFileExport> {
        const response = await this.routeGetPolicyTreeExportRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a notification template.
     */
    async routeGetTemplateRaw(requestParameters: ProvisioningApiRouteGetTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotificationTemplate>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling routeGetTemplate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/templates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NotificationTemplateFromJSON(jsonValue));
    }

    /**
     * Get a notification template.
     */
    async routeGetTemplate(requestParameters: ProvisioningApiRouteGetTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotificationTemplate> {
        const response = await this.routeGetTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all notification templates.
     */
    async routeGetTemplatesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<NotificationTemplate>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/templates`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(NotificationTemplateFromJSON));
    }

    /**
     * Get all notification templates.
     */
    async routeGetTemplates(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<NotificationTemplate>> {
        const response = await this.routeGetTemplatesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Create a new alert rule.
     */
    async routePostAlertRuleRaw(requestParameters: ProvisioningApiRoutePostAlertRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProvisionedAlertRule>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xDisableProvenance'] != null) {
            headerParameters['X-Disable-Provenance'] = String(requestParameters['xDisableProvenance']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/alert-rules`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProvisionedAlertRuleToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProvisionedAlertRuleFromJSON(jsonValue));
    }

    /**
     * Create a new alert rule.
     */
    async routePostAlertRule(requestParameters: ProvisioningApiRoutePostAlertRuleRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProvisionedAlertRule> {
        const response = await this.routePostAlertRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a contact point.
     */
    async routePostContactpointsRaw(requestParameters: ProvisioningApiRoutePostContactpointsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EmbeddedContactPoint>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xDisableProvenance'] != null) {
            headerParameters['X-Disable-Provenance'] = String(requestParameters['xDisableProvenance']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/contact-points`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: EmbeddedContactPointToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EmbeddedContactPointFromJSON(jsonValue));
    }

    /**
     * Create a contact point.
     */
    async routePostContactpoints(requestParameters: ProvisioningApiRoutePostContactpointsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EmbeddedContactPoint> {
        const response = await this.routePostContactpointsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new mute timing.
     */
    async routePostMuteTimingRaw(requestParameters: ProvisioningApiRoutePostMuteTimingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MuteTimeInterval>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xDisableProvenance'] != null) {
            headerParameters['X-Disable-Provenance'] = String(requestParameters['xDisableProvenance']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/mute-timings`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MuteTimeIntervalToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MuteTimeIntervalFromJSON(jsonValue));
    }

    /**
     * Create a new mute timing.
     */
    async routePostMuteTiming(requestParameters: ProvisioningApiRoutePostMuteTimingRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MuteTimeInterval> {
        const response = await this.routePostMuteTimingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an existing alert rule.
     */
    async routePutAlertRuleRaw(requestParameters: ProvisioningApiRoutePutAlertRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProvisionedAlertRule>> {
        if (requestParameters['uID'] == null) {
            throw new runtime.RequiredError(
                'uID',
                'Required parameter "uID" was null or undefined when calling routePutAlertRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xDisableProvenance'] != null) {
            headerParameters['X-Disable-Provenance'] = String(requestParameters['xDisableProvenance']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/alert-rules/{UID}`.replace(`{${"UID"}}`, encodeURIComponent(String(requestParameters['uID']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ProvisionedAlertRuleToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProvisionedAlertRuleFromJSON(jsonValue));
    }

    /**
     * Update an existing alert rule.
     */
    async routePutAlertRule(requestParameters: ProvisioningApiRoutePutAlertRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProvisionedAlertRule> {
        const response = await this.routePutAlertRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create or update alert rule group.
     */
    async routePutAlertRuleGroupRaw(requestParameters: ProvisioningApiRoutePutAlertRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AlertRuleGroup>> {
        if (requestParameters['folderUID'] == null) {
            throw new runtime.RequiredError(
                'folderUID',
                'Required parameter "folderUID" was null or undefined when calling routePutAlertRuleGroup().'
            );
        }

        if (requestParameters['group'] == null) {
            throw new runtime.RequiredError(
                'group',
                'Required parameter "group" was null or undefined when calling routePutAlertRuleGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xDisableProvenance'] != null) {
            headerParameters['X-Disable-Provenance'] = String(requestParameters['xDisableProvenance']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}`.replace(`{${"FolderUID"}}`, encodeURIComponent(String(requestParameters['folderUID']))).replace(`{${"Group"}}`, encodeURIComponent(String(requestParameters['group']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AlertRuleGroupToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AlertRuleGroupFromJSON(jsonValue));
    }

    /**
     * Create or update alert rule group.
     */
    async routePutAlertRuleGroup(requestParameters: ProvisioningApiRoutePutAlertRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AlertRuleGroup> {
        const response = await this.routePutAlertRuleGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an existing contact point.
     */
    async routePutContactpointRaw(requestParameters: ProvisioningApiRoutePutContactpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['uID'] == null) {
            throw new runtime.RequiredError(
                'uID',
                'Required parameter "uID" was null or undefined when calling routePutContactpoint().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xDisableProvenance'] != null) {
            headerParameters['X-Disable-Provenance'] = String(requestParameters['xDisableProvenance']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/contact-points/{UID}`.replace(`{${"UID"}}`, encodeURIComponent(String(requestParameters['uID']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: EmbeddedContactPointToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Update an existing contact point.
     */
    async routePutContactpoint(requestParameters: ProvisioningApiRoutePutContactpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.routePutContactpointRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Replace an existing mute timing.
     */
    async routePutMuteTimingRaw(requestParameters: ProvisioningApiRoutePutMuteTimingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MuteTimeInterval>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling routePutMuteTiming().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xDisableProvenance'] != null) {
            headerParameters['X-Disable-Provenance'] = String(requestParameters['xDisableProvenance']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/mute-timings/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MuteTimeIntervalToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MuteTimeIntervalFromJSON(jsonValue));
    }

    /**
     * Replace an existing mute timing.
     */
    async routePutMuteTiming(requestParameters: ProvisioningApiRoutePutMuteTimingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MuteTimeInterval> {
        const response = await this.routePutMuteTimingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sets the notification policy tree.
     */
    async routePutPolicyTreeRaw(requestParameters: ProvisioningApiRoutePutPolicyTreeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xDisableProvenance'] != null) {
            headerParameters['X-Disable-Provenance'] = String(requestParameters['xDisableProvenance']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/policies`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RouteToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Sets the notification policy tree.
     */
    async routePutPolicyTree(requestParameters: ProvisioningApiRoutePutPolicyTreeRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.routePutPolicyTreeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates an existing notification template.
     */
    async routePutTemplateRaw(requestParameters: ProvisioningApiRoutePutTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NotificationTemplate>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling routePutTemplate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xDisableProvenance'] != null) {
            headerParameters['X-Disable-Provenance'] = String(requestParameters['xDisableProvenance']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/templates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: NotificationTemplateContentToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NotificationTemplateFromJSON(jsonValue));
    }

    /**
     * Updates an existing notification template.
     */
    async routePutTemplate(requestParameters: ProvisioningApiRoutePutTemplateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NotificationTemplate> {
        const response = await this.routePutTemplateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Clears the notification policy tree.
     */
    async routeResetPolicyTreeRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v1/provisioning/policies`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Clears the notification policy tree.
     */
    async routeResetPolicyTree(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.routeResetPolicyTreeRaw(initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const RouteExportMuteTimingFormatEnum = {
    Yaml: 'yaml',
    Json: 'json',
    Hcl: 'hcl'
} as const;
export type RouteExportMuteTimingFormatEnum = typeof RouteExportMuteTimingFormatEnum[keyof typeof RouteExportMuteTimingFormatEnum];
/**
 * @export
 */
export const RouteExportMuteTimingsFormatEnum = {
    Yaml: 'yaml',
    Json: 'json',
    Hcl: 'hcl'
} as const;
export type RouteExportMuteTimingsFormatEnum = typeof RouteExportMuteTimingsFormatEnum[keyof typeof RouteExportMuteTimingsFormatEnum];
/**
 * @export
 */
export const RouteGetAlertRuleExportFormatEnum = {
    Yaml: 'yaml',
    Json: 'json',
    Hcl: 'hcl'
} as const;
export type RouteGetAlertRuleExportFormatEnum = typeof RouteGetAlertRuleExportFormatEnum[keyof typeof RouteGetAlertRuleExportFormatEnum];
/**
 * @export
 */
export const RouteGetAlertRuleGroupExportFormatEnum = {
    Yaml: 'yaml',
    Json: 'json',
    Hcl: 'hcl'
} as const;
export type RouteGetAlertRuleGroupExportFormatEnum = typeof RouteGetAlertRuleGroupExportFormatEnum[keyof typeof RouteGetAlertRuleGroupExportFormatEnum];
/**
 * @export
 */
export const RouteGetAlertRulesExportFormatEnum = {
    Yaml: 'yaml',
    Json: 'json',
    Hcl: 'hcl'
} as const;
export type RouteGetAlertRulesExportFormatEnum = typeof RouteGetAlertRulesExportFormatEnum[keyof typeof RouteGetAlertRulesExportFormatEnum];
/**
 * @export
 */
export const RouteGetContactpointsExportFormatEnum = {
    Yaml: 'yaml',
    Json: 'json',
    Hcl: 'hcl'
} as const;
export type RouteGetContactpointsExportFormatEnum = typeof RouteGetContactpointsExportFormatEnum[keyof typeof RouteGetContactpointsExportFormatEnum];
