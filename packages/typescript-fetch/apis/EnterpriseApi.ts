/* tslint:disable */
/* eslint-disable */
/**
 * Grafana HTTP API.
 * The Grafana backend exposes an HTTP API, the same API is used by the frontend to do everything from saving dashboards, creating users and updating data sources.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: hello@grafana.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ActiveSyncStatusDTO,
  ActiveUserStats,
  AddTeamRoleCommand,
  AddUserRoleCommand,
  CreateOrUpdateReportConfig,
  CreateReport200Response,
  CreateRoleForm,
  DeleteTokenCommand,
  ErrorResponseBody,
  PrometheusRemoteWriteTargetJSON,
  RecordingRuleJSON,
  Report,
  ReportEmail,
  ReportSettings,
  RoleAssignmentsDTO,
  RoleDTO,
  RolesSearchQuery,
  SearchResult,
  SetRoleAssignmentsCommand,
  SetUserRolesCommand,
  SuccessResponseBody,
  TeamGroupDTO,
  TeamGroupMapping,
  Token,
  UpdateRoleCommand,
} from '../models/index';
import {
    ActiveSyncStatusDTOFromJSON,
    ActiveSyncStatusDTOToJSON,
    ActiveUserStatsFromJSON,
    ActiveUserStatsToJSON,
    AddTeamRoleCommandFromJSON,
    AddTeamRoleCommandToJSON,
    AddUserRoleCommandFromJSON,
    AddUserRoleCommandToJSON,
    CreateOrUpdateReportConfigFromJSON,
    CreateOrUpdateReportConfigToJSON,
    CreateReport200ResponseFromJSON,
    CreateReport200ResponseToJSON,
    CreateRoleFormFromJSON,
    CreateRoleFormToJSON,
    DeleteTokenCommandFromJSON,
    DeleteTokenCommandToJSON,
    ErrorResponseBodyFromJSON,
    ErrorResponseBodyToJSON,
    PrometheusRemoteWriteTargetJSONFromJSON,
    PrometheusRemoteWriteTargetJSONToJSON,
    RecordingRuleJSONFromJSON,
    RecordingRuleJSONToJSON,
    ReportFromJSON,
    ReportToJSON,
    ReportEmailFromJSON,
    ReportEmailToJSON,
    ReportSettingsFromJSON,
    ReportSettingsToJSON,
    RoleAssignmentsDTOFromJSON,
    RoleAssignmentsDTOToJSON,
    RoleDTOFromJSON,
    RoleDTOToJSON,
    RolesSearchQueryFromJSON,
    RolesSearchQueryToJSON,
    SearchResultFromJSON,
    SearchResultToJSON,
    SetRoleAssignmentsCommandFromJSON,
    SetRoleAssignmentsCommandToJSON,
    SetUserRolesCommandFromJSON,
    SetUserRolesCommandToJSON,
    SuccessResponseBodyFromJSON,
    SuccessResponseBodyToJSON,
    TeamGroupDTOFromJSON,
    TeamGroupDTOToJSON,
    TeamGroupMappingFromJSON,
    TeamGroupMappingToJSON,
    TokenFromJSON,
    TokenToJSON,
    UpdateRoleCommandFromJSON,
    UpdateRoleCommandToJSON,
} from '../models/index';

export interface EnterpriseApiAddTeamGroupApiRequest {
    teamId: number;
    body: TeamGroupMapping;
}

export interface EnterpriseApiAddTeamRoleRequest {
    teamId: number;
    body: AddTeamRoleCommand;
}

export interface EnterpriseApiAddUserRoleRequest {
    userId: number;
    body: AddUserRoleCommand;
}

export interface EnterpriseApiCreateRecordingRuleRequest {
    body: RecordingRuleJSON;
}

export interface EnterpriseApiCreateRecordingRuleWriteTargetRequest {
    body: PrometheusRemoteWriteTargetJSON;
}

export interface EnterpriseApiCreateReportRequest {
    body: CreateOrUpdateReportConfig;
}

export interface EnterpriseApiCreateRoleRequest {
    body: CreateRoleForm;
}

export interface EnterpriseApiDeleteLicenseTokenRequest {
    body: DeleteTokenCommand;
}

export interface EnterpriseApiDeleteRecordingRuleRequest {
    recordingRuleID: number;
}

export interface EnterpriseApiDeleteReportRequest {
    id: number;
}

export interface EnterpriseApiDeleteRoleRequest {
    roleUID: string;
    force?: boolean;
    global?: boolean;
}

export interface EnterpriseApiGetReportRequest {
    id: number;
}

export interface EnterpriseApiGetRoleRequest {
    roleUID: string;
}

export interface EnterpriseApiGetRoleAssignmentsRequest {
    roleUID: string;
}

export interface EnterpriseApiGetTeamGroupsApiRequest {
    teamId: number;
}

export interface EnterpriseApiListRolesRequest {
    delegatable?: boolean;
}

export interface EnterpriseApiListTeamRolesRequest {
    teamId: number;
}

export interface EnterpriseApiListTeamsRolesRequest {
    body: RolesSearchQuery;
}

export interface EnterpriseApiListUserRolesRequest {
    userId: number;
}

export interface EnterpriseApiListUsersRolesRequest {
    body: RolesSearchQuery;
}

export interface EnterpriseApiPostACSRequest {
    relayState?: string;
}

export interface EnterpriseApiPostLicenseTokenRequest {
    body: DeleteTokenCommand;
}

export interface EnterpriseApiPostRenewLicenseTokenRequest {
    body: object;
}

export interface EnterpriseApiPostSLORequest {
    sAMLRequest?: string;
    sAMLResponse?: string;
}

export interface EnterpriseApiRemoveTeamGroupApiQueryRequest {
    teamId: number;
    groupId?: string;
}

export interface EnterpriseApiRemoveTeamRoleRequest {
    roleUID: string;
    teamId: number;
}

export interface EnterpriseApiRemoveUserRoleRequest {
    roleUID: string;
    userId: number;
    global?: boolean;
}

export interface EnterpriseApiRenderReportPDFsRequest {
    dashboardID?: string;
    orientation?: string;
    layout?: string;
    title?: string;
    scaleFactor?: string;
    includeTables?: string;
}

export interface EnterpriseApiSaveReportSettingsRequest {
    body: ReportSettings;
}

export interface EnterpriseApiSendReportRequest {
    body: ReportEmail;
}

export interface EnterpriseApiSendTestEmailRequest {
    body: CreateOrUpdateReportConfig;
}

export interface EnterpriseApiSetRoleAssignmentsRequest {
    roleUID: string;
    body: SetRoleAssignmentsCommand;
}

export interface EnterpriseApiSetTeamRolesRequest {
    teamId: number;
}

export interface EnterpriseApiSetUserRolesRequest {
    userId: number;
    body: SetUserRolesCommand;
}

export interface EnterpriseApiTestCreateRecordingRuleRequest {
    body: RecordingRuleJSON;
}

export interface EnterpriseApiUpdateRecordingRuleRequest {
    body: RecordingRuleJSON;
}

export interface EnterpriseApiUpdateReportRequest {
    id: number;
    body: CreateOrUpdateReportConfig;
}

export interface EnterpriseApiUpdateRoleRequest {
    roleUID: string;
    body: UpdateRoleCommand;
}

/**
 * 
 */
export class EnterpriseApi extends runtime.BaseAPI {

    /**
     * Add External Group.
     */
    async addTeamGroupApiRaw(requestParameters: EnterpriseApiAddTeamGroupApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['teamId'] == null) {
            throw new runtime.RequiredError(
                'teamId',
                'Required parameter "teamId" was null or undefined when calling addTeamGroupApi().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling addTeamGroupApi().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/teams/{teamId}/groups`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters['teamId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TeamGroupMappingToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Add External Group.
     */
    async addTeamGroupApi(requestParameters: EnterpriseApiAddTeamGroupApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.addTeamGroupApiRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`.
     * Add team role.
     */
    async addTeamRoleRaw(requestParameters: EnterpriseApiAddTeamRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['teamId'] == null) {
            throw new runtime.RequiredError(
                'teamId',
                'Required parameter "teamId" was null or undefined when calling addTeamRole().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling addTeamRole().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/teams/{teamId}/roles`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters['teamId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddTeamRoleCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`.
     * Add team role.
     */
    async addTeamRole(requestParameters: EnterpriseApiAddTeamRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.addTeamRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Assign a role to a specific user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
     * Add a user role assignment.
     */
    async addUserRoleRaw(requestParameters: EnterpriseApiAddUserRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling addUserRole().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling addUserRole().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/users/{userId}/roles`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddUserRoleCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Assign a role to a specific user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
     * Add a user role assignment.
     */
    async addUserRole(requestParameters: EnterpriseApiAddUserRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.addUserRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * You need to have a permission with action `provisioning:reload` with scope `provisioners:accesscontrol`.
     */
    async adminProvisioningReloadAccessControlRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ErrorResponseBody>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/admin/provisioning/access-control/reload`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ErrorResponseBodyFromJSON(jsonValue));
    }

    /**
     * You need to have a permission with action `provisioning:reload` with scope `provisioners:accesscontrol`.
     */
    async adminProvisioningReloadAccessControl(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ErrorResponseBody> {
        const response = await this.adminProvisioningReloadAccessControlRaw(initOverrides);
        return await response.value();
    }

    /**
     * Create a recording rule that is then registered and started.
     */
    async createRecordingRuleRaw(requestParameters: EnterpriseApiCreateRecordingRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecordingRuleJSON>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createRecordingRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/recording-rules`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecordingRuleJSONToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecordingRuleJSONFromJSON(jsonValue));
    }

    /**
     * Create a recording rule that is then registered and started.
     */
    async createRecordingRule(requestParameters: EnterpriseApiCreateRecordingRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecordingRuleJSON> {
        const response = await this.createRecordingRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * It returns a 422 if there is not an existing prometheus data source configured.
     * Create a remote write target.
     */
    async createRecordingRuleWriteTargetRaw(requestParameters: EnterpriseApiCreateRecordingRuleWriteTargetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PrometheusRemoteWriteTargetJSON>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createRecordingRuleWriteTarget().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/recording-rules/writer`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PrometheusRemoteWriteTargetJSONToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PrometheusRemoteWriteTargetJSONFromJSON(jsonValue));
    }

    /**
     * It returns a 422 if there is not an existing prometheus data source configured.
     * Create a remote write target.
     */
    async createRecordingRuleWriteTarget(requestParameters: EnterpriseApiCreateRecordingRuleWriteTargetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PrometheusRemoteWriteTargetJSON> {
        const response = await this.createRecordingRuleWriteTargetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Available to org admins only and with a valid license.  You need to have a permission with action `reports.admin:create`.
     * Create a report.
     */
    async createReportRaw(requestParameters: EnterpriseApiCreateReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateReport200Response>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createReport().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/reports`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateOrUpdateReportConfigToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateReport200ResponseFromJSON(jsonValue));
    }

    /**
     * Available to org admins only and with a valid license.  You need to have a permission with action `reports.admin:create`.
     * Create a report.
     */
    async createReport(requestParameters: EnterpriseApiCreateReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateReport200Response> {
        const response = await this.createReportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.  You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
     * Create a new custom role.
     */
    async createRoleRaw(requestParameters: EnterpriseApiCreateRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RoleDTO>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createRole().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/roles`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateRoleFormToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleDTOFromJSON(jsonValue));
    }

    /**
     * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.  You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
     * Create a new custom role.
     */
    async createRole(requestParameters: EnterpriseApiCreateRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RoleDTO> {
        const response = await this.createRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Removes the license stored in the Grafana database. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:delete`.
     * Remove license from database.
     */
    async deleteLicenseTokenRaw(requestParameters: EnterpriseApiDeleteLicenseTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ErrorResponseBody>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling deleteLicenseToken().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/licensing/token`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: DeleteTokenCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ErrorResponseBodyFromJSON(jsonValue));
    }

    /**
     * Removes the license stored in the Grafana database. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:delete`.
     * Remove license from database.
     */
    async deleteLicenseToken(requestParameters: EnterpriseApiDeleteLicenseTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ErrorResponseBody> {
        const response = await this.deleteLicenseTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete removes the rule from the registry and stops it.
     */
    async deleteRecordingRuleRaw(requestParameters: EnterpriseApiDeleteRecordingRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['recordingRuleID'] == null) {
            throw new runtime.RequiredError(
                'recordingRuleID',
                'Required parameter "recordingRuleID" was null or undefined when calling deleteRecordingRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/recording-rules/{recordingRuleID}`.replace(`{${"recordingRuleID"}}`, encodeURIComponent(String(requestParameters['recordingRuleID']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Delete removes the rule from the registry and stops it.
     */
    async deleteRecordingRule(requestParameters: EnterpriseApiDeleteRecordingRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.deleteRecordingRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the remote write target.
     */
    async deleteRecordingRuleWriteTargetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/recording-rules/writer`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Delete the remote write target.
     */
    async deleteRecordingRuleWriteTarget(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.deleteRecordingRuleWriteTargetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.delete` with scope `reports:id:<report ID>`.
     * Delete a report.
     */
    async deleteReportRaw(requestParameters: EnterpriseApiDeleteReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteReport().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/reports/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.delete` with scope `reports:id:<report ID>`.
     * Delete a report.
     */
    async deleteReport(requestParameters: EnterpriseApiDeleteReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.deleteReportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.  You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
     * Delete a custom role.
     */
    async deleteRoleRaw(requestParameters: EnterpriseApiDeleteRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['roleUID'] == null) {
            throw new runtime.RequiredError(
                'roleUID',
                'Required parameter "roleUID" was null or undefined when calling deleteRole().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        if (requestParameters['global'] != null) {
            queryParameters['global'] = requestParameters['global'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters['roleUID']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.  You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
     * Delete a custom role.
     */
    async deleteRole(requestParameters: EnterpriseApiDeleteRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.deleteRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns an indicator to check if fine-grained access control is enabled or not.  You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
     * Get status.
     */
    async getAccessControlStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<number>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<number>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Returns an indicator to check if fine-grained access control is enabled or not.  You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
     * Get status.
     */
    async getAccessControlStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<number> {
        const response = await this.getAccessControlStatusRaw(initOverrides);
        return await response.value();
    }

    /**
     * You need to have a permission with action `licensing.reports:read`.
     * Get custom permissions report in CSV format.
     * @deprecated
     */
    async getCustomPermissionsCSVRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/licensing/custom-permissions-csv`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * You need to have a permission with action `licensing.reports:read`.
     * Get custom permissions report in CSV format.
     * @deprecated
     */
    async getCustomPermissionsCSV(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getCustomPermissionsCSVRaw(initOverrides);
    }

    /**
     * You need to have a permission with action `licensing.reports:read`.
     * Get custom permissions report.
     * @deprecated
     */
    async getCustomPermissionsReportRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/licensing/custom-permissions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * You need to have a permission with action `licensing.reports:read`.
     * Get custom permissions report.
     * @deprecated
     */
    async getCustomPermissionsReport(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getCustomPermissionsReportRaw(initOverrides);
    }

    /**
     * You need to have a permission with action `licensing:read`.
     * Get license token.
     */
    async getLicenseTokenRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Token>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/licensing/token`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenFromJSON(jsonValue));
    }

    /**
     * You need to have a permission with action `licensing:read`.
     * Get license token.
     */
    async getLicenseToken(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Token> {
        const response = await this.getLicenseTokenRaw(initOverrides);
        return await response.value();
    }

    /**
     * It exposes the SP (Grafana\'s) metadata for the IdP\'s consumption.
     */
    async getMetadataRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/saml/metadata`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * It exposes the SP (Grafana\'s) metadata for the IdP\'s consumption.
     */
    async getMetadata(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.getMetadataRaw(initOverrides);
        return await response.value();
    }

    /**
     * Return the prometheus remote write target.
     */
    async getRecordingRuleWriteTargetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PrometheusRemoteWriteTargetJSON>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/recording-rules/writer`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PrometheusRemoteWriteTargetJSONFromJSON(jsonValue));
    }

    /**
     * Return the prometheus remote write target.
     */
    async getRecordingRuleWriteTarget(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PrometheusRemoteWriteTargetJSON> {
        const response = await this.getRecordingRuleWriteTargetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:id:<report ID>`.
     * Get a report.
     */
    async getReportRaw(requestParameters: EnterpriseApiGetReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Report>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getReport().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/reports/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReportFromJSON(jsonValue));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:id:<report ID>`.
     * Get a report.
     */
    async getReport(requestParameters: EnterpriseApiGetReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Report> {
        const response = await this.getReportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`x.
     * Get settings.
     */
    async getReportSettingsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReportSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/reports/settings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReportSettingsFromJSON(jsonValue));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`x.
     * Get settings.
     */
    async getReportSettings(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReportSettings> {
        const response = await this.getReportSettingsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:*`.
     * List reports.
     */
    async getReportsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Report>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/reports`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ReportFromJSON));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:*`.
     * List reports.
     */
    async getReports(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Report>> {
        const response = await this.getReportsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a role for the given UID.  You need to have a permission with action `roles:read` and scope `roles:*`.
     * Get a role.
     */
    async getRoleRaw(requestParameters: EnterpriseApiGetRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RoleDTO>> {
        if (requestParameters['roleUID'] == null) {
            throw new runtime.RequiredError(
                'roleUID',
                'Required parameter "roleUID" was null or undefined when calling getRole().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters['roleUID']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleDTOFromJSON(jsonValue));
    }

    /**
     * Get a role for the given UID.  You need to have a permission with action `roles:read` and scope `roles:*`.
     * Get a role.
     */
    async getRole(requestParameters: EnterpriseApiGetRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RoleDTO> {
        const response = await this.getRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
     * Get role assignments.
     */
    async getRoleAssignmentsRaw(requestParameters: EnterpriseApiGetRoleAssignmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RoleAssignmentsDTO>> {
        if (requestParameters['roleUID'] == null) {
            throw new runtime.RequiredError(
                'roleUID',
                'Required parameter "roleUID" was null or undefined when calling getRoleAssignments().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/roles/{roleUID}/assignments`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters['roleUID']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleAssignmentsDTOFromJSON(jsonValue));
    }

    /**
     * Get role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
     * Get role assignments.
     */
    async getRoleAssignments(requestParameters: EnterpriseApiGetRoleAssignmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RoleAssignmentsDTO> {
        const response = await this.getRoleAssignmentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * GetLogout initiates single logout process.
     */
    async getSAMLLogoutRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/logout/saml`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * GetLogout initiates single logout process.
     */
    async getSAMLLogout(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getSAMLLogoutRaw(initOverrides);
    }

    /**
     * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
     * It performs Single Logout (SLO) callback.
     */
    async getSLORaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/saml/slo`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
     * It performs Single Logout (SLO) callback.
     */
    async getSLO(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getSLORaw(initOverrides);
    }

    /**
     * Check license availability.
     */
    async getStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/licensing/check`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Check license availability.
     */
    async getStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getStatusRaw(initOverrides);
    }

    /**
     * You need to have a permission with action `ldap.status:read`.
     * Returns the current state of the LDAP background sync integration.
     */
    async getSyncStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ActiveSyncStatusDTO>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/admin/ldap-sync-status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ActiveSyncStatusDTOFromJSON(jsonValue));
    }

    /**
     * You need to have a permission with action `ldap.status:read`.
     * Returns the current state of the LDAP background sync integration.
     */
    async getSyncStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ActiveSyncStatusDTO> {
        const response = await this.getSyncStatusRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get External Groups.
     */
    async getTeamGroupsApiRaw(requestParameters: EnterpriseApiGetTeamGroupsApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TeamGroupDTO>>> {
        if (requestParameters['teamId'] == null) {
            throw new runtime.RequiredError(
                'teamId',
                'Required parameter "teamId" was null or undefined when calling getTeamGroupsApi().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/teams/{teamId}/groups`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters['teamId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TeamGroupDTOFromJSON));
    }

    /**
     * Get External Groups.
     */
    async getTeamGroupsApi(requestParameters: EnterpriseApiGetTeamGroupsApiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TeamGroupDTO>> {
        const response = await this.getTeamGroupsApiRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists all rules in the database: active or deleted.
     */
    async listRecordingRulesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RecordingRuleJSON>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/recording-rules`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RecordingRuleJSONFromJSON));
    }

    /**
     * Lists all rules in the database: active or deleted.
     */
    async listRecordingRules(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RecordingRuleJSON>> {
        const response = await this.listRecordingRulesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.  You need to have a permission with action `roles:read` and scope `roles:*`.
     * Get all roles.
     */
    async listRolesRaw(requestParameters: EnterpriseApiListRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RoleDTO>>> {
        const queryParameters: any = {};

        if (requestParameters['delegatable'] != null) {
            queryParameters['delegatable'] = requestParameters['delegatable'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/roles`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RoleDTOFromJSON));
    }

    /**
     * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.  You need to have a permission with action `roles:read` and scope `roles:*`.
     * Get all roles.
     */
    async listRoles(requestParameters: EnterpriseApiListRolesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RoleDTO>> {
        const response = await this.listRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`.
     * Get team roles.
     */
    async listTeamRolesRaw(requestParameters: EnterpriseApiListTeamRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['teamId'] == null) {
            throw new runtime.RequiredError(
                'teamId',
                'Required parameter "teamId" was null or undefined when calling listTeamRoles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/teams/{teamId}/roles`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters['teamId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`.
     * Get team roles.
     */
    async listTeamRoles(requestParameters: EnterpriseApiListTeamRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.listTeamRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists the roles that have been directly assigned to the given teams.  You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
     * List roles assigned to multiple teams.
     */
    async listTeamsRolesRaw(requestParameters: EnterpriseApiListTeamsRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: Array<RoleDTO>; }>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling listTeamsRoles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/teams/roles/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RolesSearchQueryToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Lists the roles that have been directly assigned to the given teams.  You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
     * List roles assigned to multiple teams.
     */
    async listTeamsRoles(requestParameters: EnterpriseApiListTeamsRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: Array<RoleDTO>; }> {
        const response = await this.listTeamsRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
     * List roles assigned to a user.
     */
    async listUserRolesRaw(requestParameters: EnterpriseApiListUserRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RoleDTO>>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling listUserRoles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/users/{userId}/roles`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RoleDTOFromJSON));
    }

    /**
     * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
     * List roles assigned to a user.
     */
    async listUserRoles(requestParameters: EnterpriseApiListUserRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RoleDTO>> {
        const response = await this.listUserRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:*`.
     * List roles assigned to multiple users.
     */
    async listUsersRolesRaw(requestParameters: EnterpriseApiListUsersRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: Array<RoleDTO>; }>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling listUsersRoles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/users/roles/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RolesSearchQueryToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:*`.
     * List roles assigned to multiple users.
     */
    async listUsersRoles(requestParameters: EnterpriseApiListUsersRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: Array<RoleDTO>; }> {
        const response = await this.listUsersRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * It performs Assertion Consumer Service (ACS).
     */
    async postACSRaw(requestParameters: EnterpriseApiPostACSRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['relayState'] != null) {
            queryParameters['RelayState'] = requestParameters['relayState'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/saml/acs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * It performs Assertion Consumer Service (ACS).
     */
    async postACS(requestParameters: EnterpriseApiPostACSRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postACSRaw(requestParameters, initOverrides);
    }

    /**
     * You need to have a permission with action `licensing:update`.
     * Create license token.
     */
    async postLicenseTokenRaw(requestParameters: EnterpriseApiPostLicenseTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Token>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling postLicenseToken().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/licensing/token`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DeleteTokenCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenFromJSON(jsonValue));
    }

    /**
     * You need to have a permission with action `licensing:update`.
     * Create license token.
     */
    async postLicenseToken(requestParameters: EnterpriseApiPostLicenseTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Token> {
        const response = await this.postLicenseTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Manually ask license issuer for a new token. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:update`.
     * Manually force license refresh.
     */
    async postRenewLicenseTokenRaw(requestParameters: EnterpriseApiPostRenewLicenseTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling postRenewLicenseToken().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/licensing/token/renew`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Manually ask license issuer for a new token. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:update`.
     * Manually force license refresh.
     */
    async postRenewLicenseToken(requestParameters: EnterpriseApiPostRenewLicenseTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postRenewLicenseTokenRaw(requestParameters, initOverrides);
    }

    /**
     * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
     * It performs Single Logout (SLO) callback.
     */
    async postSLORaw(requestParameters: EnterpriseApiPostSLORequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['sAMLRequest'] != null) {
            queryParameters['SAMLRequest'] = requestParameters['sAMLRequest'];
        }

        if (requestParameters['sAMLResponse'] != null) {
            queryParameters['SAMLResponse'] = requestParameters['sAMLResponse'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/saml/slo`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
     * It performs Single Logout (SLO) callback.
     */
    async postSLO(requestParameters: EnterpriseApiPostSLORequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postSLORaw(requestParameters, initOverrides);
    }

    /**
     * You need to have a permission with action `licensing:read`.
     * Refresh license stats.
     */
    async refreshLicenseStatsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ActiveUserStats>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/licensing/refresh-stats`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ActiveUserStatsFromJSON(jsonValue));
    }

    /**
     * You need to have a permission with action `licensing:read`.
     * Refresh license stats.
     */
    async refreshLicenseStats(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ActiveUserStats> {
        const response = await this.refreshLicenseStatsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Remove External Group.
     */
    async removeTeamGroupApiQueryRaw(requestParameters: EnterpriseApiRemoveTeamGroupApiQueryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['teamId'] == null) {
            throw new runtime.RequiredError(
                'teamId',
                'Required parameter "teamId" was null or undefined when calling removeTeamGroupApiQuery().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['groupId'] != null) {
            queryParameters['groupId'] = requestParameters['groupId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/teams/{teamId}/groups`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters['teamId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Remove External Group.
     */
    async removeTeamGroupApiQuery(requestParameters: EnterpriseApiRemoveTeamGroupApiQueryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.removeTeamGroupApiQueryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`.
     * Remove team role.
     */
    async removeTeamRoleRaw(requestParameters: EnterpriseApiRemoveTeamRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['roleUID'] == null) {
            throw new runtime.RequiredError(
                'roleUID',
                'Required parameter "roleUID" was null or undefined when calling removeTeamRole().'
            );
        }

        if (requestParameters['teamId'] == null) {
            throw new runtime.RequiredError(
                'teamId',
                'Required parameter "teamId" was null or undefined when calling removeTeamRole().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/teams/{teamId}/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters['roleUID']))).replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters['teamId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`.
     * Remove team role.
     */
    async removeTeamRole(requestParameters: EnterpriseApiRemoveTeamRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.removeTeamRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Revoke a role from a user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
     * Remove a user role assignment.
     */
    async removeUserRoleRaw(requestParameters: EnterpriseApiRemoveUserRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['roleUID'] == null) {
            throw new runtime.RequiredError(
                'roleUID',
                'Required parameter "roleUID" was null or undefined when calling removeUserRole().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling removeUserRole().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['global'] != null) {
            queryParameters['global'] = requestParameters['global'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/users/{userId}/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters['roleUID']))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Revoke a role from a user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
     * Remove a user role assignment.
     */
    async removeUserRole(requestParameters: EnterpriseApiRemoveUserRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.removeUserRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Available to all users and with a valid license.
     * Render report for multiple dashboards.
     */
    async renderReportPDFsRaw(requestParameters: EnterpriseApiRenderReportPDFsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<number>>> {
        const queryParameters: any = {};

        if (requestParameters['dashboardID'] != null) {
            queryParameters['dashboardID'] = requestParameters['dashboardID'];
        }

        if (requestParameters['orientation'] != null) {
            queryParameters['orientation'] = requestParameters['orientation'];
        }

        if (requestParameters['layout'] != null) {
            queryParameters['layout'] = requestParameters['layout'];
        }

        if (requestParameters['title'] != null) {
            queryParameters['title'] = requestParameters['title'];
        }

        if (requestParameters['scaleFactor'] != null) {
            queryParameters['scaleFactor'] = requestParameters['scaleFactor'];
        }

        if (requestParameters['includeTables'] != null) {
            queryParameters['includeTables'] = requestParameters['includeTables'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/reports/render/pdfs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Available to all users and with a valid license.
     * Render report for multiple dashboards.
     */
    async renderReportPDFs(requestParameters: EnterpriseApiRenderReportPDFsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<number>> {
        const response = await this.renderReportPDFsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:write`xx.
     * Save settings.
     */
    async saveReportSettingsRaw(requestParameters: EnterpriseApiSaveReportSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling saveReportSettings().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/reports/settings`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReportSettingsToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:write`xx.
     * Save settings.
     */
    async saveReportSettings(requestParameters: EnterpriseApiSaveReportSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.saveReportSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the result of the search through access-control role assignments.  You need to have a permission with action `teams.roles:read` on scope `teams:*` and a permission with action `users.roles:read` on scope `users:*`.
     * Debug permissions.
     */
    async searchResultRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResult>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/assignments/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchResultFromJSON(jsonValue));
    }

    /**
     * Returns the result of the search through access-control role assignments.  You need to have a permission with action `teams.roles:read` on scope `teams:*` and a permission with action `users.roles:read` on scope `users:*`.
     * Debug permissions.
     */
    async searchResult(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResult> {
        const response = await this.searchResultRaw(initOverrides);
        return await response.value();
    }

    /**
     * Generate and send a report. This API waits for the report to be generated before returning. We recommend that you set the client’s timeout to at least 60 seconds. Available to org admins only and with a valid license.  Only available in Grafana Enterprise v7.0+. This API endpoint is experimental and may be deprecated in a future release. On deprecation, a migration strategy will be provided and the endpoint will remain functional until the next major release of Grafana.  You need to have a permission with action `reports:send`.
     * Send a report.
     */
    async sendReportRaw(requestParameters: EnterpriseApiSendReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling sendReport().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/reports/email`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReportEmailToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Generate and send a report. This API waits for the report to be generated before returning. We recommend that you set the client’s timeout to at least 60 seconds. Available to org admins only and with a valid license.  Only available in Grafana Enterprise v7.0+. This API endpoint is experimental and may be deprecated in a future release. On deprecation, a migration strategy will be provided and the endpoint will remain functional until the next major release of Grafana.  You need to have a permission with action `reports:send`.
     * Send a report.
     */
    async sendReport(requestParameters: EnterpriseApiSendReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.sendReportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Available to org admins only and with a valid license.  You need to have a permission with action `reports:send`.
     * Send test report via email.
     */
    async sendTestEmailRaw(requestParameters: EnterpriseApiSendTestEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling sendTestEmail().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/reports/test-email`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateOrUpdateReportConfigToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Available to org admins only and with a valid license.  You need to have a permission with action `reports:send`.
     * Send test report via email.
     */
    async sendTestEmail(requestParameters: EnterpriseApiSendTestEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.sendTestEmailRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
     * Set role assignments.
     */
    async setRoleAssignmentsRaw(requestParameters: EnterpriseApiSetRoleAssignmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RoleAssignmentsDTO>> {
        if (requestParameters['roleUID'] == null) {
            throw new runtime.RequiredError(
                'roleUID',
                'Required parameter "roleUID" was null or undefined when calling setRoleAssignments().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling setRoleAssignments().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/roles/{roleUID}/assignments`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters['roleUID']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SetRoleAssignmentsCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleAssignmentsDTOFromJSON(jsonValue));
    }

    /**
     * Set role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
     * Set role assignments.
     */
    async setRoleAssignments(requestParameters: EnterpriseApiSetRoleAssignmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RoleAssignmentsDTO> {
        const response = await this.setRoleAssignmentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each.
     * Update team role.
     */
    async setTeamRolesRaw(requestParameters: EnterpriseApiSetTeamRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['teamId'] == null) {
            throw new runtime.RequiredError(
                'teamId',
                'Required parameter "teamId" was null or undefined when calling setTeamRoles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/teams/{teamId}/roles`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters['teamId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each.
     * Update team role.
     */
    async setTeamRoles(requestParameters: EnterpriseApiSetTeamRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.setTeamRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user. If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.  You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
     * Set user role assignments.
     */
    async setUserRolesRaw(requestParameters: EnterpriseApiSetUserRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling setUserRoles().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling setUserRoles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/users/{userId}/roles`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SetUserRolesCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user. If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.  You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
     * Set user role assignments.
     */
    async setUserRoles(requestParameters: EnterpriseApiSetUserRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.setUserRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Test a recording rule.
     */
    async testCreateRecordingRuleRaw(requestParameters: EnterpriseApiTestCreateRecordingRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling testCreateRecordingRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/recording-rules/test`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecordingRuleJSONToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Test a recording rule.
     */
    async testCreateRecordingRule(requestParameters: EnterpriseApiTestCreateRecordingRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.testCreateRecordingRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the active status of a rule.
     */
    async updateRecordingRuleRaw(requestParameters: EnterpriseApiUpdateRecordingRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecordingRuleJSON>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling updateRecordingRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/recording-rules`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RecordingRuleJSONToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecordingRuleJSONFromJSON(jsonValue));
    }

    /**
     * Update the active status of a rule.
     */
    async updateRecordingRule(requestParameters: EnterpriseApiUpdateRecordingRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecordingRuleJSON> {
        const response = await this.updateRecordingRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.admin:write` with scope `reports:id:<report ID>`.
     * Update a report.
     */
    async updateReportRaw(requestParameters: EnterpriseApiUpdateReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateReport().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling updateReport().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/reports/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CreateOrUpdateReportConfigToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.admin:write` with scope `reports:id:<report ID>`.
     * Update a report.
     */
    async updateReport(requestParameters: EnterpriseApiUpdateReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.updateReportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
     * Update a custom role.
     */
    async updateRoleRaw(requestParameters: EnterpriseApiUpdateRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RoleDTO>> {
        if (requestParameters['roleUID'] == null) {
            throw new runtime.RequiredError(
                'roleUID',
                'Required parameter "roleUID" was null or undefined when calling updateRole().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling updateRole().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters['roleUID']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateRoleCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleDTOFromJSON(jsonValue));
    }

    /**
     * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
     * Update a custom role.
     */
    async updateRole(requestParameters: EnterpriseApiUpdateRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RoleDTO> {
        const response = await this.updateRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
