/* tslint:disable */
/* eslint-disable */
/**
 * Grafana HTTP API.
 * The Grafana backend exposes an HTTP API, the same API is used by the frontend to do everything from saving dashboards, creating users and updating data sources.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: hello@grafana.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime.js';
import type {
  AddTeamRoleCommand,
  AddUserRoleCommand,
  CreateRoleForm,
  Description,
  ErrorResponseBody,
  ResourcePermissionDTO,
  RoleAssignmentsDTO,
  RoleDTO,
  RolesSearchQuery,
  SetPermissionCommand,
  SetPermissionsCommand,
  SetRoleAssignmentsCommand,
  SetUserRolesCommand,
  SuccessResponseBody,
  UpdateRoleCommand,
} from '../models/index.js';
import {
    AddTeamRoleCommandFromJSON,
    AddTeamRoleCommandToJSON,
    AddUserRoleCommandFromJSON,
    AddUserRoleCommandToJSON,
    CreateRoleFormFromJSON,
    CreateRoleFormToJSON,
    DescriptionFromJSON,
    DescriptionToJSON,
    ErrorResponseBodyFromJSON,
    ErrorResponseBodyToJSON,
    ResourcePermissionDTOFromJSON,
    ResourcePermissionDTOToJSON,
    RoleAssignmentsDTOFromJSON,
    RoleAssignmentsDTOToJSON,
    RoleDTOFromJSON,
    RoleDTOToJSON,
    RolesSearchQueryFromJSON,
    RolesSearchQueryToJSON,
    SetPermissionCommandFromJSON,
    SetPermissionCommandToJSON,
    SetPermissionsCommandFromJSON,
    SetPermissionsCommandToJSON,
    SetRoleAssignmentsCommandFromJSON,
    SetRoleAssignmentsCommandToJSON,
    SetUserRolesCommandFromJSON,
    SetUserRolesCommandToJSON,
    SuccessResponseBodyFromJSON,
    SuccessResponseBodyToJSON,
    UpdateRoleCommandFromJSON,
    UpdateRoleCommandToJSON,
} from '../models/index.js';

export interface AccessControlApiAddTeamRoleRequest {
    teamId: number;
    body: AddTeamRoleCommand;
}

export interface AccessControlApiAddUserRoleRequest {
    userId: number;
    body: AddUserRoleCommand;
}

export interface AccessControlApiCreateRoleRequest {
    body: CreateRoleForm;
}

export interface AccessControlApiDeleteRoleRequest {
    roleUID: string;
    force?: boolean;
    global?: boolean;
}

export interface AccessControlApiGetResourceDescriptionRequest {
    resource: string;
}

export interface AccessControlApiGetResourcePermissionsRequest {
    resource: string;
    resourceID: string;
}

export interface AccessControlApiGetRoleRequest {
    roleUID: string;
}

export interface AccessControlApiGetRoleAssignmentsRequest {
    roleUID: string;
}

export interface AccessControlApiListRolesRequest {
    delegatable?: boolean;
    includeHidden?: boolean;
}

export interface AccessControlApiListTeamRolesRequest {
    teamId: number;
}

export interface AccessControlApiListTeamsRolesRequest {
    body: RolesSearchQuery;
}

export interface AccessControlApiListUserRolesRequest {
    userId: number;
}

export interface AccessControlApiListUsersRolesRequest {
    body: RolesSearchQuery;
}

export interface AccessControlApiRemoveTeamRoleRequest {
    roleUID: string;
    teamId: number;
}

export interface AccessControlApiRemoveUserRoleRequest {
    roleUID: string;
    userId: number;
    global?: boolean;
}

export interface AccessControlApiSetResourcePermissionsRequest {
    resource: string;
    resourceID: string;
    body: SetPermissionsCommand;
}

export interface AccessControlApiSetResourcePermissionsForBuiltInRoleRequest {
    resource: string;
    resourceID: string;
    builtInRole: string;
    body: SetPermissionCommand;
}

export interface AccessControlApiSetResourcePermissionsForTeamRequest {
    resource: string;
    resourceID: string;
    teamID: number;
    body: SetPermissionCommand;
}

export interface AccessControlApiSetResourcePermissionsForUserRequest {
    resource: string;
    resourceID: string;
    userID: number;
    body: SetPermissionCommand;
}

export interface AccessControlApiSetRoleAssignmentsRequest {
    roleUID: string;
    body: SetRoleAssignmentsCommand;
}

export interface AccessControlApiSetTeamRolesRequest {
    teamId: number;
}

export interface AccessControlApiSetUserRolesRequest {
    userId: number;
    body: SetUserRolesCommand;
}

export interface AccessControlApiUpdateRoleRequest {
    roleUID: string;
    body: UpdateRoleCommand;
}

/**
 * 
 */
export class AccessControlApi extends runtime.BaseAPI {

    /**
     * You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`.
     * Add team role.
     */
    async addTeamRoleRaw(requestParameters: AccessControlApiAddTeamRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['teamId'] == null) {
            throw new runtime.RequiredError(
                'teamId',
                'Required parameter "teamId" was null or undefined when calling addTeamRole().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling addTeamRole().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/teams/{teamId}/roles`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters['teamId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddTeamRoleCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`.
     * Add team role.
     */
    async addTeamRole(requestParameters: AccessControlApiAddTeamRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.addTeamRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Assign a role to a specific user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
     * Add a user role assignment.
     */
    async addUserRoleRaw(requestParameters: AccessControlApiAddUserRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling addUserRole().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling addUserRole().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/users/{userId}/roles`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddUserRoleCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Assign a role to a specific user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
     * Add a user role assignment.
     */
    async addUserRole(requestParameters: AccessControlApiAddUserRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.addUserRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.  You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
     * Create a new custom role.
     */
    async createRoleRaw(requestParameters: AccessControlApiCreateRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RoleDTO>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createRole().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/roles`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateRoleFormToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleDTOFromJSON(jsonValue));
    }

    /**
     * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.  You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
     * Create a new custom role.
     */
    async createRole(requestParameters: AccessControlApiCreateRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RoleDTO> {
        const response = await this.createRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.  You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
     * Delete a custom role.
     */
    async deleteRoleRaw(requestParameters: AccessControlApiDeleteRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['roleUID'] == null) {
            throw new runtime.RequiredError(
                'roleUID',
                'Required parameter "roleUID" was null or undefined when calling deleteRole().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        if (requestParameters['global'] != null) {
            queryParameters['global'] = requestParameters['global'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters['roleUID']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.  You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
     * Delete a custom role.
     */
    async deleteRole(requestParameters: AccessControlApiDeleteRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.deleteRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns an indicator to check if fine-grained access control is enabled or not.  You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
     * Get status.
     */
    async getAccessControlStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<number>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<number>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Returns an indicator to check if fine-grained access control is enabled or not.  You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
     * Get status.
     */
    async getAccessControlStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<number> {
        const response = await this.getAccessControlStatusRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a description of a resource\'s access control properties.
     */
    async getResourceDescriptionRaw(requestParameters: AccessControlApiGetResourceDescriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Description>> {
        if (requestParameters['resource'] == null) {
            throw new runtime.RequiredError(
                'resource',
                'Required parameter "resource" was null or undefined when calling getResourceDescription().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/{resource}/description`.replace(`{${"resource"}}`, encodeURIComponent(String(requestParameters['resource']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DescriptionFromJSON(jsonValue));
    }

    /**
     * Get a description of a resource\'s access control properties.
     */
    async getResourceDescription(requestParameters: AccessControlApiGetResourceDescriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Description> {
        const response = await this.getResourceDescriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get permissions for a resource.
     */
    async getResourcePermissionsRaw(requestParameters: AccessControlApiGetResourcePermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ResourcePermissionDTO>>> {
        if (requestParameters['resource'] == null) {
            throw new runtime.RequiredError(
                'resource',
                'Required parameter "resource" was null or undefined when calling getResourcePermissions().'
            );
        }

        if (requestParameters['resourceID'] == null) {
            throw new runtime.RequiredError(
                'resourceID',
                'Required parameter "resourceID" was null or undefined when calling getResourcePermissions().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/{resource}/{resourceID}`.replace(`{${"resource"}}`, encodeURIComponent(String(requestParameters['resource']))).replace(`{${"resourceID"}}`, encodeURIComponent(String(requestParameters['resourceID']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ResourcePermissionDTOFromJSON));
    }

    /**
     * Get permissions for a resource.
     */
    async getResourcePermissions(requestParameters: AccessControlApiGetResourcePermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ResourcePermissionDTO>> {
        const response = await this.getResourcePermissionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a role for the given UID.  You need to have a permission with action `roles:read` and scope `roles:*`.
     * Get a role.
     */
    async getRoleRaw(requestParameters: AccessControlApiGetRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RoleDTO>> {
        if (requestParameters['roleUID'] == null) {
            throw new runtime.RequiredError(
                'roleUID',
                'Required parameter "roleUID" was null or undefined when calling getRole().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters['roleUID']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleDTOFromJSON(jsonValue));
    }

    /**
     * Get a role for the given UID.  You need to have a permission with action `roles:read` and scope `roles:*`.
     * Get a role.
     */
    async getRole(requestParameters: AccessControlApiGetRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RoleDTO> {
        const response = await this.getRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get role assignments for the role with the given UID. Does not include role assignments mapped through group attribute sync.  You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
     * Get role assignments.
     */
    async getRoleAssignmentsRaw(requestParameters: AccessControlApiGetRoleAssignmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RoleAssignmentsDTO>> {
        if (requestParameters['roleUID'] == null) {
            throw new runtime.RequiredError(
                'roleUID',
                'Required parameter "roleUID" was null or undefined when calling getRoleAssignments().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/roles/{roleUID}/assignments`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters['roleUID']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleAssignmentsDTOFromJSON(jsonValue));
    }

    /**
     * Get role assignments for the role with the given UID. Does not include role assignments mapped through group attribute sync.  You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
     * Get role assignments.
     */
    async getRoleAssignments(requestParameters: AccessControlApiGetRoleAssignmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RoleAssignmentsDTO> {
        const response = await this.getRoleAssignmentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.  You need to have a permission with action `roles:read` and scope `roles:*`.  The `delegatable` flag reduces the set of roles to only those for which the signed-in user has permissions to assign.
     * Get all roles.
     */
    async listRolesRaw(requestParameters: AccessControlApiListRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RoleDTO>>> {
        const queryParameters: any = {};

        if (requestParameters['delegatable'] != null) {
            queryParameters['delegatable'] = requestParameters['delegatable'];
        }

        if (requestParameters['includeHidden'] != null) {
            queryParameters['includeHidden'] = requestParameters['includeHidden'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/roles`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RoleDTOFromJSON));
    }

    /**
     * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.  You need to have a permission with action `roles:read` and scope `roles:*`.  The `delegatable` flag reduces the set of roles to only those for which the signed-in user has permissions to assign.
     * Get all roles.
     */
    async listRoles(requestParameters: AccessControlApiListRolesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RoleDTO>> {
        const response = await this.listRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`.
     * Get team roles.
     */
    async listTeamRolesRaw(requestParameters: AccessControlApiListTeamRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['teamId'] == null) {
            throw new runtime.RequiredError(
                'teamId',
                'Required parameter "teamId" was null or undefined when calling listTeamRoles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/teams/{teamId}/roles`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters['teamId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`.
     * Get team roles.
     */
    async listTeamRoles(requestParameters: AccessControlApiListTeamRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.listTeamRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists the roles that have been directly assigned to the given teams.  You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
     * List roles assigned to multiple teams.
     */
    async listTeamsRolesRaw(requestParameters: AccessControlApiListTeamsRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: Array<RoleDTO>; }>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling listTeamsRoles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/teams/roles/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RolesSearchQueryToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Lists the roles that have been directly assigned to the given teams.  You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
     * List roles assigned to multiple teams.
     */
    async listTeamsRoles(requestParameters: AccessControlApiListTeamsRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: Array<RoleDTO>; }> {
        const response = await this.listTeamsRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
     * List roles assigned to a user.
     */
    async listUserRolesRaw(requestParameters: AccessControlApiListUserRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RoleDTO>>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling listUserRoles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/users/{userId}/roles`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RoleDTOFromJSON));
    }

    /**
     * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
     * List roles assigned to a user.
     */
    async listUserRoles(requestParameters: AccessControlApiListUserRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RoleDTO>> {
        const response = await this.listUserRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:*`.
     * List roles assigned to multiple users.
     */
    async listUsersRolesRaw(requestParameters: AccessControlApiListUsersRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: Array<RoleDTO>; }>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling listUsersRoles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/users/roles/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RolesSearchQueryToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:*`.
     * List roles assigned to multiple users.
     */
    async listUsersRoles(requestParameters: AccessControlApiListUsersRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: Array<RoleDTO>; }> {
        const response = await this.listUsersRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`.
     * Remove team role.
     */
    async removeTeamRoleRaw(requestParameters: AccessControlApiRemoveTeamRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['roleUID'] == null) {
            throw new runtime.RequiredError(
                'roleUID',
                'Required parameter "roleUID" was null or undefined when calling removeTeamRole().'
            );
        }

        if (requestParameters['teamId'] == null) {
            throw new runtime.RequiredError(
                'teamId',
                'Required parameter "teamId" was null or undefined when calling removeTeamRole().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/teams/{teamId}/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters['roleUID']))).replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters['teamId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`.
     * Remove team role.
     */
    async removeTeamRole(requestParameters: AccessControlApiRemoveTeamRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.removeTeamRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Revoke a role from a user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
     * Remove a user role assignment.
     */
    async removeUserRoleRaw(requestParameters: AccessControlApiRemoveUserRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['roleUID'] == null) {
            throw new runtime.RequiredError(
                'roleUID',
                'Required parameter "roleUID" was null or undefined when calling removeUserRole().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling removeUserRole().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['global'] != null) {
            queryParameters['global'] = requestParameters['global'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/users/{userId}/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters['roleUID']))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Revoke a role from a user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
     * Remove a user role assignment.
     */
    async removeUserRole(requestParameters: AccessControlApiRemoveUserRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.removeUserRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to one or many assignment types. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
     * Set resource permissions.
     */
    async setResourcePermissionsRaw(requestParameters: AccessControlApiSetResourcePermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['resource'] == null) {
            throw new runtime.RequiredError(
                'resource',
                'Required parameter "resource" was null or undefined when calling setResourcePermissions().'
            );
        }

        if (requestParameters['resourceID'] == null) {
            throw new runtime.RequiredError(
                'resourceID',
                'Required parameter "resourceID" was null or undefined when calling setResourcePermissions().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling setResourcePermissions().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/{resource}/{resourceID}`.replace(`{${"resource"}}`, encodeURIComponent(String(requestParameters['resource']))).replace(`{${"resourceID"}}`, encodeURIComponent(String(requestParameters['resourceID']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SetPermissionsCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to one or many assignment types. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
     * Set resource permissions.
     */
    async setResourcePermissions(requestParameters: AccessControlApiSetResourcePermissionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.setResourcePermissionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a built-in role. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
     * Set resource permissions for a built-in role.
     */
    async setResourcePermissionsForBuiltInRoleRaw(requestParameters: AccessControlApiSetResourcePermissionsForBuiltInRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['resource'] == null) {
            throw new runtime.RequiredError(
                'resource',
                'Required parameter "resource" was null or undefined when calling setResourcePermissionsForBuiltInRole().'
            );
        }

        if (requestParameters['resourceID'] == null) {
            throw new runtime.RequiredError(
                'resourceID',
                'Required parameter "resourceID" was null or undefined when calling setResourcePermissionsForBuiltInRole().'
            );
        }

        if (requestParameters['builtInRole'] == null) {
            throw new runtime.RequiredError(
                'builtInRole',
                'Required parameter "builtInRole" was null or undefined when calling setResourcePermissionsForBuiltInRole().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling setResourcePermissionsForBuiltInRole().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/{resource}/{resourceID}/builtInRoles/{builtInRole}`.replace(`{${"resource"}}`, encodeURIComponent(String(requestParameters['resource']))).replace(`{${"resourceID"}}`, encodeURIComponent(String(requestParameters['resourceID']))).replace(`{${"builtInRole"}}`, encodeURIComponent(String(requestParameters['builtInRole']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SetPermissionCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a built-in role. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
     * Set resource permissions for a built-in role.
     */
    async setResourcePermissionsForBuiltInRole(requestParameters: AccessControlApiSetResourcePermissionsForBuiltInRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.setResourcePermissionsForBuiltInRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a team. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
     * Set resource permissions for a team.
     */
    async setResourcePermissionsForTeamRaw(requestParameters: AccessControlApiSetResourcePermissionsForTeamRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['resource'] == null) {
            throw new runtime.RequiredError(
                'resource',
                'Required parameter "resource" was null or undefined when calling setResourcePermissionsForTeam().'
            );
        }

        if (requestParameters['resourceID'] == null) {
            throw new runtime.RequiredError(
                'resourceID',
                'Required parameter "resourceID" was null or undefined when calling setResourcePermissionsForTeam().'
            );
        }

        if (requestParameters['teamID'] == null) {
            throw new runtime.RequiredError(
                'teamID',
                'Required parameter "teamID" was null or undefined when calling setResourcePermissionsForTeam().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling setResourcePermissionsForTeam().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/{resource}/{resourceID}/teams/{teamID}`.replace(`{${"resource"}}`, encodeURIComponent(String(requestParameters['resource']))).replace(`{${"resourceID"}}`, encodeURIComponent(String(requestParameters['resourceID']))).replace(`{${"teamID"}}`, encodeURIComponent(String(requestParameters['teamID']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SetPermissionCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a team. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
     * Set resource permissions for a team.
     */
    async setResourcePermissionsForTeam(requestParameters: AccessControlApiSetResourcePermissionsForTeamRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.setResourcePermissionsForTeamRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a user or a service account. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
     * Set resource permissions for a user.
     */
    async setResourcePermissionsForUserRaw(requestParameters: AccessControlApiSetResourcePermissionsForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['resource'] == null) {
            throw new runtime.RequiredError(
                'resource',
                'Required parameter "resource" was null or undefined when calling setResourcePermissionsForUser().'
            );
        }

        if (requestParameters['resourceID'] == null) {
            throw new runtime.RequiredError(
                'resourceID',
                'Required parameter "resourceID" was null or undefined when calling setResourcePermissionsForUser().'
            );
        }

        if (requestParameters['userID'] == null) {
            throw new runtime.RequiredError(
                'userID',
                'Required parameter "userID" was null or undefined when calling setResourcePermissionsForUser().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling setResourcePermissionsForUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/{resource}/{resourceID}/users/{userID}`.replace(`{${"resource"}}`, encodeURIComponent(String(requestParameters['resource']))).replace(`{${"resourceID"}}`, encodeURIComponent(String(requestParameters['resourceID']))).replace(`{${"userID"}}`, encodeURIComponent(String(requestParameters['userID']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SetPermissionCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a user or a service account. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
     * Set resource permissions for a user.
     */
    async setResourcePermissionsForUser(requestParameters: AccessControlApiSetResourcePermissionsForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.setResourcePermissionsForUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
     * Set role assignments.
     */
    async setRoleAssignmentsRaw(requestParameters: AccessControlApiSetRoleAssignmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RoleAssignmentsDTO>> {
        if (requestParameters['roleUID'] == null) {
            throw new runtime.RequiredError(
                'roleUID',
                'Required parameter "roleUID" was null or undefined when calling setRoleAssignments().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling setRoleAssignments().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/roles/{roleUID}/assignments`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters['roleUID']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SetRoleAssignmentsCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleAssignmentsDTOFromJSON(jsonValue));
    }

    /**
     * Set role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
     * Set role assignments.
     */
    async setRoleAssignments(requestParameters: AccessControlApiSetRoleAssignmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RoleAssignmentsDTO> {
        const response = await this.setRoleAssignmentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each.
     * Update team role.
     */
    async setTeamRolesRaw(requestParameters: AccessControlApiSetTeamRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['teamId'] == null) {
            throw new runtime.RequiredError(
                'teamId',
                'Required parameter "teamId" was null or undefined when calling setTeamRoles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/teams/{teamId}/roles`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters['teamId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each.
     * Update team role.
     */
    async setTeamRoles(requestParameters: AccessControlApiSetTeamRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.setTeamRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user. Roles mapped through group attribute sync are not impacted. If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.  You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
     * Set user role assignments.
     */
    async setUserRolesRaw(requestParameters: AccessControlApiSetUserRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling setUserRoles().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling setUserRoles().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/users/{userId}/roles`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SetUserRolesCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user. Roles mapped through group attribute sync are not impacted. If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.  You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
     * Set user role assignments.
     */
    async setUserRoles(requestParameters: AccessControlApiSetUserRolesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.setUserRolesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
     * Update a custom role.
     */
    async updateRoleRaw(requestParameters: AccessControlApiUpdateRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RoleDTO>> {
        if (requestParameters['roleUID'] == null) {
            throw new runtime.RequiredError(
                'roleUID',
                'Required parameter "roleUID" was null or undefined when calling updateRole().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling updateRole().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/access-control/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters['roleUID']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateRoleCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleDTOFromJSON(jsonValue));
    }

    /**
     * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
     * Update a custom role.
     */
    async updateRole(requestParameters: AccessControlApiUpdateRoleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RoleDTO> {
        const response = await this.updateRoleRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
