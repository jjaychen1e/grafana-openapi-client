/* tslint:disable */
/* eslint-disable */
/**
 * Grafana HTTP API.
 * The Grafana backend exposes an HTTP API, the same API is used by the frontend to do everything from saving dashboards, creating users and updating data sources.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: hello@grafana.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime.js';
import type {
  AddDataSource200Response,
  AddDataSourceCommand,
  DataSource,
  DataSourceListItemDTO,
  DeleteDataSourceByName200Response,
  ErrorResponseBody,
  GetDataSourceIdByName200Response,
  SuccessResponseBody,
  UpdateDataSourceCommand,
} from '../models/index.js';
import {
    AddDataSource200ResponseFromJSON,
    AddDataSource200ResponseToJSON,
    AddDataSourceCommandFromJSON,
    AddDataSourceCommandToJSON,
    DataSourceFromJSON,
    DataSourceToJSON,
    DataSourceListItemDTOFromJSON,
    DataSourceListItemDTOToJSON,
    DeleteDataSourceByName200ResponseFromJSON,
    DeleteDataSourceByName200ResponseToJSON,
    ErrorResponseBodyFromJSON,
    ErrorResponseBodyToJSON,
    GetDataSourceIdByName200ResponseFromJSON,
    GetDataSourceIdByName200ResponseToJSON,
    SuccessResponseBodyFromJSON,
    SuccessResponseBodyToJSON,
    UpdateDataSourceCommandFromJSON,
    UpdateDataSourceCommandToJSON,
} from '../models/index.js';

export interface DatasourcesApiAddDataSourceRequest {
    body: AddDataSourceCommand;
}

export interface DatasourcesApiCallDatasourceResourceByIDRequest {
    datasourceProxyRoute: string;
    id: string;
}

export interface DatasourcesApiCallDatasourceResourceWithUIDRequest {
    datasourceProxyRoute: string;
    uid: string;
}

export interface DatasourcesApiCheckDatasourceHealthByIDRequest {
    id: string;
}

export interface DatasourcesApiCheckDatasourceHealthWithUIDRequest {
    uid: string;
}

export interface DatasourcesApiDatasourceProxyDELETEByUIDcallsRequest {
    uid: string;
    datasourceProxyRoute: string;
}

export interface DatasourcesApiDatasourceProxyDELETEcallsRequest {
    id: string;
    datasourceProxyRoute: string;
}

export interface DatasourcesApiDatasourceProxyGETByUIDcallsRequest {
    datasourceProxyRoute: string;
    uid: string;
}

export interface DatasourcesApiDatasourceProxyGETcallsRequest {
    datasourceProxyRoute: string;
    id: string;
}

export interface DatasourcesApiDatasourceProxyPOSTByUIDcallsRequest {
    datasourceProxyRoute: string;
    uid: string;
    datasourceProxyParam: object;
}

export interface DatasourcesApiDatasourceProxyPOSTcallsRequest {
    datasourceProxyRoute: string;
    id: string;
    datasourceProxyParam: object;
}

export interface DatasourcesApiDeleteDataSourceByIDRequest {
    id: string;
}

export interface DatasourcesApiDeleteDataSourceByNameRequest {
    name: string;
}

export interface DatasourcesApiDeleteDataSourceByUIDRequest {
    uid: string;
}

export interface DatasourcesApiGetDataSourceByIDRequest {
    id: string;
}

export interface DatasourcesApiGetDataSourceByNameRequest {
    name: string;
}

export interface DatasourcesApiGetDataSourceByUIDRequest {
    uid: string;
}

export interface DatasourcesApiGetDataSourceIdByNameRequest {
    name: string;
}

export interface DatasourcesApiUpdateDataSourceByIDRequest {
    id: string;
    body: UpdateDataSourceCommand;
}

export interface DatasourcesApiUpdateDataSourceByUIDRequest {
    uid: string;
    body: UpdateDataSourceCommand;
}

/**
 * 
 */
export class DatasourcesApi extends runtime.BaseAPI {

    /**
     * By defining `password` and `basicAuthPassword` under secureJsonData property Grafana encrypts them securely as an encrypted blob in the database. The response then lists the encrypted fields under secureJsonFields.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:create`
     * Create a data source.
     */
    async addDataSourceRaw(requestParameters: DatasourcesApiAddDataSourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddDataSource200Response>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling addDataSource().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddDataSourceCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddDataSource200ResponseFromJSON(jsonValue));
    }

    /**
     * By defining `password` and `basicAuthPassword` under secureJsonData property Grafana encrypts them securely as an encrypted blob in the database. The response then lists the encrypted fields under secureJsonFields.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:create`
     * Create a data source.
     */
    async addDataSource(requestParameters: DatasourcesApiAddDataSourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddDataSource200Response> {
        const response = await this.addDataSourceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Please refer to [updated API](#/datasources/callDatasourceResourceWithUID) instead
     * Fetch data source resources by Id.
     * @deprecated
     */
    async callDatasourceResourceByIDRaw(requestParameters: DatasourcesApiCallDatasourceResourceByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['datasourceProxyRoute'] == null) {
            throw new runtime.RequiredError(
                'datasourceProxyRoute',
                'Required parameter "datasourceProxyRoute" was null or undefined when calling callDatasourceResourceByID().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling callDatasourceResourceByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/{id}/resources/{datasource_proxy_route}`.replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(requestParameters['datasourceProxyRoute']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Please refer to [updated API](#/datasources/callDatasourceResourceWithUID) instead
     * Fetch data source resources by Id.
     * @deprecated
     */
    async callDatasourceResourceByID(requestParameters: DatasourcesApiCallDatasourceResourceByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.callDatasourceResourceByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch data source resources.
     */
    async callDatasourceResourceWithUIDRaw(requestParameters: DatasourcesApiCallDatasourceResourceWithUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['datasourceProxyRoute'] == null) {
            throw new runtime.RequiredError(
                'datasourceProxyRoute',
                'Required parameter "datasourceProxyRoute" was null or undefined when calling callDatasourceResourceWithUID().'
            );
        }

        if (requestParameters['uid'] == null) {
            throw new runtime.RequiredError(
                'uid',
                'Required parameter "uid" was null or undefined when calling callDatasourceResourceWithUID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/uid/{uid}/resources/{datasource_proxy_route}`.replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(requestParameters['datasourceProxyRoute']))).replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters['uid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Fetch data source resources.
     */
    async callDatasourceResourceWithUID(requestParameters: DatasourcesApiCallDatasourceResourceWithUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.callDatasourceResourceWithUIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Please refer to [updated API](#/datasources/checkDatasourceHealthWithUID) instead
     * Sends a health check request to the plugin datasource identified by the ID.
     * @deprecated
     */
    async checkDatasourceHealthByIDRaw(requestParameters: DatasourcesApiCheckDatasourceHealthByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling checkDatasourceHealthByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/{id}/health`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Please refer to [updated API](#/datasources/checkDatasourceHealthWithUID) instead
     * Sends a health check request to the plugin datasource identified by the ID.
     * @deprecated
     */
    async checkDatasourceHealthByID(requestParameters: DatasourcesApiCheckDatasourceHealthByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.checkDatasourceHealthByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sends a health check request to the plugin datasource identified by the UID.
     */
    async checkDatasourceHealthWithUIDRaw(requestParameters: DatasourcesApiCheckDatasourceHealthWithUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['uid'] == null) {
            throw new runtime.RequiredError(
                'uid',
                'Required parameter "uid" was null or undefined when calling checkDatasourceHealthWithUID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/uid/{uid}/health`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters['uid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Sends a health check request to the plugin datasource identified by the UID.
     */
    async checkDatasourceHealthWithUID(requestParameters: DatasourcesApiCheckDatasourceHealthWithUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.checkDatasourceHealthWithUIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Proxies all calls to the actual data source.
     * Data source proxy DELETE calls.
     */
    async datasourceProxyDELETEByUIDcallsRaw(requestParameters: DatasourcesApiDatasourceProxyDELETEByUIDcallsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['uid'] == null) {
            throw new runtime.RequiredError(
                'uid',
                'Required parameter "uid" was null or undefined when calling datasourceProxyDELETEByUIDcalls().'
            );
        }

        if (requestParameters['datasourceProxyRoute'] == null) {
            throw new runtime.RequiredError(
                'datasourceProxyRoute',
                'Required parameter "datasourceProxyRoute" was null or undefined when calling datasourceProxyDELETEByUIDcalls().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/proxy/uid/{uid}/{datasource_proxy_route}`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters['uid']))).replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(requestParameters['datasourceProxyRoute']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Proxies all calls to the actual data source.
     * Data source proxy DELETE calls.
     */
    async datasourceProxyDELETEByUIDcalls(requestParameters: DatasourcesApiDatasourceProxyDELETEByUIDcallsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.datasourceProxyDELETEByUIDcallsRaw(requestParameters, initOverrides);
    }

    /**
     * Proxies all calls to the actual data source.  Please refer to [updated API](#/datasources/datasourceProxyDELETEByUIDcalls) instead
     * Data source proxy DELETE calls.
     * @deprecated
     */
    async datasourceProxyDELETEcallsRaw(requestParameters: DatasourcesApiDatasourceProxyDELETEcallsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling datasourceProxyDELETEcalls().'
            );
        }

        if (requestParameters['datasourceProxyRoute'] == null) {
            throw new runtime.RequiredError(
                'datasourceProxyRoute',
                'Required parameter "datasourceProxyRoute" was null or undefined when calling datasourceProxyDELETEcalls().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/proxy/{id}/{datasource_proxy_route}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(requestParameters['datasourceProxyRoute']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Proxies all calls to the actual data source.  Please refer to [updated API](#/datasources/datasourceProxyDELETEByUIDcalls) instead
     * Data source proxy DELETE calls.
     * @deprecated
     */
    async datasourceProxyDELETEcalls(requestParameters: DatasourcesApiDatasourceProxyDELETEcallsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.datasourceProxyDELETEcallsRaw(requestParameters, initOverrides);
    }

    /**
     * Proxies all calls to the actual data source.
     * Data source proxy GET calls.
     */
    async datasourceProxyGETByUIDcallsRaw(requestParameters: DatasourcesApiDatasourceProxyGETByUIDcallsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['datasourceProxyRoute'] == null) {
            throw new runtime.RequiredError(
                'datasourceProxyRoute',
                'Required parameter "datasourceProxyRoute" was null or undefined when calling datasourceProxyGETByUIDcalls().'
            );
        }

        if (requestParameters['uid'] == null) {
            throw new runtime.RequiredError(
                'uid',
                'Required parameter "uid" was null or undefined when calling datasourceProxyGETByUIDcalls().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/proxy/uid/{uid}/{datasource_proxy_route}`.replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(requestParameters['datasourceProxyRoute']))).replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters['uid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Proxies all calls to the actual data source.
     * Data source proxy GET calls.
     */
    async datasourceProxyGETByUIDcalls(requestParameters: DatasourcesApiDatasourceProxyGETByUIDcallsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.datasourceProxyGETByUIDcallsRaw(requestParameters, initOverrides);
    }

    /**
     * Proxies all calls to the actual data source.  Please refer to [updated API](#/datasources/datasourceProxyGETByUIDcalls) instead
     * Data source proxy GET calls.
     * @deprecated
     */
    async datasourceProxyGETcallsRaw(requestParameters: DatasourcesApiDatasourceProxyGETcallsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['datasourceProxyRoute'] == null) {
            throw new runtime.RequiredError(
                'datasourceProxyRoute',
                'Required parameter "datasourceProxyRoute" was null or undefined when calling datasourceProxyGETcalls().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling datasourceProxyGETcalls().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/proxy/{id}/{datasource_proxy_route}`.replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(requestParameters['datasourceProxyRoute']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Proxies all calls to the actual data source.  Please refer to [updated API](#/datasources/datasourceProxyGETByUIDcalls) instead
     * Data source proxy GET calls.
     * @deprecated
     */
    async datasourceProxyGETcalls(requestParameters: DatasourcesApiDatasourceProxyGETcallsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.datasourceProxyGETcallsRaw(requestParameters, initOverrides);
    }

    /**
     * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined
     * Data source proxy POST calls.
     */
    async datasourceProxyPOSTByUIDcallsRaw(requestParameters: DatasourcesApiDatasourceProxyPOSTByUIDcallsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['datasourceProxyRoute'] == null) {
            throw new runtime.RequiredError(
                'datasourceProxyRoute',
                'Required parameter "datasourceProxyRoute" was null or undefined when calling datasourceProxyPOSTByUIDcalls().'
            );
        }

        if (requestParameters['uid'] == null) {
            throw new runtime.RequiredError(
                'uid',
                'Required parameter "uid" was null or undefined when calling datasourceProxyPOSTByUIDcalls().'
            );
        }

        if (requestParameters['datasourceProxyParam'] == null) {
            throw new runtime.RequiredError(
                'datasourceProxyParam',
                'Required parameter "datasourceProxyParam" was null or undefined when calling datasourceProxyPOSTByUIDcalls().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/proxy/uid/{uid}/{datasource_proxy_route}`.replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(requestParameters['datasourceProxyRoute']))).replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters['uid']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['datasourceProxyParam'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined
     * Data source proxy POST calls.
     */
    async datasourceProxyPOSTByUIDcalls(requestParameters: DatasourcesApiDatasourceProxyPOSTByUIDcallsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.datasourceProxyPOSTByUIDcallsRaw(requestParameters, initOverrides);
    }

    /**
     * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined  Please refer to [updated API](#/datasources/datasourceProxyPOSTByUIDcalls) instead
     * Data source proxy POST calls.
     * @deprecated
     */
    async datasourceProxyPOSTcallsRaw(requestParameters: DatasourcesApiDatasourceProxyPOSTcallsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['datasourceProxyRoute'] == null) {
            throw new runtime.RequiredError(
                'datasourceProxyRoute',
                'Required parameter "datasourceProxyRoute" was null or undefined when calling datasourceProxyPOSTcalls().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling datasourceProxyPOSTcalls().'
            );
        }

        if (requestParameters['datasourceProxyParam'] == null) {
            throw new runtime.RequiredError(
                'datasourceProxyParam',
                'Required parameter "datasourceProxyParam" was null or undefined when calling datasourceProxyPOSTcalls().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/proxy/{id}/{datasource_proxy_route}`.replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(requestParameters['datasourceProxyRoute']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['datasourceProxyParam'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined  Please refer to [updated API](#/datasources/datasourceProxyPOSTByUIDcalls) instead
     * Data source proxy POST calls.
     * @deprecated
     */
    async datasourceProxyPOSTcalls(requestParameters: DatasourcesApiDatasourceProxyPOSTcallsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.datasourceProxyPOSTcallsRaw(requestParameters, initOverrides);
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/deleteDataSourceByUID) instead
     * Delete an existing data source by id.
     * @deprecated
     */
    async deleteDataSourceByIDRaw(requestParameters: DatasourcesApiDeleteDataSourceByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteDataSourceByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/deleteDataSourceByUID) instead
     * Delete an existing data source by id.
     * @deprecated
     */
    async deleteDataSourceByID(requestParameters: DatasourcesApiDeleteDataSourceByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.deleteDataSourceByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
     * Delete an existing data source by name.
     */
    async deleteDataSourceByNameRaw(requestParameters: DatasourcesApiDeleteDataSourceByNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteDataSourceByName200Response>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling deleteDataSourceByName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/name/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteDataSourceByName200ResponseFromJSON(jsonValue));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
     * Delete an existing data source by name.
     */
    async deleteDataSourceByName(requestParameters: DatasourcesApiDeleteDataSourceByNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteDataSourceByName200Response> {
        const response = await this.deleteDataSourceByNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
     * Delete an existing data source by UID.
     */
    async deleteDataSourceByUIDRaw(requestParameters: DatasourcesApiDeleteDataSourceByUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['uid'] == null) {
            throw new runtime.RequiredError(
                'uid',
                'Required parameter "uid" was null or undefined when calling deleteDataSourceByUID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/uid/{uid}`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters['uid']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
     * Delete an existing data source by UID.
     */
    async deleteDataSourceByUID(requestParameters: DatasourcesApiDeleteDataSourceByUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.deleteDataSourceByUIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/getDataSourceByUID) instead
     * Get a single data source by Id.
     * @deprecated
     */
    async getDataSourceByIDRaw(requestParameters: DatasourcesApiGetDataSourceByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DataSource>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getDataSourceByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DataSourceFromJSON(jsonValue));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/getDataSourceByUID) instead
     * Get a single data source by Id.
     * @deprecated
     */
    async getDataSourceByID(requestParameters: DatasourcesApiGetDataSourceByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DataSource> {
        const response = await this.getDataSourceByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
     * Get a single data source by Name.
     */
    async getDataSourceByNameRaw(requestParameters: DatasourcesApiGetDataSourceByNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DataSource>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getDataSourceByName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/name/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DataSourceFromJSON(jsonValue));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
     * Get a single data source by Name.
     */
    async getDataSourceByName(requestParameters: DatasourcesApiGetDataSourceByNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DataSource> {
        const response = await this.getDataSourceByNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
     * Get a single data source by UID.
     */
    async getDataSourceByUIDRaw(requestParameters: DatasourcesApiGetDataSourceByUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DataSource>> {
        if (requestParameters['uid'] == null) {
            throw new runtime.RequiredError(
                'uid',
                'Required parameter "uid" was null or undefined when calling getDataSourceByUID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/uid/{uid}`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters['uid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DataSourceFromJSON(jsonValue));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
     * Get a single data source by UID.
     */
    async getDataSourceByUID(requestParameters: DatasourcesApiGetDataSourceByUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DataSource> {
        const response = await this.getDataSourceByUIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
     * Get data source Id by Name.
     */
    async getDataSourceIdByNameRaw(requestParameters: DatasourcesApiGetDataSourceIdByNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetDataSourceIdByName200Response>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getDataSourceIdByName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/id/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters['name']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetDataSourceIdByName200ResponseFromJSON(jsonValue));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
     * Get data source Id by Name.
     */
    async getDataSourceIdByName(requestParameters: DatasourcesApiGetDataSourceIdByNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetDataSourceIdByName200Response> {
        const response = await this.getDataSourceIdByNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scope: `datasources:*`.
     * Get all data sources.
     */
    async getDataSourcesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<DataSourceListItemDTO>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DataSourceListItemDTOFromJSON));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scope: `datasources:*`.
     * Get all data sources.
     */
    async getDataSources(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<DataSourceListItemDTO>> {
        const response = await this.getDataSourcesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the encrypted fields are listed under secureJsonFields section in the response.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/updateDataSourceByUID) instead
     * Update an existing data source by its sequential ID.
     * @deprecated
     */
    async updateDataSourceByIDRaw(requestParameters: DatasourcesApiUpdateDataSourceByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddDataSource200Response>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateDataSourceByID().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling updateDataSourceByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateDataSourceCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddDataSource200ResponseFromJSON(jsonValue));
    }

    /**
     * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the encrypted fields are listed under secureJsonFields section in the response.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/updateDataSourceByUID) instead
     * Update an existing data source by its sequential ID.
     * @deprecated
     */
    async updateDataSourceByID(requestParameters: DatasourcesApiUpdateDataSourceByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddDataSource200Response> {
        const response = await this.updateDataSourceByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the encrypted fields are listed under secureJsonFields section in the response.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:1` (single data source).
     * Update an existing data source.
     */
    async updateDataSourceByUIDRaw(requestParameters: DatasourcesApiUpdateDataSourceByUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddDataSource200Response>> {
        if (requestParameters['uid'] == null) {
            throw new runtime.RequiredError(
                'uid',
                'Required parameter "uid" was null or undefined when calling updateDataSourceByUID().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling updateDataSourceByUID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/datasources/uid/{uid}`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters['uid']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateDataSourceCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddDataSource200ResponseFromJSON(jsonValue));
    }

    /**
     * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the encrypted fields are listed under secureJsonFields section in the response.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:1` (single data source).
     * Update an existing data source.
     */
    async updateDataSourceByUID(requestParameters: DatasourcesApiUpdateDataSourceByUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddDataSource200Response> {
        const response = await this.updateDataSourceByUIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
