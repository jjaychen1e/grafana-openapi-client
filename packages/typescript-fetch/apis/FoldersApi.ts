/* tslint:disable */
/* eslint-disable */
/**
 * Grafana HTTP API.
 * The Grafana backend exposes an HTTP API, the same API is used by the frontend to do everything from saving dashboards, creating users and updating data sources.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: hello@grafana.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime.js';
import type {
  CreateFolderCommand,
  DeleteFolder200Response,
  ErrorResponseBody,
  Folder,
  FolderSearchHit,
  MoveFolderCommand,
  UpdateFolderCommand,
} from '../models/index.js';
import {
    CreateFolderCommandFromJSON,
    CreateFolderCommandToJSON,
    DeleteFolder200ResponseFromJSON,
    DeleteFolder200ResponseToJSON,
    ErrorResponseBodyFromJSON,
    ErrorResponseBodyToJSON,
    FolderFromJSON,
    FolderToJSON,
    FolderSearchHitFromJSON,
    FolderSearchHitToJSON,
    MoveFolderCommandFromJSON,
    MoveFolderCommandToJSON,
    UpdateFolderCommandFromJSON,
    UpdateFolderCommandToJSON,
} from '../models/index.js';

export interface FoldersApiCreateFolderRequest {
    body: CreateFolderCommand;
}

export interface FoldersApiDeleteFolderRequest {
    folderUid: string;
    forceDeleteRules?: boolean;
}

export interface FoldersApiGetFolderByIDRequest {
    folderId: number;
}

export interface FoldersApiGetFolderByUIDRequest {
    folderUid: string;
}

export interface FoldersApiGetFolderDescendantCountsRequest {
    folderUid: string;
}

export interface FoldersApiGetFoldersRequest {
    limit?: number;
    page?: number;
    parentUid?: string;
    permission?: GetFoldersPermissionEnum;
}

export interface FoldersApiMoveFolderRequest {
    folderUid: string;
    body: MoveFolderCommand;
}

export interface FoldersApiUpdateFolderRequest {
    folderUid: string;
    body: UpdateFolderCommand;
}

/**
 * 
 */
export class FoldersApi extends runtime.BaseAPI {

    /**
     * If nested folders are enabled then it additionally expects the parent folder UID.
     * Create folder.
     */
    async createFolderRaw(requestParameters: FoldersApiCreateFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createFolder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/folders`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateFolderCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * If nested folders are enabled then it additionally expects the parent folder UID.
     * Create folder.
     */
    async createFolder(requestParameters: FoldersApiCreateFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Folder> {
        const response = await this.createFolderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes an existing folder identified by UID along with all dashboards (and their alerts) stored in the folder. This operation cannot be reverted. If nested folders are enabled then it also deletes all the subfolders.
     * Delete folder.
     */
    async deleteFolderRaw(requestParameters: FoldersApiDeleteFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteFolder200Response>> {
        if (requestParameters['folderUid'] == null) {
            throw new runtime.RequiredError(
                'folderUid',
                'Required parameter "folderUid" was null or undefined when calling deleteFolder().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['forceDeleteRules'] != null) {
            queryParameters['forceDeleteRules'] = requestParameters['forceDeleteRules'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/folders/{folder_uid}`.replace(`{${"folder_uid"}}`, encodeURIComponent(String(requestParameters['folderUid']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteFolder200ResponseFromJSON(jsonValue));
    }

    /**
     * Deletes an existing folder identified by UID along with all dashboards (and their alerts) stored in the folder. This operation cannot be reverted. If nested folders are enabled then it also deletes all the subfolders.
     * Delete folder.
     */
    async deleteFolder(requestParameters: FoldersApiDeleteFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteFolder200Response> {
        const response = await this.deleteFolderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the folder identified by id. This is deprecated. Please refer to [updated API](#/folders/getFolderByUID) instead
     * Get folder by id.
     * @deprecated
     */
    async getFolderByIDRaw(requestParameters: FoldersApiGetFolderByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters['folderId'] == null) {
            throw new runtime.RequiredError(
                'folderId',
                'Required parameter "folderId" was null or undefined when calling getFolderByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/folders/id/{folder_id}`.replace(`{${"folder_id"}}`, encodeURIComponent(String(requestParameters['folderId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Returns the folder identified by id. This is deprecated. Please refer to [updated API](#/folders/getFolderByUID) instead
     * Get folder by id.
     * @deprecated
     */
    async getFolderByID(requestParameters: FoldersApiGetFolderByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Folder> {
        const response = await this.getFolderByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get folder by uid.
     */
    async getFolderByUIDRaw(requestParameters: FoldersApiGetFolderByUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters['folderUid'] == null) {
            throw new runtime.RequiredError(
                'folderUid',
                'Required parameter "folderUid" was null or undefined when calling getFolderByUID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/folders/{folder_uid}`.replace(`{${"folder_uid"}}`, encodeURIComponent(String(requestParameters['folderUid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Get folder by uid.
     */
    async getFolderByUID(requestParameters: FoldersApiGetFolderByUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Folder> {
        const response = await this.getFolderByUIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the count of each descendant of a folder by kind. The folder is identified by UID.
     */
    async getFolderDescendantCountsRaw(requestParameters: FoldersApiGetFolderDescendantCountsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: number; }>> {
        if (requestParameters['folderUid'] == null) {
            throw new runtime.RequiredError(
                'folderUid',
                'Required parameter "folderUid" was null or undefined when calling getFolderDescendantCounts().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/folders/{folder_uid}/counts`.replace(`{${"folder_uid"}}`, encodeURIComponent(String(requestParameters['folderUid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Gets the count of each descendant of a folder by kind. The folder is identified by UID.
     */
    async getFolderDescendantCounts(requestParameters: FoldersApiGetFolderDescendantCountsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: number; }> {
        const response = await this.getFolderDescendantCountsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * It returns all folders that the authenticated user has permission to view. If nested folders are enabled, it expects an additional query parameter with the parent folder UID and returns the immediate subfolders that the authenticated user has permission to view. If the parameter is not supplied then it returns immediate subfolders under the root that the authenticated user has permission to view.
     * Get all folders.
     */
    async getFoldersRaw(requestParameters: FoldersApiGetFoldersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<FolderSearchHit>>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['parentUid'] != null) {
            queryParameters['parentUid'] = requestParameters['parentUid'];
        }

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/folders`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FolderSearchHitFromJSON));
    }

    /**
     * It returns all folders that the authenticated user has permission to view. If nested folders are enabled, it expects an additional query parameter with the parent folder UID and returns the immediate subfolders that the authenticated user has permission to view. If the parameter is not supplied then it returns immediate subfolders under the root that the authenticated user has permission to view.
     * Get all folders.
     */
    async getFolders(requestParameters: FoldersApiGetFoldersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<FolderSearchHit>> {
        const response = await this.getFoldersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Move folder.
     */
    async moveFolderRaw(requestParameters: FoldersApiMoveFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters['folderUid'] == null) {
            throw new runtime.RequiredError(
                'folderUid',
                'Required parameter "folderUid" was null or undefined when calling moveFolder().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling moveFolder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/folders/{folder_uid}/move`.replace(`{${"folder_uid"}}`, encodeURIComponent(String(requestParameters['folderUid']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MoveFolderCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Move folder.
     */
    async moveFolder(requestParameters: FoldersApiMoveFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Folder> {
        const response = await this.moveFolderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update folder.
     */
    async updateFolderRaw(requestParameters: FoldersApiUpdateFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Folder>> {
        if (requestParameters['folderUid'] == null) {
            throw new runtime.RequiredError(
                'folderUid',
                'Required parameter "folderUid" was null or undefined when calling updateFolder().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling updateFolder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/folders/{folder_uid}`.replace(`{${"folder_uid"}}`, encodeURIComponent(String(requestParameters['folderUid']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateFolderCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
    }

    /**
     * Update folder.
     */
    async updateFolder(requestParameters: FoldersApiUpdateFolderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Folder> {
        const response = await this.updateFolderRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetFoldersPermissionEnum = {
    Edit: 'Edit',
    View: 'View'
} as const;
export type GetFoldersPermissionEnum = typeof GetFoldersPermissionEnum[keyof typeof GetFoldersPermissionEnum];
