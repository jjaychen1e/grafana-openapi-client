/* tslint:disable */
/* eslint-disable */
/**
 * Grafana HTTP API.
 * The Grafana backend exposes an HTTP API, the same API is used by the frontend to do everything from saving dashboards, creating users and updating data sources.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: hello@grafana.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime.js';
import type {
  Annotation,
  ErrorResponseBody,
  GetAnnotationTagsResponse,
  MassDeleteAnnotationsCmd,
  PatchAnnotationsCmd,
  PostAnnotation200Response,
  PostAnnotationsCmd,
  PostGraphiteAnnotationsCmd,
  SuccessResponseBody,
  UpdateAnnotationsCmd,
} from '../models/index.js';
import {
    AnnotationFromJSON,
    AnnotationToJSON,
    ErrorResponseBodyFromJSON,
    ErrorResponseBodyToJSON,
    GetAnnotationTagsResponseFromJSON,
    GetAnnotationTagsResponseToJSON,
    MassDeleteAnnotationsCmdFromJSON,
    MassDeleteAnnotationsCmdToJSON,
    PatchAnnotationsCmdFromJSON,
    PatchAnnotationsCmdToJSON,
    PostAnnotation200ResponseFromJSON,
    PostAnnotation200ResponseToJSON,
    PostAnnotationsCmdFromJSON,
    PostAnnotationsCmdToJSON,
    PostGraphiteAnnotationsCmdFromJSON,
    PostGraphiteAnnotationsCmdToJSON,
    SuccessResponseBodyFromJSON,
    SuccessResponseBodyToJSON,
    UpdateAnnotationsCmdFromJSON,
    UpdateAnnotationsCmdToJSON,
} from '../models/index.js';

export interface AnnotationsApiDeleteAnnotationByIDRequest {
    annotationId: string;
}

export interface AnnotationsApiGetAnnotationByIDRequest {
    annotationId: string;
}

export interface AnnotationsApiGetAnnotationTagsRequest {
    tag?: string;
    limit?: string;
}

export interface AnnotationsApiGetAnnotationsRequest {
    from?: number;
    to?: number;
    userId?: number;
    alertId?: number;
    dashboardId?: number;
    dashboardUID?: string;
    panelId?: number;
    limit?: number;
    tags?: Array<string>;
    type?: GetAnnotationsTypeEnum;
    matchAny?: boolean;
}

export interface AnnotationsApiMassDeleteAnnotationsRequest {
    body: MassDeleteAnnotationsCmd;
}

export interface AnnotationsApiPatchAnnotationRequest {
    annotationId: string;
    body: PatchAnnotationsCmd;
}

export interface AnnotationsApiPostAnnotationRequest {
    body: PostAnnotationsCmd;
}

export interface AnnotationsApiPostGraphiteAnnotationRequest {
    body: PostGraphiteAnnotationsCmd;
}

export interface AnnotationsApiUpdateAnnotationRequest {
    annotationId: string;
    body: UpdateAnnotationsCmd;
}

/**
 * 
 */
export class AnnotationsApi extends runtime.BaseAPI {

    /**
     * Deletes the annotation that matches the specified ID.
     * Delete Annotation By ID.
     */
    async deleteAnnotationByIDRaw(requestParameters: AnnotationsApiDeleteAnnotationByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['annotationId'] == null) {
            throw new runtime.RequiredError(
                'annotationId',
                'Required parameter "annotationId" was null or undefined when calling deleteAnnotationByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/annotations/{annotation_id}`.replace(`{${"annotation_id"}}`, encodeURIComponent(String(requestParameters['annotationId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Deletes the annotation that matches the specified ID.
     * Delete Annotation By ID.
     */
    async deleteAnnotationByID(requestParameters: AnnotationsApiDeleteAnnotationByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.deleteAnnotationByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Annotation by ID.
     */
    async getAnnotationByIDRaw(requestParameters: AnnotationsApiGetAnnotationByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Annotation>> {
        if (requestParameters['annotationId'] == null) {
            throw new runtime.RequiredError(
                'annotationId',
                'Required parameter "annotationId" was null or undefined when calling getAnnotationByID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/annotations/{annotation_id}`.replace(`{${"annotation_id"}}`, encodeURIComponent(String(requestParameters['annotationId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnnotationFromJSON(jsonValue));
    }

    /**
     * Get Annotation by ID.
     */
    async getAnnotationByID(requestParameters: AnnotationsApiGetAnnotationByIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Annotation> {
        const response = await this.getAnnotationByIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find all the event tags created in the annotations.
     * Find Annotations Tags.
     */
    async getAnnotationTagsRaw(requestParameters: AnnotationsApiGetAnnotationTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAnnotationTagsResponse>> {
        const queryParameters: any = {};

        if (requestParameters['tag'] != null) {
            queryParameters['tag'] = requestParameters['tag'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/annotations/tags`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetAnnotationTagsResponseFromJSON(jsonValue));
    }

    /**
     * Find all the event tags created in the annotations.
     * Find Annotations Tags.
     */
    async getAnnotationTags(requestParameters: AnnotationsApiGetAnnotationTagsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAnnotationTagsResponse> {
        const response = await this.getAnnotationTagsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Starting in Grafana v6.4 regions annotations are now returned in one entity that now includes the timeEnd property.
     * Find Annotations.
     */
    async getAnnotationsRaw(requestParameters: AnnotationsApiGetAnnotationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Annotation>>> {
        const queryParameters: any = {};

        if (requestParameters['from'] != null) {
            queryParameters['from'] = requestParameters['from'];
        }

        if (requestParameters['to'] != null) {
            queryParameters['to'] = requestParameters['to'];
        }

        if (requestParameters['userId'] != null) {
            queryParameters['userId'] = requestParameters['userId'];
        }

        if (requestParameters['alertId'] != null) {
            queryParameters['alertId'] = requestParameters['alertId'];
        }

        if (requestParameters['dashboardId'] != null) {
            queryParameters['dashboardId'] = requestParameters['dashboardId'];
        }

        if (requestParameters['dashboardUID'] != null) {
            queryParameters['dashboardUID'] = requestParameters['dashboardUID'];
        }

        if (requestParameters['panelId'] != null) {
            queryParameters['panelId'] = requestParameters['panelId'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['tags'] != null) {
            queryParameters['tags'] = requestParameters['tags'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['matchAny'] != null) {
            queryParameters['matchAny'] = requestParameters['matchAny'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/annotations`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AnnotationFromJSON));
    }

    /**
     * Starting in Grafana v6.4 regions annotations are now returned in one entity that now includes the timeEnd property.
     * Find Annotations.
     */
    async getAnnotations(requestParameters: AnnotationsApiGetAnnotationsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Annotation>> {
        const response = await this.getAnnotationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete multiple annotations.
     */
    async massDeleteAnnotationsRaw(requestParameters: AnnotationsApiMassDeleteAnnotationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling massDeleteAnnotations().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/annotations/mass-delete`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MassDeleteAnnotationsCmdToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Delete multiple annotations.
     */
    async massDeleteAnnotations(requestParameters: AnnotationsApiMassDeleteAnnotationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.massDeleteAnnotationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates one or more properties of an annotation that matches the specified ID. This operation currently supports updating of the `text`, `tags`, `time` and `timeEnd` properties. This is available in Grafana 6.0.0-beta2 and above.
     * Patch Annotation.
     */
    async patchAnnotationRaw(requestParameters: AnnotationsApiPatchAnnotationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['annotationId'] == null) {
            throw new runtime.RequiredError(
                'annotationId',
                'Required parameter "annotationId" was null or undefined when calling patchAnnotation().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchAnnotation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/annotations/{annotation_id}`.replace(`{${"annotation_id"}}`, encodeURIComponent(String(requestParameters['annotationId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchAnnotationsCmdToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Updates one or more properties of an annotation that matches the specified ID. This operation currently supports updating of the `text`, `tags`, `time` and `timeEnd` properties. This is available in Grafana 6.0.0-beta2 and above.
     * Patch Annotation.
     */
    async patchAnnotation(requestParameters: AnnotationsApiPatchAnnotationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.patchAnnotationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates an annotation in the Grafana database. The dashboardId and panelId fields are optional. If they are not specified then an organization annotation is created and can be queried in any dashboard that adds the Grafana annotations data source. When creating a region annotation include the timeEnd property. The format for `time` and `timeEnd` should be epoch numbers in millisecond resolution. The response for this HTTP request is slightly different in versions prior to v6.4. In prior versions you would also get an endId if you where creating a region. But in 6.4 regions are represented using a single event with time and timeEnd properties.
     * Create Annotation.
     */
    async postAnnotationRaw(requestParameters: AnnotationsApiPostAnnotationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PostAnnotation200Response>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling postAnnotation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/annotations`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostAnnotationsCmdToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PostAnnotation200ResponseFromJSON(jsonValue));
    }

    /**
     * Creates an annotation in the Grafana database. The dashboardId and panelId fields are optional. If they are not specified then an organization annotation is created and can be queried in any dashboard that adds the Grafana annotations data source. When creating a region annotation include the timeEnd property. The format for `time` and `timeEnd` should be epoch numbers in millisecond resolution. The response for this HTTP request is slightly different in versions prior to v6.4. In prior versions you would also get an endId if you where creating a region. But in 6.4 regions are represented using a single event with time and timeEnd properties.
     * Create Annotation.
     */
    async postAnnotation(requestParameters: AnnotationsApiPostAnnotationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PostAnnotation200Response> {
        const response = await this.postAnnotationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates an annotation by using Graphite-compatible event format. The `when` and `data` fields are optional. If `when` is not specified then the current time will be used as annotation’s timestamp. The `tags` field can also be in prior to Graphite `0.10.0` format (string with multiple tags being separated by a space).
     * Create Annotation in Graphite format.
     */
    async postGraphiteAnnotationRaw(requestParameters: AnnotationsApiPostGraphiteAnnotationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PostAnnotation200Response>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling postGraphiteAnnotation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/annotations/graphite`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostGraphiteAnnotationsCmdToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PostAnnotation200ResponseFromJSON(jsonValue));
    }

    /**
     * Creates an annotation by using Graphite-compatible event format. The `when` and `data` fields are optional. If `when` is not specified then the current time will be used as annotation’s timestamp. The `tags` field can also be in prior to Graphite `0.10.0` format (string with multiple tags being separated by a space).
     * Create Annotation in Graphite format.
     */
    async postGraphiteAnnotation(requestParameters: AnnotationsApiPostGraphiteAnnotationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PostAnnotation200Response> {
        const response = await this.postGraphiteAnnotationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates all properties of an annotation that matches the specified id. To only update certain property, consider using the Patch Annotation operation.
     * Update Annotation.
     */
    async updateAnnotationRaw(requestParameters: AnnotationsApiUpdateAnnotationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['annotationId'] == null) {
            throw new runtime.RequiredError(
                'annotationId',
                'Required parameter "annotationId" was null or undefined when calling updateAnnotation().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling updateAnnotation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/annotations/{annotation_id}`.replace(`{${"annotation_id"}}`, encodeURIComponent(String(requestParameters['annotationId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateAnnotationsCmdToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Updates all properties of an annotation that matches the specified id. To only update certain property, consider using the Patch Annotation operation.
     * Update Annotation.
     */
    async updateAnnotation(requestParameters: AnnotationsApiUpdateAnnotationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.updateAnnotationRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetAnnotationsTypeEnum = {
    Alert: 'alert',
    Annotation: 'annotation'
} as const;
export type GetAnnotationsTypeEnum = typeof GetAnnotationsTypeEnum[keyof typeof GetAnnotationsTypeEnum];
