/* tslint:disable */
/* eslint-disable */
/**
 * Grafana HTTP API.
 * The Grafana backend exposes an HTTP API, the same API is used by the frontend to do everything from saving dashboards, creating users and updating data sources.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: hello@grafana.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime.js';
import type {
  CreateLibraryElementCommand,
  ErrorResponseBody,
  LibraryElementArrayResponse,
  LibraryElementConnectionsResponse,
  LibraryElementResponse,
  LibraryElementSearchResponse,
  PatchLibraryElementCommand,
  SuccessResponseBody,
} from '../models/index.js';
import {
    CreateLibraryElementCommandFromJSON,
    CreateLibraryElementCommandToJSON,
    ErrorResponseBodyFromJSON,
    ErrorResponseBodyToJSON,
    LibraryElementArrayResponseFromJSON,
    LibraryElementArrayResponseToJSON,
    LibraryElementConnectionsResponseFromJSON,
    LibraryElementConnectionsResponseToJSON,
    LibraryElementResponseFromJSON,
    LibraryElementResponseToJSON,
    LibraryElementSearchResponseFromJSON,
    LibraryElementSearchResponseToJSON,
    PatchLibraryElementCommandFromJSON,
    PatchLibraryElementCommandToJSON,
    SuccessResponseBodyFromJSON,
    SuccessResponseBodyToJSON,
} from '../models/index.js';

export interface LibraryElementsApiCreateLibraryElementRequest {
    body: CreateLibraryElementCommand;
}

export interface LibraryElementsApiDeleteLibraryElementByUIDRequest {
    libraryElementUid: string;
}

export interface LibraryElementsApiGetLibraryElementByNameRequest {
    libraryElementName: string;
}

export interface LibraryElementsApiGetLibraryElementByUIDRequest {
    libraryElementUid: string;
}

export interface LibraryElementsApiGetLibraryElementConnectionsRequest {
    libraryElementUid: string;
}

export interface LibraryElementsApiGetLibraryElementsRequest {
    searchString?: string;
    kind?: GetLibraryElementsKindEnum;
    sortDirection?: GetLibraryElementsSortDirectionEnum;
    typeFilter?: string;
    excludeUid?: string;
    folderFilter?: string;
    perPage?: number;
    page?: number;
}

export interface LibraryElementsApiUpdateLibraryElementRequest {
    libraryElementUid: string;
    body: PatchLibraryElementCommand;
}

/**
 * 
 */
export class LibraryElementsApi extends runtime.BaseAPI {

    /**
     * Creates a new library element.
     * Create library element.
     */
    async createLibraryElementRaw(requestParameters: LibraryElementsApiCreateLibraryElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LibraryElementResponse>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createLibraryElement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/library-elements`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateLibraryElementCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LibraryElementResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new library element.
     * Create library element.
     */
    async createLibraryElement(requestParameters: LibraryElementsApiCreateLibraryElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LibraryElementResponse> {
        const response = await this.createLibraryElementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes an existing library element as specified by the UID. This operation cannot be reverted. You cannot delete a library element that is connected. This operation cannot be reverted.
     * Delete library element.
     */
    async deleteLibraryElementByUIDRaw(requestParameters: LibraryElementsApiDeleteLibraryElementByUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessResponseBody>> {
        if (requestParameters['libraryElementUid'] == null) {
            throw new runtime.RequiredError(
                'libraryElementUid',
                'Required parameter "libraryElementUid" was null or undefined when calling deleteLibraryElementByUID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/library-elements/{library_element_uid}`.replace(`{${"library_element_uid"}}`, encodeURIComponent(String(requestParameters['libraryElementUid']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
    }

    /**
     * Deletes an existing library element as specified by the UID. This operation cannot be reverted. You cannot delete a library element that is connected. This operation cannot be reverted.
     * Delete library element.
     */
    async deleteLibraryElementByUID(requestParameters: LibraryElementsApiDeleteLibraryElementByUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessResponseBody> {
        const response = await this.deleteLibraryElementByUIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a library element with the given name.
     * Get library element by name.
     */
    async getLibraryElementByNameRaw(requestParameters: LibraryElementsApiGetLibraryElementByNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LibraryElementArrayResponse>> {
        if (requestParameters['libraryElementName'] == null) {
            throw new runtime.RequiredError(
                'libraryElementName',
                'Required parameter "libraryElementName" was null or undefined when calling getLibraryElementByName().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/library-elements/name/{library_element_name}`.replace(`{${"library_element_name"}}`, encodeURIComponent(String(requestParameters['libraryElementName']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LibraryElementArrayResponseFromJSON(jsonValue));
    }

    /**
     * Returns a library element with the given name.
     * Get library element by name.
     */
    async getLibraryElementByName(requestParameters: LibraryElementsApiGetLibraryElementByNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LibraryElementArrayResponse> {
        const response = await this.getLibraryElementByNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a library element with the given UID.
     * Get library element by UID.
     */
    async getLibraryElementByUIDRaw(requestParameters: LibraryElementsApiGetLibraryElementByUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LibraryElementResponse>> {
        if (requestParameters['libraryElementUid'] == null) {
            throw new runtime.RequiredError(
                'libraryElementUid',
                'Required parameter "libraryElementUid" was null or undefined when calling getLibraryElementByUID().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/library-elements/{library_element_uid}`.replace(`{${"library_element_uid"}}`, encodeURIComponent(String(requestParameters['libraryElementUid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LibraryElementResponseFromJSON(jsonValue));
    }

    /**
     * Returns a library element with the given UID.
     * Get library element by UID.
     */
    async getLibraryElementByUID(requestParameters: LibraryElementsApiGetLibraryElementByUIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LibraryElementResponse> {
        const response = await this.getLibraryElementByUIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of connections for a library element based on the UID specified.
     * Get library element connections.
     */
    async getLibraryElementConnectionsRaw(requestParameters: LibraryElementsApiGetLibraryElementConnectionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LibraryElementConnectionsResponse>> {
        if (requestParameters['libraryElementUid'] == null) {
            throw new runtime.RequiredError(
                'libraryElementUid',
                'Required parameter "libraryElementUid" was null or undefined when calling getLibraryElementConnections().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/library-elements/{library_element_uid}/connections/`.replace(`{${"library_element_uid"}}`, encodeURIComponent(String(requestParameters['libraryElementUid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LibraryElementConnectionsResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of connections for a library element based on the UID specified.
     * Get library element connections.
     */
    async getLibraryElementConnections(requestParameters: LibraryElementsApiGetLibraryElementConnectionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LibraryElementConnectionsResponse> {
        const response = await this.getLibraryElementConnectionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of all library elements the authenticated user has permission to view. Use the `perPage` query parameter to control the maximum number of library elements returned; the default limit is `100`. You can also use the `page` query parameter to fetch library elements from any page other than the first one.
     * Get all library elements.
     */
    async getLibraryElementsRaw(requestParameters: LibraryElementsApiGetLibraryElementsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LibraryElementSearchResponse>> {
        const queryParameters: any = {};

        if (requestParameters['searchString'] != null) {
            queryParameters['searchString'] = requestParameters['searchString'];
        }

        if (requestParameters['kind'] != null) {
            queryParameters['kind'] = requestParameters['kind'];
        }

        if (requestParameters['sortDirection'] != null) {
            queryParameters['sortDirection'] = requestParameters['sortDirection'];
        }

        if (requestParameters['typeFilter'] != null) {
            queryParameters['typeFilter'] = requestParameters['typeFilter'];
        }

        if (requestParameters['excludeUid'] != null) {
            queryParameters['excludeUid'] = requestParameters['excludeUid'];
        }

        if (requestParameters['folderFilter'] != null) {
            queryParameters['folderFilter'] = requestParameters['folderFilter'];
        }

        if (requestParameters['perPage'] != null) {
            queryParameters['perPage'] = requestParameters['perPage'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/library-elements`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LibraryElementSearchResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of all library elements the authenticated user has permission to view. Use the `perPage` query parameter to control the maximum number of library elements returned; the default limit is `100`. You can also use the `page` query parameter to fetch library elements from any page other than the first one.
     * Get all library elements.
     */
    async getLibraryElements(requestParameters: LibraryElementsApiGetLibraryElementsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LibraryElementSearchResponse> {
        const response = await this.getLibraryElementsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates an existing library element identified by uid.
     * Update library element.
     */
    async updateLibraryElementRaw(requestParameters: LibraryElementsApiUpdateLibraryElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LibraryElementResponse>> {
        if (requestParameters['libraryElementUid'] == null) {
            throw new runtime.RequiredError(
                'libraryElementUid',
                'Required parameter "libraryElementUid" was null or undefined when calling updateLibraryElement().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling updateLibraryElement().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/library-elements/{library_element_uid}`.replace(`{${"library_element_uid"}}`, encodeURIComponent(String(requestParameters['libraryElementUid']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchLibraryElementCommandToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LibraryElementResponseFromJSON(jsonValue));
    }

    /**
     * Updates an existing library element identified by uid.
     * Update library element.
     */
    async updateLibraryElement(requestParameters: LibraryElementsApiUpdateLibraryElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LibraryElementResponse> {
        const response = await this.updateLibraryElementRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetLibraryElementsKindEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;
export type GetLibraryElementsKindEnum = typeof GetLibraryElementsKindEnum[keyof typeof GetLibraryElementsKindEnum];
/**
 * @export
 */
export const GetLibraryElementsSortDirectionEnum = {
    Asc: 'alpha-asc',
    Desc: 'alpha-desc'
} as const;
export type GetLibraryElementsSortDirectionEnum = typeof GetLibraryElementsSortDirectionEnum[keyof typeof GetLibraryElementsSortDirectionEnum];
