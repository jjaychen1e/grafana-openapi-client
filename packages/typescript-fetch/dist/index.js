'use strict';

// runtime.ts
var BASE_PATH = "/api".replace(/\/+$/, "");
var Configuration = class {
  constructor(configuration = {}) {
    this.configuration = configuration;
  }
  set config(configuration) {
    this.configuration = configuration;
  }
  get basePath() {
    return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
  }
  get fetchApi() {
    return this.configuration.fetchApi;
  }
  get middleware() {
    return this.configuration.middleware || [];
  }
  get queryParamsStringify() {
    return this.configuration.queryParamsStringify || querystring;
  }
  get username() {
    return this.configuration.username;
  }
  get password() {
    return this.configuration.password;
  }
  get apiKey() {
    const apiKey = this.configuration.apiKey;
    if (apiKey) {
      return typeof apiKey === "function" ? apiKey : () => apiKey;
    }
    return void 0;
  }
  get accessToken() {
    const accessToken = this.configuration.accessToken;
    if (accessToken) {
      return typeof accessToken === "function" ? accessToken : async () => accessToken;
    }
    return void 0;
  }
  get headers() {
    return this.configuration.headers;
  }
  get credentials() {
    return this.configuration.credentials;
  }
};
var DefaultConfig = new Configuration();
var _BaseAPI = class _BaseAPI {
  constructor(configuration = DefaultConfig) {
    this.configuration = configuration;
    this.fetchApi = async (url, init) => {
      let fetchParams = { url, init };
      for (const middleware of this.middleware) {
        if (middleware.pre) {
          fetchParams = await middleware.pre({
            fetch: this.fetchApi,
            ...fetchParams
          }) || fetchParams;
        }
      }
      let response = void 0;
      try {
        response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
      } catch (e) {
        for (const middleware of this.middleware) {
          if (middleware.onError) {
            response = await middleware.onError({
              fetch: this.fetchApi,
              url: fetchParams.url,
              init: fetchParams.init,
              error: e,
              response: response ? response.clone() : void 0
            }) || response;
          }
        }
        if (response === void 0) {
          if (e instanceof Error) {
            throw new FetchError(e, "The request failed and the interceptors did not return an alternative response");
          } else {
            throw e;
          }
        }
      }
      for (const middleware of this.middleware) {
        if (middleware.post) {
          response = await middleware.post({
            fetch: this.fetchApi,
            url: fetchParams.url,
            init: fetchParams.init,
            response: response.clone()
          }) || response;
        }
      }
      return response;
    };
    this.middleware = configuration.middleware;
  }
  withMiddleware(...middlewares) {
    const next = this.clone();
    next.middleware = next.middleware.concat(...middlewares);
    return next;
  }
  withPreMiddleware(...preMiddlewares) {
    const middlewares = preMiddlewares.map((pre) => ({ pre }));
    return this.withMiddleware(...middlewares);
  }
  withPostMiddleware(...postMiddlewares) {
    const middlewares = postMiddlewares.map((post) => ({ post }));
    return this.withMiddleware(...middlewares);
  }
  /**
   * Check if the given MIME is a JSON MIME.
   * JSON MIME examples:
   *   application/json
   *   application/json; charset=UTF8
   *   APPLICATION/JSON
   *   application/vnd.company+json
   * @param mime - MIME (Multipurpose Internet Mail Extensions)
   * @return True if the given MIME is JSON, false otherwise.
   */
  isJsonMime(mime) {
    if (!mime) {
      return false;
    }
    return _BaseAPI.jsonRegex.test(mime);
  }
  async request(context, initOverrides) {
    const { url, init } = await this.createFetchParams(context, initOverrides);
    const response = await this.fetchApi(url, init);
    if (response && (response.status >= 200 && response.status < 300)) {
      return response;
    }
    throw new ResponseError(response, "Response returned an error code");
  }
  async createFetchParams(context, initOverrides) {
    let url = this.configuration.basePath + context.path;
    if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
      url += "?" + this.configuration.queryParamsStringify(context.query);
    }
    const headers = Object.assign({}, this.configuration.headers, context.headers);
    Object.keys(headers).forEach((key) => headers[key] === void 0 ? delete headers[key] : {});
    const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async () => initOverrides;
    const initParams = {
      method: context.method,
      headers,
      body: context.body,
      credentials: this.configuration.credentials
    };
    const overriddenInit = {
      ...initParams,
      ...await initOverrideFn({
        init: initParams,
        context
      })
    };
    let body;
    if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
      body = overriddenInit.body;
    } else if (this.isJsonMime(headers["Content-Type"])) {
      body = JSON.stringify(overriddenInit.body);
    } else {
      body = overriddenInit.body;
    }
    const init = {
      ...overriddenInit,
      body
    };
    return { url, init };
  }
  /**
   * Create a shallow clone of `this` by constructing a new instance
   * and then shallow cloning data members.
   */
  clone() {
    const constructor = this.constructor;
    const next = new constructor(this.configuration);
    next.middleware = this.middleware.slice();
    return next;
  }
};
_BaseAPI.jsonRegex = new RegExp("^(:?application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(:?;.*)?$", "i");
var BaseAPI = _BaseAPI;
function isBlob(value) {
  return typeof Blob !== "undefined" && value instanceof Blob;
}
function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}
var ResponseError = class extends Error {
  constructor(response, msg) {
    super(msg);
    this.response = response;
    this.name = "ResponseError";
  }
};
var FetchError = class extends Error {
  constructor(cause, msg) {
    super(msg);
    this.cause = cause;
    this.name = "FetchError";
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};
var COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "	",
  pipes: "|"
};
function querystring(params, prefix = "") {
  return Object.keys(params).map((key) => querystringSingleKey(key, params[key], prefix)).filter((part) => part.length > 0).join("&");
}
function querystringSingleKey(key, value, keyPrefix = "") {
  const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
  if (value instanceof Array) {
    const multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
    return `${encodeURIComponent(fullKey)}=${multiValue}`;
  }
  if (value instanceof Set) {
    const valueAsArray = Array.from(value);
    return querystringSingleKey(key, valueAsArray, keyPrefix);
  }
  if (value instanceof Date) {
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
  }
  if (value instanceof Object) {
    return querystring(value, fullKey);
  }
  return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function exists(json, key) {
  const value = json[key];
  return value !== null && value !== void 0;
}
function mapValues(data, fn) {
  return Object.keys(data).reduce(
    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),
    {}
  );
}
function canConsumeForm(consumes) {
  for (const consume of consumes) {
    if ("multipart/form-data" === consume.contentType) {
      return true;
    }
  }
  return false;
}
var JSONApiResponse = class {
  constructor(raw, transformer = (jsonValue) => jsonValue) {
    this.raw = raw;
    this.transformer = transformer;
  }
  async value() {
    return this.transformer(await this.raw.json());
  }
};
var VoidApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  async value() {
    return void 0;
  }
};
var BlobApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  async value() {
    return await this.raw.blob();
  }
};
var TextApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  async value() {
    return await this.raw.text();
  }
};

// models/FailedUser.ts
function instanceOfFailedUser(value) {
  return true;
}
function FailedUserFromJSON(json) {
  return FailedUserFromJSONTyped(json);
}
function FailedUserFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "error": json["Error"] == null ? void 0 : json["Error"],
    "login": json["Login"] == null ? void 0 : json["Login"]
  };
}
function FailedUserToJSON(json) {
  return FailedUserToJSONTyped(json, false);
}
function FailedUserToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "Error": value["error"],
    "Login": value["login"]
  };
}

// models/SyncResult.ts
function instanceOfSyncResult(value) {
  return true;
}
function SyncResultFromJSON(json) {
  return SyncResultFromJSONTyped(json);
}
function SyncResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "elapsed": json["Elapsed"] == null ? void 0 : json["Elapsed"],
    "failedUsers": json["FailedUsers"] == null ? void 0 : json["FailedUsers"].map(FailedUserFromJSON),
    "missingUserIds": json["MissingUserIds"] == null ? void 0 : json["MissingUserIds"],
    "started": json["Started"] == null ? void 0 : new Date(json["Started"]),
    "updatedUserIds": json["UpdatedUserIds"] == null ? void 0 : json["UpdatedUserIds"]
  };
}
function SyncResultToJSON(json) {
  return SyncResultToJSONTyped(json, false);
}
function SyncResultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "Elapsed": value["elapsed"],
    "FailedUsers": value["failedUsers"] == null ? void 0 : value["failedUsers"].map(FailedUserToJSON),
    "MissingUserIds": value["missingUserIds"],
    "Started": value["started"] == null ? void 0 : value["started"].toISOString(),
    "UpdatedUserIds": value["updatedUserIds"]
  };
}

// models/ActiveSyncStatusDTO.ts
function instanceOfActiveSyncStatusDTO(value) {
  return true;
}
function ActiveSyncStatusDTOFromJSON(json) {
  return ActiveSyncStatusDTOFromJSONTyped(json);
}
function ActiveSyncStatusDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "enabled": json["enabled"] == null ? void 0 : json["enabled"],
    "nextSync": json["nextSync"] == null ? void 0 : new Date(json["nextSync"]),
    "prevSync": json["prevSync"] == null ? void 0 : SyncResultFromJSON(json["prevSync"]),
    "schedule": json["schedule"] == null ? void 0 : json["schedule"]
  };
}
function ActiveSyncStatusDTOToJSON(json) {
  return ActiveSyncStatusDTOToJSONTyped(json, false);
}
function ActiveSyncStatusDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "enabled": value["enabled"],
    "nextSync": value["nextSync"] == null ? void 0 : value["nextSync"].toISOString(),
    "prevSync": SyncResultToJSON(value["prevSync"]),
    "schedule": value["schedule"]
  };
}

// models/ActiveUserStats.ts
function instanceOfActiveUserStats(value) {
  return true;
}
function ActiveUserStatsFromJSON(json) {
  return ActiveUserStatsFromJSONTyped(json);
}
function ActiveUserStatsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "activeAdminsAndEditors": json["active_admins_and_editors"] == null ? void 0 : json["active_admins_and_editors"],
    "activeAnonymousDevices": json["active_anonymous_devices"] == null ? void 0 : json["active_anonymous_devices"],
    "activeUsers": json["active_users"] == null ? void 0 : json["active_users"],
    "activeViewers": json["active_viewers"] == null ? void 0 : json["active_viewers"]
  };
}
function ActiveUserStatsToJSON(json) {
  return ActiveUserStatsToJSONTyped(json, false);
}
function ActiveUserStatsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "active_admins_and_editors": value["activeAdminsAndEditors"],
    "active_anonymous_devices": value["activeAnonymousDevices"],
    "active_users": value["activeUsers"],
    "active_viewers": value["activeViewers"]
  };
}

// models/AddAPIKeyCommand.ts
var AddAPIKeyCommandRoleEnum = {
  None: "None",
  Viewer: "Viewer",
  Editor: "Editor",
  Admin: "Admin"
};
function instanceOfAddAPIKeyCommand(value) {
  return true;
}
function AddAPIKeyCommandFromJSON(json) {
  return AddAPIKeyCommandFromJSONTyped(json);
}
function AddAPIKeyCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "role": json["role"] == null ? void 0 : json["role"],
    "secondsToLive": json["secondsToLive"] == null ? void 0 : json["secondsToLive"]
  };
}
function AddAPIKeyCommandToJSON(json) {
  return AddAPIKeyCommandToJSONTyped(json, false);
}
function AddAPIKeyCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "role": value["role"],
    "secondsToLive": value["secondsToLive"]
  };
}

// models/DataSource.ts
function instanceOfDataSource(value) {
  return true;
}
function DataSourceFromJSON(json) {
  return DataSourceFromJSONTyped(json);
}
function DataSourceFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "access": json["access"] == null ? void 0 : json["access"],
    "accessControl": json["accessControl"] == null ? void 0 : json["accessControl"],
    "basicAuth": json["basicAuth"] == null ? void 0 : json["basicAuth"],
    "basicAuthUser": json["basicAuthUser"] == null ? void 0 : json["basicAuthUser"],
    "database": json["database"] == null ? void 0 : json["database"],
    "id": json["id"] == null ? void 0 : json["id"],
    "isDefault": json["isDefault"] == null ? void 0 : json["isDefault"],
    "jsonData": json["jsonData"] == null ? void 0 : json["jsonData"],
    "name": json["name"] == null ? void 0 : json["name"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "readOnly": json["readOnly"] == null ? void 0 : json["readOnly"],
    "secureJsonFields": json["secureJsonFields"] == null ? void 0 : json["secureJsonFields"],
    "type": json["type"] == null ? void 0 : json["type"],
    "typeLogoUrl": json["typeLogoUrl"] == null ? void 0 : json["typeLogoUrl"],
    "uid": json["uid"] == null ? void 0 : json["uid"],
    "url": json["url"] == null ? void 0 : json["url"],
    "user": json["user"] == null ? void 0 : json["user"],
    "version": json["version"] == null ? void 0 : json["version"],
    "withCredentials": json["withCredentials"] == null ? void 0 : json["withCredentials"]
  };
}
function DataSourceToJSON(json) {
  return DataSourceToJSONTyped(json, false);
}
function DataSourceToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "access": value["access"],
    "accessControl": value["accessControl"],
    "basicAuth": value["basicAuth"],
    "basicAuthUser": value["basicAuthUser"],
    "database": value["database"],
    "id": value["id"],
    "isDefault": value["isDefault"],
    "jsonData": value["jsonData"],
    "name": value["name"],
    "orgId": value["orgId"],
    "readOnly": value["readOnly"],
    "secureJsonFields": value["secureJsonFields"],
    "type": value["type"],
    "typeLogoUrl": value["typeLogoUrl"],
    "uid": value["uid"],
    "url": value["url"],
    "user": value["user"],
    "version": value["version"],
    "withCredentials": value["withCredentials"]
  };
}

// models/AddDataSource200Response.ts
function instanceOfAddDataSource200Response(value) {
  if (!("datasource" in value) || value["datasource"] === void 0) return false;
  if (!("id" in value) || value["id"] === void 0) return false;
  if (!("message" in value) || value["message"] === void 0) return false;
  if (!("name" in value) || value["name"] === void 0) return false;
  return true;
}
function AddDataSource200ResponseFromJSON(json) {
  return AddDataSource200ResponseFromJSONTyped(json);
}
function AddDataSource200ResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "datasource": DataSourceFromJSON(json["datasource"]),
    "id": json["id"],
    "message": json["message"],
    "name": json["name"]
  };
}
function AddDataSource200ResponseToJSON(json) {
  return AddDataSource200ResponseToJSONTyped(json, false);
}
function AddDataSource200ResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "datasource": DataSourceToJSON(value["datasource"]),
    "id": value["id"],
    "message": value["message"],
    "name": value["name"]
  };
}

// models/AddDataSourceCommand.ts
function instanceOfAddDataSourceCommand(value) {
  return true;
}
function AddDataSourceCommandFromJSON(json) {
  return AddDataSourceCommandFromJSONTyped(json);
}
function AddDataSourceCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "access": json["access"] == null ? void 0 : json["access"],
    "basicAuth": json["basicAuth"] == null ? void 0 : json["basicAuth"],
    "basicAuthUser": json["basicAuthUser"] == null ? void 0 : json["basicAuthUser"],
    "database": json["database"] == null ? void 0 : json["database"],
    "isDefault": json["isDefault"] == null ? void 0 : json["isDefault"],
    "jsonData": json["jsonData"] == null ? void 0 : json["jsonData"],
    "name": json["name"] == null ? void 0 : json["name"],
    "secureJsonData": json["secureJsonData"] == null ? void 0 : json["secureJsonData"],
    "type": json["type"] == null ? void 0 : json["type"],
    "uid": json["uid"] == null ? void 0 : json["uid"],
    "url": json["url"] == null ? void 0 : json["url"],
    "user": json["user"] == null ? void 0 : json["user"],
    "withCredentials": json["withCredentials"] == null ? void 0 : json["withCredentials"]
  };
}
function AddDataSourceCommandToJSON(json) {
  return AddDataSourceCommandToJSONTyped(json, false);
}
function AddDataSourceCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "access": value["access"],
    "basicAuth": value["basicAuth"],
    "basicAuthUser": value["basicAuthUser"],
    "database": value["database"],
    "isDefault": value["isDefault"],
    "jsonData": value["jsonData"],
    "name": value["name"],
    "secureJsonData": value["secureJsonData"],
    "type": value["type"],
    "uid": value["uid"],
    "url": value["url"],
    "user": value["user"],
    "withCredentials": value["withCredentials"]
  };
}

// models/AddInviteForm.ts
var AddInviteFormRoleEnum = {
  None: "None",
  Viewer: "Viewer",
  Editor: "Editor",
  Admin: "Admin"
};
function instanceOfAddInviteForm(value) {
  return true;
}
function AddInviteFormFromJSON(json) {
  return AddInviteFormFromJSONTyped(json);
}
function AddInviteFormFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "loginOrEmail": json["loginOrEmail"] == null ? void 0 : json["loginOrEmail"],
    "name": json["name"] == null ? void 0 : json["name"],
    "role": json["role"] == null ? void 0 : json["role"],
    "sendEmail": json["sendEmail"] == null ? void 0 : json["sendEmail"]
  };
}
function AddInviteFormToJSON(json) {
  return AddInviteFormToJSONTyped(json, false);
}
function AddInviteFormToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "loginOrEmail": value["loginOrEmail"],
    "name": value["name"],
    "role": value["role"],
    "sendEmail": value["sendEmail"]
  };
}

// models/AddOrgUserCommand.ts
var AddOrgUserCommandRoleEnum = {
  None: "None",
  Viewer: "Viewer",
  Editor: "Editor",
  Admin: "Admin"
};
function instanceOfAddOrgUserCommand(value) {
  return true;
}
function AddOrgUserCommandFromJSON(json) {
  return AddOrgUserCommandFromJSONTyped(json);
}
function AddOrgUserCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "loginOrEmail": json["loginOrEmail"] == null ? void 0 : json["loginOrEmail"],
    "role": json["role"] == null ? void 0 : json["role"]
  };
}
function AddOrgUserCommandToJSON(json) {
  return AddOrgUserCommandToJSONTyped(json, false);
}
function AddOrgUserCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "loginOrEmail": value["loginOrEmail"],
    "role": value["role"]
  };
}

// models/AddServiceAccountTokenCommand.ts
function instanceOfAddServiceAccountTokenCommand(value) {
  return true;
}
function AddServiceAccountTokenCommandFromJSON(json) {
  return AddServiceAccountTokenCommandFromJSONTyped(json);
}
function AddServiceAccountTokenCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "secondsToLive": json["secondsToLive"] == null ? void 0 : json["secondsToLive"]
  };
}
function AddServiceAccountTokenCommandToJSON(json) {
  return AddServiceAccountTokenCommandToJSONTyped(json, false);
}
function AddServiceAccountTokenCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "secondsToLive": value["secondsToLive"]
  };
}

// models/AddTeamMemberCommand.ts
function instanceOfAddTeamMemberCommand(value) {
  return true;
}
function AddTeamMemberCommandFromJSON(json) {
  return AddTeamMemberCommandFromJSONTyped(json);
}
function AddTeamMemberCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "userId": json["userId"] == null ? void 0 : json["userId"]
  };
}
function AddTeamMemberCommandToJSON(json) {
  return AddTeamMemberCommandToJSONTyped(json, false);
}
function AddTeamMemberCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "userId": value["userId"]
  };
}

// models/AddTeamRoleCommand.ts
function instanceOfAddTeamRoleCommand(value) {
  return true;
}
function AddTeamRoleCommandFromJSON(json) {
  return AddTeamRoleCommandFromJSONTyped(json);
}
function AddTeamRoleCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "roleUid": json["roleUid"] == null ? void 0 : json["roleUid"]
  };
}
function AddTeamRoleCommandToJSON(json) {
  return AddTeamRoleCommandToJSONTyped(json, false);
}
function AddTeamRoleCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "roleUid": value["roleUid"]
  };
}

// models/AddUserRoleCommand.ts
function instanceOfAddUserRoleCommand(value) {
  return true;
}
function AddUserRoleCommandFromJSON(json) {
  return AddUserRoleCommandFromJSONTyped(json);
}
function AddUserRoleCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "global": json["global"] == null ? void 0 : json["global"],
    "roleUid": json["roleUid"] == null ? void 0 : json["roleUid"]
  };
}
function AddUserRoleCommandToJSON(json) {
  return AddUserRoleCommandToJSONTyped(json, false);
}
function AddUserRoleCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "global": value["global"],
    "roleUid": value["roleUid"]
  };
}

// models/Address.ts
function instanceOfAddress(value) {
  return true;
}
function AddressFromJSON(json) {
  return AddressFromJSONTyped(json);
}
function AddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "address1": json["address1"] == null ? void 0 : json["address1"],
    "address2": json["address2"] == null ? void 0 : json["address2"],
    "city": json["city"] == null ? void 0 : json["city"],
    "country": json["country"] == null ? void 0 : json["country"],
    "state": json["state"] == null ? void 0 : json["state"],
    "zipCode": json["zipCode"] == null ? void 0 : json["zipCode"]
  };
}
function AddressToJSON(json) {
  return AddressToJSONTyped(json, false);
}
function AddressToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "address1": value["address1"],
    "address2": value["address2"],
    "city": value["city"],
    "country": value["country"],
    "state": value["state"],
    "zipCode": value["zipCode"]
  };
}

// models/AdminCreateUserForm.ts
function instanceOfAdminCreateUserForm(value) {
  return true;
}
function AdminCreateUserFormFromJSON(json) {
  return AdminCreateUserFormFromJSONTyped(json);
}
function AdminCreateUserFormFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "email": json["email"] == null ? void 0 : json["email"],
    "login": json["login"] == null ? void 0 : json["login"],
    "name": json["name"] == null ? void 0 : json["name"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "password": json["password"] == null ? void 0 : json["password"]
  };
}
function AdminCreateUserFormToJSON(json) {
  return AdminCreateUserFormToJSONTyped(json, false);
}
function AdminCreateUserFormToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "email": value["email"],
    "login": value["login"],
    "name": value["name"],
    "orgId": value["orgId"],
    "password": value["password"]
  };
}

// models/AdminCreateUserResponse.ts
function instanceOfAdminCreateUserResponse(value) {
  return true;
}
function AdminCreateUserResponseFromJSON(json) {
  return AdminCreateUserResponseFromJSONTyped(json);
}
function AdminCreateUserResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"] == null ? void 0 : json["id"],
    "message": json["message"] == null ? void 0 : json["message"]
  };
}
function AdminCreateUserResponseToJSON(json) {
  return AdminCreateUserResponseToJSONTyped(json, false);
}
function AdminCreateUserResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "message": value["message"]
  };
}

// models/AdminStats.ts
function instanceOfAdminStats(value) {
  return true;
}
function AdminStatsFromJSON(json) {
  return AdminStatsFromJSONTyped(json);
}
function AdminStatsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "activeAdmins": json["activeAdmins"] == null ? void 0 : json["activeAdmins"],
    "activeDevices": json["activeDevices"] == null ? void 0 : json["activeDevices"],
    "activeEditors": json["activeEditors"] == null ? void 0 : json["activeEditors"],
    "activeSessions": json["activeSessions"] == null ? void 0 : json["activeSessions"],
    "activeUsers": json["activeUsers"] == null ? void 0 : json["activeUsers"],
    "activeViewers": json["activeViewers"] == null ? void 0 : json["activeViewers"],
    "admins": json["admins"] == null ? void 0 : json["admins"],
    "alerts": json["alerts"] == null ? void 0 : json["alerts"],
    "dailyActiveAdmins": json["dailyActiveAdmins"] == null ? void 0 : json["dailyActiveAdmins"],
    "dailyActiveEditors": json["dailyActiveEditors"] == null ? void 0 : json["dailyActiveEditors"],
    "dailyActiveSessions": json["dailyActiveSessions"] == null ? void 0 : json["dailyActiveSessions"],
    "dailyActiveUsers": json["dailyActiveUsers"] == null ? void 0 : json["dailyActiveUsers"],
    "dailyActiveViewers": json["dailyActiveViewers"] == null ? void 0 : json["dailyActiveViewers"],
    "dashboards": json["dashboards"] == null ? void 0 : json["dashboards"],
    "datasources": json["datasources"] == null ? void 0 : json["datasources"],
    "editors": json["editors"] == null ? void 0 : json["editors"],
    "monthlyActiveUsers": json["monthlyActiveUsers"] == null ? void 0 : json["monthlyActiveUsers"],
    "orgs": json["orgs"] == null ? void 0 : json["orgs"],
    "playlists": json["playlists"] == null ? void 0 : json["playlists"],
    "snapshots": json["snapshots"] == null ? void 0 : json["snapshots"],
    "stars": json["stars"] == null ? void 0 : json["stars"],
    "tags": json["tags"] == null ? void 0 : json["tags"],
    "users": json["users"] == null ? void 0 : json["users"],
    "viewers": json["viewers"] == null ? void 0 : json["viewers"]
  };
}
function AdminStatsToJSON(json) {
  return AdminStatsToJSONTyped(json, false);
}
function AdminStatsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "activeAdmins": value["activeAdmins"],
    "activeDevices": value["activeDevices"],
    "activeEditors": value["activeEditors"],
    "activeSessions": value["activeSessions"],
    "activeUsers": value["activeUsers"],
    "activeViewers": value["activeViewers"],
    "admins": value["admins"],
    "alerts": value["alerts"],
    "dailyActiveAdmins": value["dailyActiveAdmins"],
    "dailyActiveEditors": value["dailyActiveEditors"],
    "dailyActiveSessions": value["dailyActiveSessions"],
    "dailyActiveUsers": value["dailyActiveUsers"],
    "dailyActiveViewers": value["dailyActiveViewers"],
    "dashboards": value["dashboards"],
    "datasources": value["datasources"],
    "editors": value["editors"],
    "monthlyActiveUsers": value["monthlyActiveUsers"],
    "orgs": value["orgs"],
    "playlists": value["playlists"],
    "snapshots": value["snapshots"],
    "stars": value["stars"],
    "tags": value["tags"],
    "users": value["users"],
    "viewers": value["viewers"]
  };
}

// models/AdminUpdateUserPasswordForm.ts
function instanceOfAdminUpdateUserPasswordForm(value) {
  return true;
}
function AdminUpdateUserPasswordFormFromJSON(json) {
  return AdminUpdateUserPasswordFormFromJSONTyped(json);
}
function AdminUpdateUserPasswordFormFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "password": json["password"] == null ? void 0 : json["password"]
  };
}
function AdminUpdateUserPasswordFormToJSON(json) {
  return AdminUpdateUserPasswordFormToJSONTyped(json, false);
}
function AdminUpdateUserPasswordFormToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "password": value["password"]
  };
}

// models/AdminUpdateUserPermissionsForm.ts
function instanceOfAdminUpdateUserPermissionsForm(value) {
  return true;
}
function AdminUpdateUserPermissionsFormFromJSON(json) {
  return AdminUpdateUserPermissionsFormFromJSONTyped(json);
}
function AdminUpdateUserPermissionsFormFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "isGrafanaAdmin": json["isGrafanaAdmin"] == null ? void 0 : json["isGrafanaAdmin"]
  };
}
function AdminUpdateUserPermissionsFormToJSON(json) {
  return AdminUpdateUserPermissionsFormToJSONTyped(json, false);
}
function AdminUpdateUserPermissionsFormToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "isGrafanaAdmin": value["isGrafanaAdmin"]
  };
}

// models/Alert.ts
function instanceOfAlert(value) {
  if (!("labels" in value) || value["labels"] === void 0) return false;
  return true;
}
function AlertFromJSON(json) {
  return AlertFromJSONTyped(json);
}
function AlertFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "generatorURL": json["generatorURL"] == null ? void 0 : json["generatorURL"],
    "labels": json["labels"]
  };
}
function AlertToJSON(json) {
  return AlertToJSONTyped(json, false);
}
function AlertToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "generatorURL": value["generatorURL"],
    "labels": value["labels"]
  };
}

// models/AlertDiscovery.ts
function instanceOfAlertDiscovery(value) {
  if (!("alerts" in value) || value["alerts"] === void 0) return false;
  return true;
}
function AlertDiscoveryFromJSON(json) {
  return AlertDiscoveryFromJSONTyped(json);
}
function AlertDiscoveryFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "alerts": json["alerts"].map(AlertFromJSON)
  };
}
function AlertDiscoveryToJSON(json) {
  return AlertDiscoveryToJSONTyped(json, false);
}
function AlertDiscoveryToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "alerts": value["alerts"].map(AlertToJSON)
  };
}

// models/AlertStatus.ts
var AlertStatusStateEnum = {
  UnprocessedActiveSuppressed: "[unprocessed active suppressed]"
};
function instanceOfAlertStatus(value) {
  if (!("inhibitedBy" in value) || value["inhibitedBy"] === void 0) return false;
  if (!("silencedBy" in value) || value["silencedBy"] === void 0) return false;
  if (!("state" in value) || value["state"] === void 0) return false;
  return true;
}
function AlertStatusFromJSON(json) {
  return AlertStatusFromJSONTyped(json);
}
function AlertStatusFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "inhibitedBy": json["inhibitedBy"],
    "silencedBy": json["silencedBy"],
    "state": json["state"]
  };
}
function AlertStatusToJSON(json) {
  return AlertStatusToJSONTyped(json, false);
}
function AlertStatusToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "inhibitedBy": value["inhibitedBy"],
    "silencedBy": value["silencedBy"],
    "state": value["state"]
  };
}

// models/Integration.ts
function instanceOfIntegration(value) {
  if (!("name" in value) || value["name"] === void 0) return false;
  if (!("sendResolved" in value) || value["sendResolved"] === void 0) return false;
  return true;
}
function IntegrationFromJSON(json) {
  return IntegrationFromJSONTyped(json);
}
function IntegrationFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "lastNotifyAttempt": json["lastNotifyAttempt"] == null ? void 0 : new Date(json["lastNotifyAttempt"]),
    "lastNotifyAttemptDuration": json["lastNotifyAttemptDuration"] == null ? void 0 : json["lastNotifyAttemptDuration"],
    "lastNotifyAttemptError": json["lastNotifyAttemptError"] == null ? void 0 : json["lastNotifyAttemptError"],
    "name": json["name"],
    "sendResolved": json["sendResolved"]
  };
}
function IntegrationToJSON(json) {
  return IntegrationToJSONTyped(json, false);
}
function IntegrationToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "lastNotifyAttempt": value["lastNotifyAttempt"] == null ? void 0 : value["lastNotifyAttempt"].toISOString(),
    "lastNotifyAttemptDuration": value["lastNotifyAttemptDuration"],
    "lastNotifyAttemptError": value["lastNotifyAttemptError"],
    "name": value["name"],
    "sendResolved": value["sendResolved"]
  };
}

// models/Receiver.ts
function instanceOfReceiver(value) {
  if (!("active" in value) || value["active"] === void 0) return false;
  if (!("integrations" in value) || value["integrations"] === void 0) return false;
  if (!("name" in value) || value["name"] === void 0) return false;
  return true;
}
function ReceiverFromJSON(json) {
  return ReceiverFromJSONTyped(json);
}
function ReceiverFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "active": json["active"],
    "integrations": json["integrations"].map(IntegrationFromJSON),
    "name": json["name"]
  };
}
function ReceiverToJSON(json) {
  return ReceiverToJSONTyped(json, false);
}
function ReceiverToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "active": value["active"],
    "integrations": value["integrations"].map(IntegrationToJSON),
    "name": value["name"]
  };
}

// models/GettableAlert.ts
function instanceOfGettableAlert(value) {
  if (!("annotations" in value) || value["annotations"] === void 0) return false;
  if (!("endsAt" in value) || value["endsAt"] === void 0) return false;
  if (!("fingerprint" in value) || value["fingerprint"] === void 0) return false;
  if (!("labels" in value) || value["labels"] === void 0) return false;
  if (!("receivers" in value) || value["receivers"] === void 0) return false;
  if (!("startsAt" in value) || value["startsAt"] === void 0) return false;
  if (!("status" in value) || value["status"] === void 0) return false;
  if (!("updatedAt" in value) || value["updatedAt"] === void 0) return false;
  return true;
}
function GettableAlertFromJSON(json) {
  return GettableAlertFromJSONTyped(json);
}
function GettableAlertFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "annotations": json["annotations"],
    "endsAt": new Date(json["endsAt"]),
    "fingerprint": json["fingerprint"],
    "generatorURL": json["generatorURL"] == null ? void 0 : json["generatorURL"],
    "labels": json["labels"],
    "receivers": json["receivers"].map(ReceiverFromJSON),
    "startsAt": new Date(json["startsAt"]),
    "status": AlertStatusFromJSON(json["status"]),
    "updatedAt": new Date(json["updatedAt"])
  };
}
function GettableAlertToJSON(json) {
  return GettableAlertToJSONTyped(json, false);
}
function GettableAlertToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "annotations": value["annotations"],
    "endsAt": value["endsAt"].toISOString(),
    "fingerprint": value["fingerprint"],
    "generatorURL": value["generatorURL"],
    "labels": value["labels"],
    "receivers": value["receivers"].map(ReceiverToJSON),
    "startsAt": value["startsAt"].toISOString(),
    "status": AlertStatusToJSON(value["status"]),
    "updatedAt": value["updatedAt"].toISOString()
  };
}

// models/AlertGroup.ts
function instanceOfAlertGroup(value) {
  if (!("alerts" in value) || value["alerts"] === void 0) return false;
  if (!("labels" in value) || value["labels"] === void 0) return false;
  if (!("receiver" in value) || value["receiver"] === void 0) return false;
  return true;
}
function AlertGroupFromJSON(json) {
  return AlertGroupFromJSONTyped(json);
}
function AlertGroupFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "alerts": json["alerts"].map(GettableAlertFromJSON),
    "labels": json["labels"],
    "receiver": ReceiverFromJSON(json["receiver"])
  };
}
function AlertGroupToJSON(json) {
  return AlertGroupToJSONTyped(json, false);
}
function AlertGroupToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "alerts": value["alerts"].map(GettableAlertToJSON),
    "labels": value["labels"],
    "receiver": ReceiverToJSON(value["receiver"])
  };
}

// models/AlertInstancesResponse.ts
function instanceOfAlertInstancesResponse(value) {
  return true;
}
function AlertInstancesResponseFromJSON(json) {
  return AlertInstancesResponseFromJSONTyped(json);
}
function AlertInstancesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "instances": json["instances"] == null ? void 0 : json["instances"]
  };
}
function AlertInstancesResponseToJSON(json) {
  return AlertInstancesResponseToJSONTyped(json, false);
}
function AlertInstancesResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "instances": value["instances"]
  };
}

// models/AlertManager.ts
function instanceOfAlertManager(value) {
  return true;
}
function AlertManagerFromJSON(json) {
  return AlertManagerFromJSONTyped(json);
}
function AlertManagerFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "url": json["url"] == null ? void 0 : json["url"]
  };
}
function AlertManagerToJSON(json) {
  return AlertManagerToJSONTyped(json, false);
}
function AlertManagerToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "url": value["url"]
  };
}

// models/AlertManagersResult.ts
function instanceOfAlertManagersResult(value) {
  return true;
}
function AlertManagersResultFromJSON(json) {
  return AlertManagersResultFromJSONTyped(json);
}
function AlertManagersResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "activeAlertManagers": json["activeAlertManagers"] == null ? void 0 : json["activeAlertManagers"].map(AlertManagerFromJSON),
    "droppedAlertManagers": json["droppedAlertManagers"] == null ? void 0 : json["droppedAlertManagers"].map(AlertManagerFromJSON)
  };
}
function AlertManagersResultToJSON(json) {
  return AlertManagersResultToJSONTyped(json, false);
}
function AlertManagersResultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "activeAlertManagers": value["activeAlertManagers"] == null ? void 0 : value["activeAlertManagers"].map(AlertManagerToJSON),
    "droppedAlertManagers": value["droppedAlertManagers"] == null ? void 0 : value["droppedAlertManagers"].map(AlertManagerToJSON)
  };
}

// models/RelativeTimeRange.ts
function instanceOfRelativeTimeRange(value) {
  return true;
}
function RelativeTimeRangeFromJSON(json) {
  return RelativeTimeRangeFromJSONTyped(json);
}
function RelativeTimeRangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "from": json["from"] == null ? void 0 : json["from"],
    "to": json["to"] == null ? void 0 : json["to"]
  };
}
function RelativeTimeRangeToJSON(json) {
  return RelativeTimeRangeToJSONTyped(json, false);
}
function RelativeTimeRangeToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "from": value["from"],
    "to": value["to"]
  };
}

// models/AlertQuery.ts
function instanceOfAlertQuery(value) {
  return true;
}
function AlertQueryFromJSON(json) {
  return AlertQueryFromJSONTyped(json);
}
function AlertQueryFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "datasourceUid": json["datasourceUid"] == null ? void 0 : json["datasourceUid"],
    "model": json["model"] == null ? void 0 : json["model"],
    "queryType": json["queryType"] == null ? void 0 : json["queryType"],
    "refId": json["refId"] == null ? void 0 : json["refId"],
    "relativeTimeRange": json["relativeTimeRange"] == null ? void 0 : RelativeTimeRangeFromJSON(json["relativeTimeRange"])
  };
}
function AlertQueryToJSON(json) {
  return AlertQueryToJSONTyped(json, false);
}
function AlertQueryToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "datasourceUid": value["datasourceUid"],
    "model": value["model"],
    "queryType": value["queryType"],
    "refId": value["refId"],
    "relativeTimeRange": RelativeTimeRangeToJSON(value["relativeTimeRange"])
  };
}

// models/RelativeTimeRangeExport.ts
function instanceOfRelativeTimeRangeExport(value) {
  return true;
}
function RelativeTimeRangeExportFromJSON(json) {
  return RelativeTimeRangeExportFromJSONTyped(json);
}
function RelativeTimeRangeExportFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "from": json["from"] == null ? void 0 : json["from"],
    "to": json["to"] == null ? void 0 : json["to"]
  };
}
function RelativeTimeRangeExportToJSON(json) {
  return RelativeTimeRangeExportToJSONTyped(json, false);
}
function RelativeTimeRangeExportToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "from": value["from"],
    "to": value["to"]
  };
}

// models/AlertQueryExport.ts
function instanceOfAlertQueryExport(value) {
  return true;
}
function AlertQueryExportFromJSON(json) {
  return AlertQueryExportFromJSONTyped(json);
}
function AlertQueryExportFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "datasourceUid": json["datasourceUid"] == null ? void 0 : json["datasourceUid"],
    "model": json["model"] == null ? void 0 : json["model"],
    "queryType": json["queryType"] == null ? void 0 : json["queryType"],
    "refId": json["refId"] == null ? void 0 : json["refId"],
    "relativeTimeRange": json["relativeTimeRange"] == null ? void 0 : RelativeTimeRangeExportFromJSON(json["relativeTimeRange"])
  };
}
function AlertQueryExportToJSON(json) {
  return AlertQueryExportToJSONTyped(json, false);
}
function AlertQueryExportToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "datasourceUid": value["datasourceUid"],
    "model": value["model"],
    "queryType": value["queryType"],
    "refId": value["refId"],
    "relativeTimeRange": RelativeTimeRangeExportToJSON(value["relativeTimeRange"])
  };
}

// models/AlertResponse.ts
function instanceOfAlertResponse(value) {
  if (!("status" in value) || value["status"] === void 0) return false;
  return true;
}
function AlertResponseFromJSON(json) {
  return AlertResponseFromJSONTyped(json);
}
function AlertResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "data": json["data"] == null ? void 0 : AlertDiscoveryFromJSON(json["data"]),
    "error": json["error"] == null ? void 0 : json["error"],
    "errorType": json["errorType"] == null ? void 0 : json["errorType"],
    "status": json["status"]
  };
}
function AlertResponseToJSON(json) {
  return AlertResponseToJSONTyped(json, false);
}
function AlertResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "data": AlertDiscoveryToJSON(value["data"]),
    "error": value["error"],
    "errorType": value["errorType"],
    "status": value["status"]
  };
}

// models/AlertRuleNotificationSettingsExport.ts
function instanceOfAlertRuleNotificationSettingsExport(value) {
  return true;
}
function AlertRuleNotificationSettingsExportFromJSON(json) {
  return AlertRuleNotificationSettingsExportFromJSONTyped(json);
}
function AlertRuleNotificationSettingsExportFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "groupBy": json["group_by"] == null ? void 0 : json["group_by"],
    "groupInterval": json["group_interval"] == null ? void 0 : json["group_interval"],
    "groupWait": json["group_wait"] == null ? void 0 : json["group_wait"],
    "muteTimeIntervals": json["mute_time_intervals"] == null ? void 0 : json["mute_time_intervals"],
    "receiver": json["receiver"] == null ? void 0 : json["receiver"],
    "repeatInterval": json["repeat_interval"] == null ? void 0 : json["repeat_interval"]
  };
}
function AlertRuleNotificationSettingsExportToJSON(json) {
  return AlertRuleNotificationSettingsExportToJSONTyped(json, false);
}
function AlertRuleNotificationSettingsExportToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "group_by": value["groupBy"],
    "group_interval": value["groupInterval"],
    "group_wait": value["groupWait"],
    "mute_time_intervals": value["muteTimeIntervals"],
    "receiver": value["receiver"],
    "repeat_interval": value["repeatInterval"]
  };
}

// models/AlertRuleExport.ts
var AlertRuleExportExecErrStateEnum = {
  Ok: "OK",
  Alerting: "Alerting",
  Error: "Error"
};
var AlertRuleExportNoDataStateEnum = {
  Alerting: "Alerting",
  NoData: "NoData",
  Ok: "OK"
};
function instanceOfAlertRuleExport(value) {
  return true;
}
function AlertRuleExportFromJSON(json) {
  return AlertRuleExportFromJSONTyped(json);
}
function AlertRuleExportFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "annotations": json["annotations"] == null ? void 0 : json["annotations"],
    "condition": json["condition"] == null ? void 0 : json["condition"],
    "dasboardUid": json["dasboardUid"] == null ? void 0 : json["dasboardUid"],
    "data": json["data"] == null ? void 0 : json["data"].map(AlertQueryExportFromJSON),
    "execErrState": json["execErrState"] == null ? void 0 : json["execErrState"],
    "_for": json["for"] == null ? void 0 : json["for"],
    "isPaused": json["isPaused"] == null ? void 0 : json["isPaused"],
    "labels": json["labels"] == null ? void 0 : json["labels"],
    "noDataState": json["noDataState"] == null ? void 0 : json["noDataState"],
    "notificationSettings": json["notification_settings"] == null ? void 0 : AlertRuleNotificationSettingsExportFromJSON(json["notification_settings"]),
    "panelId": json["panelId"] == null ? void 0 : json["panelId"],
    "title": json["title"] == null ? void 0 : json["title"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function AlertRuleExportToJSON(json) {
  return AlertRuleExportToJSONTyped(json, false);
}
function AlertRuleExportToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "annotations": value["annotations"],
    "condition": value["condition"],
    "dasboardUid": value["dasboardUid"],
    "data": value["data"] == null ? void 0 : value["data"].map(AlertQueryExportToJSON),
    "execErrState": value["execErrState"],
    "for": value["_for"],
    "isPaused": value["isPaused"],
    "labels": value["labels"],
    "noDataState": value["noDataState"],
    "notification_settings": AlertRuleNotificationSettingsExportToJSON(value["notificationSettings"]),
    "panelId": value["panelId"],
    "title": value["title"],
    "uid": value["uid"]
  };
}

// models/AlertRuleNotificationSettings.ts
function instanceOfAlertRuleNotificationSettings(value) {
  if (!("receiver" in value) || value["receiver"] === void 0) return false;
  return true;
}
function AlertRuleNotificationSettingsFromJSON(json) {
  return AlertRuleNotificationSettingsFromJSONTyped(json);
}
function AlertRuleNotificationSettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "groupBy": json["group_by"] == null ? void 0 : json["group_by"],
    "groupInterval": json["group_interval"] == null ? void 0 : json["group_interval"],
    "groupWait": json["group_wait"] == null ? void 0 : json["group_wait"],
    "muteTimeIntervals": json["mute_time_intervals"] == null ? void 0 : json["mute_time_intervals"],
    "receiver": json["receiver"],
    "repeatInterval": json["repeat_interval"] == null ? void 0 : json["repeat_interval"]
  };
}
function AlertRuleNotificationSettingsToJSON(json) {
  return AlertRuleNotificationSettingsToJSONTyped(json, false);
}
function AlertRuleNotificationSettingsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "group_by": value["groupBy"],
    "group_interval": value["groupInterval"],
    "group_wait": value["groupWait"],
    "mute_time_intervals": value["muteTimeIntervals"],
    "receiver": value["receiver"],
    "repeat_interval": value["repeatInterval"]
  };
}

// models/ProvisionedAlertRule.ts
var ProvisionedAlertRuleExecErrStateEnum = {
  Ok: "OK",
  Alerting: "Alerting",
  Error: "Error"
};
var ProvisionedAlertRuleNoDataStateEnum = {
  Alerting: "Alerting",
  NoData: "NoData",
  Ok: "OK"
};
function instanceOfProvisionedAlertRule(value) {
  if (!("condition" in value) || value["condition"] === void 0) return false;
  if (!("data" in value) || value["data"] === void 0) return false;
  if (!("execErrState" in value) || value["execErrState"] === void 0) return false;
  if (!("folderUID" in value) || value["folderUID"] === void 0) return false;
  if (!("_for" in value) || value["_for"] === void 0) return false;
  if (!("noDataState" in value) || value["noDataState"] === void 0) return false;
  if (!("orgID" in value) || value["orgID"] === void 0) return false;
  if (!("ruleGroup" in value) || value["ruleGroup"] === void 0) return false;
  if (!("title" in value) || value["title"] === void 0) return false;
  return true;
}
function ProvisionedAlertRuleFromJSON(json) {
  return ProvisionedAlertRuleFromJSONTyped(json);
}
function ProvisionedAlertRuleFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "annotations": json["annotations"] == null ? void 0 : json["annotations"],
    "condition": json["condition"],
    "data": json["data"].map(AlertQueryFromJSON),
    "execErrState": json["execErrState"],
    "folderUID": json["folderUID"],
    "_for": json["for"],
    "id": json["id"] == null ? void 0 : json["id"],
    "isPaused": json["isPaused"] == null ? void 0 : json["isPaused"],
    "labels": json["labels"] == null ? void 0 : json["labels"],
    "noDataState": json["noDataState"],
    "notificationSettings": json["notification_settings"] == null ? void 0 : AlertRuleNotificationSettingsFromJSON(json["notification_settings"]),
    "orgID": json["orgID"],
    "provenance": json["provenance"] == null ? void 0 : json["provenance"],
    "ruleGroup": json["ruleGroup"],
    "title": json["title"],
    "uid": json["uid"] == null ? void 0 : json["uid"],
    "updated": json["updated"] == null ? void 0 : new Date(json["updated"])
  };
}
function ProvisionedAlertRuleToJSON(json) {
  return ProvisionedAlertRuleToJSONTyped(json, false);
}
function ProvisionedAlertRuleToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "annotations": value["annotations"],
    "condition": value["condition"],
    "data": value["data"].map(AlertQueryToJSON),
    "execErrState": value["execErrState"],
    "folderUID": value["folderUID"],
    "for": value["_for"],
    "id": value["id"],
    "isPaused": value["isPaused"],
    "labels": value["labels"],
    "noDataState": value["noDataState"],
    "notification_settings": AlertRuleNotificationSettingsToJSON(value["notificationSettings"]),
    "orgID": value["orgID"],
    "provenance": value["provenance"],
    "ruleGroup": value["ruleGroup"],
    "title": value["title"],
    "uid": value["uid"]
  };
}

// models/AlertRuleGroup.ts
function instanceOfAlertRuleGroup(value) {
  return true;
}
function AlertRuleGroupFromJSON(json) {
  return AlertRuleGroupFromJSONTyped(json);
}
function AlertRuleGroupFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "folderUid": json["folderUid"] == null ? void 0 : json["folderUid"],
    "interval": json["interval"] == null ? void 0 : json["interval"],
    "rules": json["rules"] == null ? void 0 : json["rules"].map(ProvisionedAlertRuleFromJSON),
    "title": json["title"] == null ? void 0 : json["title"]
  };
}
function AlertRuleGroupToJSON(json) {
  return AlertRuleGroupToJSONTyped(json, false);
}
function AlertRuleGroupToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "folderUid": value["folderUid"],
    "interval": value["interval"],
    "rules": value["rules"] == null ? void 0 : value["rules"].map(ProvisionedAlertRuleToJSON),
    "title": value["title"]
  };
}

// models/AlertRuleGroupExport.ts
function instanceOfAlertRuleGroupExport(value) {
  return true;
}
function AlertRuleGroupExportFromJSON(json) {
  return AlertRuleGroupExportFromJSONTyped(json);
}
function AlertRuleGroupExportFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "folder": json["folder"] == null ? void 0 : json["folder"],
    "interval": json["interval"] == null ? void 0 : json["interval"],
    "name": json["name"] == null ? void 0 : json["name"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "rules": json["rules"] == null ? void 0 : json["rules"].map(AlertRuleExportFromJSON)
  };
}
function AlertRuleGroupExportToJSON(json) {
  return AlertRuleGroupExportToJSONTyped(json, false);
}
function AlertRuleGroupExportToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "folder": value["folder"],
    "interval": value["interval"],
    "name": value["name"],
    "orgId": value["orgId"],
    "rules": value["rules"] == null ? void 0 : value["rules"].map(AlertRuleExportToJSON)
  };
}

// models/AlertRuleGroupMetadata.ts
function instanceOfAlertRuleGroupMetadata(value) {
  return true;
}
function AlertRuleGroupMetadataFromJSON(json) {
  return AlertRuleGroupMetadataFromJSONTyped(json);
}
function AlertRuleGroupMetadataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "interval": json["interval"] == null ? void 0 : json["interval"]
  };
}
function AlertRuleGroupMetadataToJSON(json) {
  return AlertRuleGroupMetadataToJSONTyped(json, false);
}
function AlertRuleGroupMetadataToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "interval": value["interval"]
  };
}

// models/ReceiverExport.ts
function instanceOfReceiverExport(value) {
  return true;
}
function ReceiverExportFromJSON(json) {
  return ReceiverExportFromJSONTyped(json);
}
function ReceiverExportFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "disableResolveMessage": json["disableResolveMessage"] == null ? void 0 : json["disableResolveMessage"],
    "settings": json["settings"] == null ? void 0 : json["settings"],
    "type": json["type"] == null ? void 0 : json["type"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function ReceiverExportToJSON(json) {
  return ReceiverExportToJSONTyped(json, false);
}
function ReceiverExportToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "disableResolveMessage": value["disableResolveMessage"],
    "settings": value["settings"],
    "type": value["type"],
    "uid": value["uid"]
  };
}

// models/ContactPointExport.ts
function instanceOfContactPointExport(value) {
  return true;
}
function ContactPointExportFromJSON(json) {
  return ContactPointExportFromJSONTyped(json);
}
function ContactPointExportFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "receivers": json["receivers"] == null ? void 0 : json["receivers"].map(ReceiverExportFromJSON)
  };
}
function ContactPointExportToJSON(json) {
  return ContactPointExportToJSONTyped(json, false);
}
function ContactPointExportToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "orgId": value["orgId"],
    "receivers": value["receivers"] == null ? void 0 : value["receivers"].map(ReceiverExportToJSON)
  };
}

// models/Matcher.ts
function instanceOfMatcher(value) {
  if (!("isRegex" in value) || value["isRegex"] === void 0) return false;
  if (!("name" in value) || value["name"] === void 0) return false;
  if (!("value" in value) || value["value"] === void 0) return false;
  return true;
}
function MatcherFromJSON(json) {
  return MatcherFromJSONTyped(json);
}
function MatcherFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "isEqual": json["isEqual"] == null ? void 0 : json["isEqual"],
    "isRegex": json["isRegex"],
    "name": json["name"],
    "value": json["value"]
  };
}
function MatcherToJSON(json) {
  return MatcherToJSONTyped(json, false);
}
function MatcherToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "isEqual": value["isEqual"],
    "isRegex": value["isRegex"],
    "name": value["name"],
    "value": value["value"]
  };
}

// models/RouteExport.ts
function instanceOfRouteExport(value) {
  return true;
}
function RouteExportFromJSON(json) {
  return RouteExportFromJSONTyped(json);
}
function RouteExportFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "_continue": json["continue"] == null ? void 0 : json["continue"],
    "groupBy": json["group_by"] == null ? void 0 : json["group_by"],
    "groupInterval": json["group_interval"] == null ? void 0 : json["group_interval"],
    "groupWait": json["group_wait"] == null ? void 0 : json["group_wait"],
    "match": json["match"] == null ? void 0 : json["match"],
    "matchRe": json["match_re"] == null ? void 0 : json["match_re"],
    "matchers": json["matchers"] == null ? void 0 : json["matchers"].map(MatcherFromJSON),
    "muteTimeIntervals": json["mute_time_intervals"] == null ? void 0 : json["mute_time_intervals"],
    "objectMatchers": json["object_matchers"] == null ? void 0 : json["object_matchers"],
    "receiver": json["receiver"] == null ? void 0 : json["receiver"],
    "repeatInterval": json["repeat_interval"] == null ? void 0 : json["repeat_interval"],
    "routes": json["routes"] == null ? void 0 : json["routes"].map(RouteExportFromJSON)
  };
}
function RouteExportToJSON(json) {
  return RouteExportToJSONTyped(json, false);
}
function RouteExportToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "continue": value["_continue"],
    "group_by": value["groupBy"],
    "group_interval": value["groupInterval"],
    "group_wait": value["groupWait"],
    "match": value["match"],
    "match_re": value["matchRe"],
    "matchers": value["matchers"] == null ? void 0 : value["matchers"].map(MatcherToJSON),
    "mute_time_intervals": value["muteTimeIntervals"],
    "object_matchers": value["objectMatchers"],
    "receiver": value["receiver"],
    "repeat_interval": value["repeatInterval"],
    "routes": value["routes"] == null ? void 0 : value["routes"].map(RouteExportToJSON)
  };
}

// models/NotificationPolicyExport.ts
function instanceOfNotificationPolicyExport(value) {
  return true;
}
function NotificationPolicyExportFromJSON(json) {
  return NotificationPolicyExportFromJSONTyped(json);
}
function NotificationPolicyExportFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "_continue": json["continue"] == null ? void 0 : json["continue"],
    "groupBy": json["group_by"] == null ? void 0 : json["group_by"],
    "groupInterval": json["group_interval"] == null ? void 0 : json["group_interval"],
    "groupWait": json["group_wait"] == null ? void 0 : json["group_wait"],
    "match": json["match"] == null ? void 0 : json["match"],
    "matchRe": json["match_re"] == null ? void 0 : json["match_re"],
    "matchers": json["matchers"] == null ? void 0 : json["matchers"].map(MatcherFromJSON),
    "muteTimeIntervals": json["mute_time_intervals"] == null ? void 0 : json["mute_time_intervals"],
    "objectMatchers": json["object_matchers"] == null ? void 0 : json["object_matchers"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "receiver": json["receiver"] == null ? void 0 : json["receiver"],
    "repeatInterval": json["repeat_interval"] == null ? void 0 : json["repeat_interval"],
    "routes": json["routes"] == null ? void 0 : json["routes"].map(RouteExportFromJSON)
  };
}
function NotificationPolicyExportToJSON(json) {
  return NotificationPolicyExportToJSONTyped(json, false);
}
function NotificationPolicyExportToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "continue": value["_continue"],
    "group_by": value["groupBy"],
    "group_interval": value["groupInterval"],
    "group_wait": value["groupWait"],
    "match": value["match"],
    "match_re": value["matchRe"],
    "matchers": value["matchers"] == null ? void 0 : value["matchers"].map(MatcherToJSON),
    "mute_time_intervals": value["muteTimeIntervals"],
    "object_matchers": value["objectMatchers"],
    "orgId": value["orgId"],
    "receiver": value["receiver"],
    "repeat_interval": value["repeatInterval"],
    "routes": value["routes"] == null ? void 0 : value["routes"].map(RouteExportToJSON)
  };
}

// models/TimeInterval.ts
function instanceOfTimeInterval(value) {
  return true;
}
function TimeIntervalFromJSON(json) {
  return TimeIntervalFromJSONTyped(json);
}
function TimeIntervalFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "timeIntervals": json["time_intervals"] == null ? void 0 : json["time_intervals"].map(TimeIntervalFromJSON)
  };
}
function TimeIntervalToJSON(json) {
  return TimeIntervalToJSONTyped(json, false);
}
function TimeIntervalToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "time_intervals": value["timeIntervals"] == null ? void 0 : value["timeIntervals"].map(TimeIntervalToJSON)
  };
}

// models/MuteTimeIntervalExport.ts
function instanceOfMuteTimeIntervalExport(value) {
  return true;
}
function MuteTimeIntervalExportFromJSON(json) {
  return MuteTimeIntervalExportFromJSONTyped(json);
}
function MuteTimeIntervalExportFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "timeIntervals": json["time_intervals"] == null ? void 0 : json["time_intervals"].map(TimeIntervalFromJSON)
  };
}
function MuteTimeIntervalExportToJSON(json) {
  return MuteTimeIntervalExportToJSONTyped(json, false);
}
function MuteTimeIntervalExportToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "orgId": value["orgId"],
    "time_intervals": value["timeIntervals"] == null ? void 0 : value["timeIntervals"].map(TimeIntervalToJSON)
  };
}

// models/AlertingFileExport.ts
function instanceOfAlertingFileExport(value) {
  return true;
}
function AlertingFileExportFromJSON(json) {
  return AlertingFileExportFromJSONTyped(json);
}
function AlertingFileExportFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "apiVersion": json["apiVersion"] == null ? void 0 : json["apiVersion"],
    "contactPoints": json["contactPoints"] == null ? void 0 : json["contactPoints"].map(ContactPointExportFromJSON),
    "groups": json["groups"] == null ? void 0 : json["groups"].map(AlertRuleGroupExportFromJSON),
    "muteTimes": json["muteTimes"] == null ? void 0 : json["muteTimes"].map(MuteTimeIntervalExportFromJSON),
    "policies": json["policies"] == null ? void 0 : json["policies"].map(NotificationPolicyExportFromJSON)
  };
}
function AlertingFileExportToJSON(json) {
  return AlertingFileExportToJSONTyped(json, false);
}
function AlertingFileExportToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "apiVersion": value["apiVersion"],
    "contactPoints": value["contactPoints"] == null ? void 0 : value["contactPoints"].map(ContactPointExportToJSON),
    "groups": value["groups"] == null ? void 0 : value["groups"].map(AlertRuleGroupExportToJSON),
    "muteTimes": value["muteTimes"] == null ? void 0 : value["muteTimes"].map(MuteTimeIntervalExportToJSON),
    "policies": value["policies"] == null ? void 0 : value["policies"].map(NotificationPolicyExportToJSON)
  };
}

// models/AlertingRule.ts
function instanceOfAlertingRule(value) {
  if (!("activeAt" in value) || value["activeAt"] === void 0) return false;
  if (!("annotations" in value) || value["annotations"] === void 0) return false;
  if (!("health" in value) || value["health"] === void 0) return false;
  if (!("name" in value) || value["name"] === void 0) return false;
  if (!("query" in value) || value["query"] === void 0) return false;
  if (!("state" in value) || value["state"] === void 0) return false;
  if (!("type" in value) || value["type"] === void 0) return false;
  return true;
}
function AlertingRuleFromJSON(json) {
  return AlertingRuleFromJSONTyped(json);
}
function AlertingRuleFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "activeAt": new Date(json["activeAt"]),
    "alerts": json["alerts"] == null ? void 0 : json["alerts"].map(AlertFromJSON),
    "annotations": json["annotations"],
    "duration": json["duration"] == null ? void 0 : json["duration"],
    "evaluationTime": json["evaluationTime"] == null ? void 0 : json["evaluationTime"],
    "health": json["health"],
    "labels": json["labels"] == null ? void 0 : json["labels"],
    "lastError": json["lastError"] == null ? void 0 : json["lastError"],
    "lastEvaluation": json["lastEvaluation"] == null ? void 0 : new Date(json["lastEvaluation"]),
    "name": json["name"],
    "query": json["query"],
    "state": json["state"],
    "totals": json["totals"] == null ? void 0 : json["totals"],
    "totalsFiltered": json["totalsFiltered"] == null ? void 0 : json["totalsFiltered"],
    "type": json["type"]
  };
}
function AlertingRuleToJSON(json) {
  return AlertingRuleToJSONTyped(json, false);
}
function AlertingRuleToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "activeAt": value["activeAt"].toISOString(),
    "alerts": value["alerts"] == null ? void 0 : value["alerts"].map(AlertToJSON),
    "annotations": value["annotations"],
    "duration": value["duration"],
    "evaluationTime": value["evaluationTime"],
    "health": value["health"],
    "labels": value["labels"],
    "lastError": value["lastError"],
    "lastEvaluation": value["lastEvaluation"] == null ? void 0 : value["lastEvaluation"].toISOString(),
    "name": value["name"],
    "query": value["query"],
    "state": value["state"],
    "totals": value["totals"],
    "totalsFiltered": value["totalsFiltered"],
    "type": value["type"]
  };
}

// models/AlertingStatus.ts
var AlertingStatusAlertmanagersChoiceEnum = {
  All: "all",
  Internal: "internal",
  External: "external"
};
function instanceOfAlertingStatus(value) {
  return true;
}
function AlertingStatusFromJSON(json) {
  return AlertingStatusFromJSONTyped(json);
}
function AlertingStatusFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "alertmanagersChoice": json["alertmanagersChoice"] == null ? void 0 : json["alertmanagersChoice"],
    "numExternalAlertmanagers": json["numExternalAlertmanagers"] == null ? void 0 : json["numExternalAlertmanagers"]
  };
}
function AlertingStatusToJSON(json) {
  return AlertingStatusToJSONTyped(json, false);
}
function AlertingStatusToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "alertmanagersChoice": value["alertmanagersChoice"],
    "numExternalAlertmanagers": value["numExternalAlertmanagers"]
  };
}

// models/AlertmanagerConfig.ts
function instanceOfAlertmanagerConfig(value) {
  if (!("original" in value) || value["original"] === void 0) return false;
  return true;
}
function AlertmanagerConfigFromJSON(json) {
  return AlertmanagerConfigFromJSONTyped(json);
}
function AlertmanagerConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "original": json["original"]
  };
}
function AlertmanagerConfigToJSON(json) {
  return AlertmanagerConfigToJSONTyped(json, false);
}
function AlertmanagerConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "original": value["original"]
  };
}

// models/VersionInfo.ts
function instanceOfVersionInfo(value) {
  if (!("branch" in value) || value["branch"] === void 0) return false;
  if (!("buildDate" in value) || value["buildDate"] === void 0) return false;
  if (!("buildUser" in value) || value["buildUser"] === void 0) return false;
  if (!("goVersion" in value) || value["goVersion"] === void 0) return false;
  if (!("revision" in value) || value["revision"] === void 0) return false;
  if (!("version" in value) || value["version"] === void 0) return false;
  return true;
}
function VersionInfoFromJSON(json) {
  return VersionInfoFromJSONTyped(json);
}
function VersionInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "branch": json["branch"],
    "buildDate": json["buildDate"],
    "buildUser": json["buildUser"],
    "goVersion": json["goVersion"],
    "revision": json["revision"],
    "version": json["version"]
  };
}
function VersionInfoToJSON(json) {
  return VersionInfoToJSONTyped(json, false);
}
function VersionInfoToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "branch": value["branch"],
    "buildDate": value["buildDate"],
    "buildUser": value["buildUser"],
    "goVersion": value["goVersion"],
    "revision": value["revision"],
    "version": value["version"]
  };
}

// models/PeerStatus.ts
function instanceOfPeerStatus(value) {
  if (!("address" in value) || value["address"] === void 0) return false;
  if (!("name" in value) || value["name"] === void 0) return false;
  return true;
}
function PeerStatusFromJSON(json) {
  return PeerStatusFromJSONTyped(json);
}
function PeerStatusFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "address": json["address"],
    "name": json["name"]
  };
}
function PeerStatusToJSON(json) {
  return PeerStatusToJSONTyped(json, false);
}
function PeerStatusToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "address": value["address"],
    "name": value["name"]
  };
}

// models/ClusterStatus.ts
var ClusterStatusStatusEnum = {
  ReadySettlingDisabled: "[ready settling disabled]"
};
function instanceOfClusterStatus(value) {
  if (!("status" in value) || value["status"] === void 0) return false;
  return true;
}
function ClusterStatusFromJSON(json) {
  return ClusterStatusFromJSONTyped(json);
}
function ClusterStatusFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "peers": json["peers"] == null ? void 0 : json["peers"].map(PeerStatusFromJSON),
    "status": json["status"]
  };
}
function ClusterStatusToJSON(json) {
  return ClusterStatusToJSONTyped(json, false);
}
function ClusterStatusToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "peers": value["peers"] == null ? void 0 : value["peers"].map(PeerStatusToJSON),
    "status": value["status"]
  };
}

// models/AlertmanagerStatus.ts
function instanceOfAlertmanagerStatus(value) {
  if (!("cluster" in value) || value["cluster"] === void 0) return false;
  if (!("config" in value) || value["config"] === void 0) return false;
  if (!("uptime" in value) || value["uptime"] === void 0) return false;
  if (!("versionInfo" in value) || value["versionInfo"] === void 0) return false;
  return true;
}
function AlertmanagerStatusFromJSON(json) {
  return AlertmanagerStatusFromJSONTyped(json);
}
function AlertmanagerStatusFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "cluster": ClusterStatusFromJSON(json["cluster"]),
    "config": AlertmanagerConfigFromJSON(json["config"]),
    "uptime": new Date(json["uptime"]),
    "versionInfo": VersionInfoFromJSON(json["versionInfo"])
  };
}
function AlertmanagerStatusToJSON(json) {
  return AlertmanagerStatusToJSONTyped(json, false);
}
function AlertmanagerStatusToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "cluster": ClusterStatusToJSON(value["cluster"]),
    "config": AlertmanagerConfigToJSON(value["config"]),
    "uptime": value["uptime"].toISOString(),
    "versionInfo": VersionInfoToJSON(value["versionInfo"])
  };
}

// models/Annotation.ts
function instanceOfAnnotation(value) {
  return true;
}
function AnnotationFromJSON(json) {
  return AnnotationFromJSONTyped(json);
}
function AnnotationFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "alertId": json["alertId"] == null ? void 0 : json["alertId"],
    "alertName": json["alertName"] == null ? void 0 : json["alertName"],
    "avatarUrl": json["avatarUrl"] == null ? void 0 : json["avatarUrl"],
    "created": json["created"] == null ? void 0 : json["created"],
    "dashboardId": json["dashboardId"] == null ? void 0 : json["dashboardId"],
    "dashboardUID": json["dashboardUID"] == null ? void 0 : json["dashboardUID"],
    "data": json["data"] == null ? void 0 : json["data"],
    "email": json["email"] == null ? void 0 : json["email"],
    "id": json["id"] == null ? void 0 : json["id"],
    "login": json["login"] == null ? void 0 : json["login"],
    "newState": json["newState"] == null ? void 0 : json["newState"],
    "panelId": json["panelId"] == null ? void 0 : json["panelId"],
    "prevState": json["prevState"] == null ? void 0 : json["prevState"],
    "tags": json["tags"] == null ? void 0 : json["tags"],
    "text": json["text"] == null ? void 0 : json["text"],
    "time": json["time"] == null ? void 0 : json["time"],
    "timeEnd": json["timeEnd"] == null ? void 0 : json["timeEnd"],
    "updated": json["updated"] == null ? void 0 : json["updated"],
    "userId": json["userId"] == null ? void 0 : json["userId"]
  };
}
function AnnotationToJSON(json) {
  return AnnotationToJSONTyped(json, false);
}
function AnnotationToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "alertId": value["alertId"],
    "alertName": value["alertName"],
    "avatarUrl": value["avatarUrl"],
    "created": value["created"],
    "dashboardId": value["dashboardId"],
    "dashboardUID": value["dashboardUID"],
    "data": value["data"],
    "email": value["email"],
    "id": value["id"],
    "login": value["login"],
    "newState": value["newState"],
    "panelId": value["panelId"],
    "prevState": value["prevState"],
    "tags": value["tags"],
    "text": value["text"],
    "time": value["time"],
    "timeEnd": value["timeEnd"],
    "updated": value["updated"],
    "userId": value["userId"]
  };
}

// models/AnnotationActions.ts
function instanceOfAnnotationActions(value) {
  return true;
}
function AnnotationActionsFromJSON(json) {
  return AnnotationActionsFromJSONTyped(json);
}
function AnnotationActionsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "canAdd": json["canAdd"] == null ? void 0 : json["canAdd"],
    "canDelete": json["canDelete"] == null ? void 0 : json["canDelete"],
    "canEdit": json["canEdit"] == null ? void 0 : json["canEdit"]
  };
}
function AnnotationActionsToJSON(json) {
  return AnnotationActionsToJSONTyped(json, false);
}
function AnnotationActionsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "canAdd": value["canAdd"],
    "canDelete": value["canDelete"],
    "canEdit": value["canEdit"]
  };
}

// models/AnnotationTarget.ts
function instanceOfAnnotationTarget(value) {
  return true;
}
function AnnotationTargetFromJSON(json) {
  return AnnotationTargetFromJSONTyped(json);
}
function AnnotationTargetFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "limit": json["limit"] == null ? void 0 : json["limit"],
    "matchAny": json["matchAny"] == null ? void 0 : json["matchAny"],
    "tags": json["tags"] == null ? void 0 : json["tags"],
    "type": json["type"] == null ? void 0 : json["type"]
  };
}
function AnnotationTargetToJSON(json) {
  return AnnotationTargetToJSONTyped(json, false);
}
function AnnotationTargetToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "limit": value["limit"],
    "matchAny": value["matchAny"],
    "tags": value["tags"],
    "type": value["type"]
  };
}

// models/DataSourceRef.ts
function instanceOfDataSourceRef(value) {
  return true;
}
function DataSourceRefFromJSON(json) {
  return DataSourceRefFromJSONTyped(json);
}
function DataSourceRefFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["type"] == null ? void 0 : json["type"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function DataSourceRefToJSON(json) {
  return DataSourceRefToJSONTyped(json, false);
}
function DataSourceRefToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "type": value["type"],
    "uid": value["uid"]
  };
}

// models/AnnotationPanelFilter.ts
function instanceOfAnnotationPanelFilter(value) {
  return true;
}
function AnnotationPanelFilterFromJSON(json) {
  return AnnotationPanelFilterFromJSONTyped(json);
}
function AnnotationPanelFilterFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "exclude": json["exclude"] == null ? void 0 : json["exclude"],
    "ids": json["ids"] == null ? void 0 : json["ids"]
  };
}
function AnnotationPanelFilterToJSON(json) {
  return AnnotationPanelFilterToJSONTyped(json, false);
}
function AnnotationPanelFilterToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "exclude": value["exclude"],
    "ids": value["ids"]
  };
}

// models/AnnotationQuery.ts
function instanceOfAnnotationQuery(value) {
  return true;
}
function AnnotationQueryFromJSON(json) {
  return AnnotationQueryFromJSONTyped(json);
}
function AnnotationQueryFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "builtIn": json["builtIn"] == null ? void 0 : json["builtIn"],
    "datasource": json["datasource"] == null ? void 0 : DataSourceRefFromJSON(json["datasource"]),
    "enable": json["enable"] == null ? void 0 : json["enable"],
    "filter": json["filter"] == null ? void 0 : AnnotationPanelFilterFromJSON(json["filter"]),
    "hide": json["hide"] == null ? void 0 : json["hide"],
    "iconColor": json["iconColor"] == null ? void 0 : json["iconColor"],
    "name": json["name"] == null ? void 0 : json["name"],
    "target": json["target"] == null ? void 0 : AnnotationTargetFromJSON(json["target"]),
    "type": json["type"] == null ? void 0 : json["type"]
  };
}
function AnnotationQueryToJSON(json) {
  return AnnotationQueryToJSONTyped(json, false);
}
function AnnotationQueryToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "builtIn": value["builtIn"],
    "datasource": DataSourceRefToJSON(value["datasource"]),
    "enable": value["enable"],
    "filter": AnnotationPanelFilterToJSON(value["filter"]),
    "hide": value["hide"],
    "iconColor": value["iconColor"],
    "name": value["name"],
    "target": AnnotationTargetToJSON(value["target"]),
    "type": value["type"]
  };
}

// models/AnnotationEvent.ts
function instanceOfAnnotationEvent(value) {
  return true;
}
function AnnotationEventFromJSON(json) {
  return AnnotationEventFromJSONTyped(json);
}
function AnnotationEventFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "color": json["color"] == null ? void 0 : json["color"],
    "dashboardId": json["dashboardId"] == null ? void 0 : json["dashboardId"],
    "id": json["id"] == null ? void 0 : json["id"],
    "isRegion": json["isRegion"] == null ? void 0 : json["isRegion"],
    "panelId": json["panelId"] == null ? void 0 : json["panelId"],
    "source": json["source"] == null ? void 0 : AnnotationQueryFromJSON(json["source"]),
    "tags": json["tags"] == null ? void 0 : json["tags"],
    "text": json["text"] == null ? void 0 : json["text"],
    "time": json["time"] == null ? void 0 : json["time"],
    "timeEnd": json["timeEnd"] == null ? void 0 : json["timeEnd"]
  };
}
function AnnotationEventToJSON(json) {
  return AnnotationEventToJSONTyped(json, false);
}
function AnnotationEventToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "color": value["color"],
    "dashboardId": value["dashboardId"],
    "id": value["id"],
    "isRegion": value["isRegion"],
    "panelId": value["panelId"],
    "source": AnnotationQueryToJSON(value["source"]),
    "tags": value["tags"],
    "text": value["text"],
    "time": value["time"],
    "timeEnd": value["timeEnd"]
  };
}

// models/AnnotationPermission.ts
function instanceOfAnnotationPermission(value) {
  return true;
}
function AnnotationPermissionFromJSON(json) {
  return AnnotationPermissionFromJSONTyped(json);
}
function AnnotationPermissionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "dashboard": json["dashboard"] == null ? void 0 : AnnotationActionsFromJSON(json["dashboard"]),
    "organization": json["organization"] == null ? void 0 : AnnotationActionsFromJSON(json["organization"])
  };
}
function AnnotationPermissionToJSON(json) {
  return AnnotationPermissionToJSONTyped(json, false);
}
function AnnotationPermissionToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "dashboard": AnnotationActionsToJSON(value["dashboard"]),
    "organization": AnnotationActionsToJSON(value["organization"])
  };
}

// models/ApiKeyDTO.ts
var ApiKeyDTORoleEnum = {
  None: "None",
  Viewer: "Viewer",
  Editor: "Editor",
  Admin: "Admin"
};
function instanceOfApiKeyDTO(value) {
  return true;
}
function ApiKeyDTOFromJSON(json) {
  return ApiKeyDTOFromJSONTyped(json);
}
function ApiKeyDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "accessControl": json["accessControl"] == null ? void 0 : json["accessControl"],
    "expiration": json["expiration"] == null ? void 0 : new Date(json["expiration"]),
    "id": json["id"] == null ? void 0 : json["id"],
    "lastUsedAt": json["lastUsedAt"] == null ? void 0 : new Date(json["lastUsedAt"]),
    "name": json["name"] == null ? void 0 : json["name"],
    "role": json["role"] == null ? void 0 : json["role"]
  };
}
function ApiKeyDTOToJSON(json) {
  return ApiKeyDTOToJSONTyped(json, false);
}
function ApiKeyDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "accessControl": value["accessControl"],
    "expiration": value["expiration"] == null ? void 0 : value["expiration"].toISOString(),
    "id": value["id"],
    "lastUsedAt": value["lastUsedAt"] == null ? void 0 : value["lastUsedAt"].toISOString(),
    "name": value["name"],
    "role": value["role"]
  };
}

// models/ApiRuleNode.ts
function instanceOfApiRuleNode(value) {
  return true;
}
function ApiRuleNodeFromJSON(json) {
  return ApiRuleNodeFromJSONTyped(json);
}
function ApiRuleNodeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "alert": json["alert"] == null ? void 0 : json["alert"],
    "annotations": json["annotations"] == null ? void 0 : json["annotations"],
    "expr": json["expr"] == null ? void 0 : json["expr"],
    "_for": json["for"] == null ? void 0 : json["for"],
    "keepFiringFor": json["keep_firing_for"] == null ? void 0 : json["keep_firing_for"],
    "labels": json["labels"] == null ? void 0 : json["labels"],
    "record": json["record"] == null ? void 0 : json["record"]
  };
}
function ApiRuleNodeToJSON(json) {
  return ApiRuleNodeToJSONTyped(json, false);
}
function ApiRuleNodeToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "alert": value["alert"],
    "annotations": value["annotations"],
    "expr": value["expr"],
    "for": value["_for"],
    "keep_firing_for": value["keepFiringFor"],
    "labels": value["labels"],
    "record": value["record"]
  };
}

// models/Assignments.ts
function instanceOfAssignments(value) {
  return true;
}
function AssignmentsFromJSON(json) {
  return AssignmentsFromJSONTyped(json);
}
function AssignmentsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "builtInRoles": json["builtInRoles"] == null ? void 0 : json["builtInRoles"],
    "serviceAccounts": json["serviceAccounts"] == null ? void 0 : json["serviceAccounts"],
    "teams": json["teams"] == null ? void 0 : json["teams"],
    "users": json["users"] == null ? void 0 : json["users"]
  };
}
function AssignmentsToJSON(json) {
  return AssignmentsToJSONTyped(json, false);
}
function AssignmentsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "builtInRoles": value["builtInRoles"],
    "serviceAccounts": value["serviceAccounts"],
    "teams": value["teams"],
    "users": value["users"]
  };
}

// models/AttributeTypeAndValue.ts
function instanceOfAttributeTypeAndValue(value) {
  return true;
}
function AttributeTypeAndValueFromJSON(json) {
  return AttributeTypeAndValueFromJSONTyped(json);
}
function AttributeTypeAndValueFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "type": json["Type"] == null ? void 0 : json["Type"],
    "value": json["Value"] == null ? void 0 : json["Value"]
  };
}
function AttributeTypeAndValueToJSON(json) {
  return AttributeTypeAndValueToJSONTyped(json, false);
}
function AttributeTypeAndValueToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "Type": value["type"],
    "Value": value["value"]
  };
}

// models/Authorization.ts
function instanceOfAuthorization(value) {
  return true;
}
function AuthorizationFromJSON(json) {
  return AuthorizationFromJSONTyped(json);
}
function AuthorizationFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "credentials": json["credentials"] == null ? void 0 : json["credentials"],
    "credentialsFile": json["credentials_file"] == null ? void 0 : json["credentials_file"],
    "type": json["type"] == null ? void 0 : json["type"]
  };
}
function AuthorizationToJSON(json) {
  return AuthorizationToJSONTyped(json, false);
}
function AuthorizationToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "credentials": value["credentials"],
    "credentials_file": value["credentialsFile"],
    "type": value["type"]
  };
}

// models/BacktestConfig.ts
var BacktestConfigNoDataStateEnum = {
  Alerting: "Alerting",
  NoData: "NoData",
  Ok: "OK"
};
function instanceOfBacktestConfig(value) {
  return true;
}
function BacktestConfigFromJSON(json) {
  return BacktestConfigFromJSONTyped(json);
}
function BacktestConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "annotations": json["annotations"] == null ? void 0 : json["annotations"],
    "condition": json["condition"] == null ? void 0 : json["condition"],
    "data": json["data"] == null ? void 0 : json["data"].map(AlertQueryFromJSON),
    "_for": json["for"] == null ? void 0 : json["for"],
    "from": json["from"] == null ? void 0 : new Date(json["from"]),
    "interval": json["interval"] == null ? void 0 : json["interval"],
    "labels": json["labels"] == null ? void 0 : json["labels"],
    "noDataState": json["no_data_state"] == null ? void 0 : json["no_data_state"],
    "title": json["title"] == null ? void 0 : json["title"],
    "to": json["to"] == null ? void 0 : new Date(json["to"])
  };
}
function BacktestConfigToJSON(json) {
  return BacktestConfigToJSONTyped(json, false);
}
function BacktestConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "annotations": value["annotations"],
    "condition": value["condition"],
    "data": value["data"] == null ? void 0 : value["data"].map(AlertQueryToJSON),
    "for": value["_for"],
    "from": value["from"] == null ? void 0 : value["from"].toISOString(),
    "interval": value["interval"],
    "labels": value["labels"],
    "no_data_state": value["noDataState"],
    "title": value["title"],
    "to": value["to"] == null ? void 0 : value["to"].toISOString()
  };
}

// models/BasicAuth.ts
function instanceOfBasicAuth(value) {
  return true;
}
function BasicAuthFromJSON(json) {
  return BasicAuthFromJSONTyped(json);
}
function BasicAuthFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "password": json["password"] == null ? void 0 : json["password"],
    "passwordFile": json["password_file"] == null ? void 0 : json["password_file"],
    "username": json["username"] == null ? void 0 : json["username"],
    "usernameFile": json["username_file"] == null ? void 0 : json["username_file"]
  };
}
function BasicAuthToJSON(json) {
  return BasicAuthToJSONTyped(json, false);
}
function BasicAuthToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "password": value["password"],
    "password_file": value["passwordFile"],
    "username": value["username"],
    "username_file": value["usernameFile"]
  };
}

// models/CalculateDiffTarget.ts
function instanceOfCalculateDiffTarget(value) {
  return true;
}
function CalculateDiffTargetFromJSON(json) {
  return CalculateDiffTargetFromJSONTyped(json);
}
function CalculateDiffTargetFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "dashboardId": json["dashboardId"] == null ? void 0 : json["dashboardId"],
    "unsavedDashboard": json["unsavedDashboard"] == null ? void 0 : json["unsavedDashboard"],
    "version": json["version"] == null ? void 0 : json["version"]
  };
}
function CalculateDiffTargetToJSON(json) {
  return CalculateDiffTargetToJSONTyped(json, false);
}
function CalculateDiffTargetToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "dashboardId": value["dashboardId"],
    "unsavedDashboard": value["unsavedDashboard"],
    "version": value["version"]
  };
}

// models/CalculateDashboardDiffRequest.ts
var CalculateDashboardDiffRequestDiffTypeEnum = {
  Basic: "basic",
  Json: "json"
};
function instanceOfCalculateDashboardDiffRequest(value) {
  return true;
}
function CalculateDashboardDiffRequestFromJSON(json) {
  return CalculateDashboardDiffRequestFromJSONTyped(json);
}
function CalculateDashboardDiffRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "base": json["base"] == null ? void 0 : CalculateDiffTargetFromJSON(json["base"]),
    "diffType": json["diffType"] == null ? void 0 : json["diffType"],
    "_new": json["new"] == null ? void 0 : CalculateDiffTargetFromJSON(json["new"])
  };
}
function CalculateDashboardDiffRequestToJSON(json) {
  return CalculateDashboardDiffRequestToJSONTyped(json, false);
}
function CalculateDashboardDiffRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "base": CalculateDiffTargetToJSON(value["base"]),
    "diffType": value["diffType"],
    "new": CalculateDiffTargetToJSON(value["_new"])
  };
}

// models/Extension.ts
function instanceOfExtension(value) {
  return true;
}
function ExtensionFromJSON(json) {
  return ExtensionFromJSONTyped(json);
}
function ExtensionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "critical": json["Critical"] == null ? void 0 : json["Critical"],
    "id": json["Id"] == null ? void 0 : json["Id"],
    "value": json["Value"] == null ? void 0 : json["Value"]
  };
}
function ExtensionToJSON(json) {
  return ExtensionToJSONTyped(json, false);
}
function ExtensionToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "Critical": value["critical"],
    "Id": value["id"],
    "Value": value["value"]
  };
}

// models/IPNet.ts
function instanceOfIPNet(value) {
  return true;
}
function IPNetFromJSON(json) {
  return IPNetFromJSONTyped(json);
}
function IPNetFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "iP": json["IP"] == null ? void 0 : json["IP"],
    "mask": json["Mask"] == null ? void 0 : json["Mask"]
  };
}
function IPNetToJSON(json) {
  return IPNetToJSONTyped(json, false);
}
function IPNetToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "IP": value["iP"],
    "Mask": value["mask"]
  };
}

// models/URL.ts
function instanceOfURL(value) {
  return true;
}
function URLFromJSON(json) {
  return URLFromJSONTyped(json);
}
function URLFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "forceQuery": json["ForceQuery"] == null ? void 0 : json["ForceQuery"],
    "fragment": json["Fragment"] == null ? void 0 : json["Fragment"],
    "host": json["Host"] == null ? void 0 : json["Host"],
    "omitHost": json["OmitHost"] == null ? void 0 : json["OmitHost"],
    "opaque": json["Opaque"] == null ? void 0 : json["Opaque"],
    "path": json["Path"] == null ? void 0 : json["Path"],
    "rawFragment": json["RawFragment"] == null ? void 0 : json["RawFragment"],
    "rawPath": json["RawPath"] == null ? void 0 : json["RawPath"],
    "rawQuery": json["RawQuery"] == null ? void 0 : json["RawQuery"],
    "scheme": json["Scheme"] == null ? void 0 : json["Scheme"],
    "user": json["User"] == null ? void 0 : json["User"]
  };
}
function URLToJSON(json) {
  return URLToJSONTyped(json, false);
}
function URLToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "ForceQuery": value["forceQuery"],
    "Fragment": value["fragment"],
    "Host": value["host"],
    "OmitHost": value["omitHost"],
    "Opaque": value["opaque"],
    "Path": value["path"],
    "RawFragment": value["rawFragment"],
    "RawPath": value["rawPath"],
    "RawQuery": value["rawQuery"],
    "Scheme": value["scheme"],
    "User": value["user"]
  };
}

// models/Name.ts
function instanceOfName(value) {
  return true;
}
function NameFromJSON(json) {
  return NameFromJSONTyped(json);
}
function NameFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "country": json["Country"] == null ? void 0 : json["Country"],
    "extraNames": json["ExtraNames"] == null ? void 0 : json["ExtraNames"].map(AttributeTypeAndValueFromJSON),
    "locality": json["Locality"] == null ? void 0 : json["Locality"],
    "names": json["Names"] == null ? void 0 : json["Names"].map(AttributeTypeAndValueFromJSON),
    "serialNumber": json["SerialNumber"] == null ? void 0 : json["SerialNumber"],
    "streetAddress": json["StreetAddress"] == null ? void 0 : json["StreetAddress"]
  };
}
function NameToJSON(json) {
  return NameToJSONTyped(json, false);
}
function NameToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "Country": value["country"],
    "ExtraNames": value["extraNames"] == null ? void 0 : value["extraNames"].map(AttributeTypeAndValueToJSON),
    "Locality": value["locality"],
    "Names": value["names"] == null ? void 0 : value["names"].map(AttributeTypeAndValueToJSON),
    "SerialNumber": value["serialNumber"],
    "StreetAddress": value["streetAddress"]
  };
}

// models/Certificate.ts
function instanceOfCertificate(value) {
  return true;
}
function CertificateFromJSON(json) {
  return CertificateFromJSONTyped(json);
}
function CertificateFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "authorityKeyId": json["AuthorityKeyId"] == null ? void 0 : json["AuthorityKeyId"],
    "basicConstraintsValid": json["BasicConstraintsValid"] == null ? void 0 : json["BasicConstraintsValid"],
    "cRLDistributionPoints": json["CRLDistributionPoints"] == null ? void 0 : json["CRLDistributionPoints"],
    "dNSNames": json["DNSNames"] == null ? void 0 : json["DNSNames"],
    "emailAddresses": json["EmailAddresses"] == null ? void 0 : json["EmailAddresses"],
    "excludedDNSDomains": json["ExcludedDNSDomains"] == null ? void 0 : json["ExcludedDNSDomains"],
    "excludedEmailAddresses": json["ExcludedEmailAddresses"] == null ? void 0 : json["ExcludedEmailAddresses"],
    "excludedIPRanges": json["ExcludedIPRanges"] == null ? void 0 : json["ExcludedIPRanges"].map(IPNetFromJSON),
    "excludedURIDomains": json["ExcludedURIDomains"] == null ? void 0 : json["ExcludedURIDomains"],
    "extKeyUsage": json["ExtKeyUsage"] == null ? void 0 : json["ExtKeyUsage"],
    "extensions": json["Extensions"] == null ? void 0 : json["Extensions"].map(ExtensionFromJSON),
    "extraExtensions": json["ExtraExtensions"] == null ? void 0 : json["ExtraExtensions"].map(ExtensionFromJSON),
    "iPAddresses": json["IPAddresses"] == null ? void 0 : json["IPAddresses"],
    "isCA": json["IsCA"] == null ? void 0 : json["IsCA"],
    "issuer": json["Issuer"] == null ? void 0 : NameFromJSON(json["Issuer"]),
    "issuingCertificateURL": json["IssuingCertificateURL"] == null ? void 0 : json["IssuingCertificateURL"],
    "keyUsage": json["KeyUsage"] == null ? void 0 : json["KeyUsage"],
    "maxPathLen": json["MaxPathLen"] == null ? void 0 : json["MaxPathLen"],
    "maxPathLenZero": json["MaxPathLenZero"] == null ? void 0 : json["MaxPathLenZero"],
    "notBefore": json["NotBefore"] == null ? void 0 : new Date(json["NotBefore"]),
    "oCSPServer": json["OCSPServer"] == null ? void 0 : json["OCSPServer"],
    "permittedDNSDomains": json["PermittedDNSDomains"] == null ? void 0 : json["PermittedDNSDomains"],
    "permittedDNSDomainsCritical": json["PermittedDNSDomainsCritical"] == null ? void 0 : json["PermittedDNSDomainsCritical"],
    "permittedEmailAddresses": json["PermittedEmailAddresses"] == null ? void 0 : json["PermittedEmailAddresses"],
    "permittedIPRanges": json["PermittedIPRanges"] == null ? void 0 : json["PermittedIPRanges"].map(IPNetFromJSON),
    "permittedURIDomains": json["PermittedURIDomains"] == null ? void 0 : json["PermittedURIDomains"],
    "policyIdentifiers": json["PolicyIdentifiers"] == null ? void 0 : json["PolicyIdentifiers"],
    "publicKey": json["PublicKey"] == null ? void 0 : json["PublicKey"],
    "publicKeyAlgorithm": json["PublicKeyAlgorithm"] == null ? void 0 : json["PublicKeyAlgorithm"],
    "raw": json["Raw"] == null ? void 0 : json["Raw"],
    "rawIssuer": json["RawIssuer"] == null ? void 0 : json["RawIssuer"],
    "rawSubject": json["RawSubject"] == null ? void 0 : json["RawSubject"],
    "rawSubjectPublicKeyInfo": json["RawSubjectPublicKeyInfo"] == null ? void 0 : json["RawSubjectPublicKeyInfo"],
    "rawTBSCertificate": json["RawTBSCertificate"] == null ? void 0 : json["RawTBSCertificate"],
    "serialNumber": json["SerialNumber"] == null ? void 0 : json["SerialNumber"],
    "signature": json["Signature"] == null ? void 0 : json["Signature"],
    "signatureAlgorithm": json["SignatureAlgorithm"] == null ? void 0 : json["SignatureAlgorithm"],
    "subject": json["Subject"] == null ? void 0 : NameFromJSON(json["Subject"]),
    "subjectKeyId": json["SubjectKeyId"] == null ? void 0 : json["SubjectKeyId"],
    "uRIs": json["URIs"] == null ? void 0 : json["URIs"].map(URLFromJSON),
    "unhandledCriticalExtensions": json["UnhandledCriticalExtensions"] == null ? void 0 : json["UnhandledCriticalExtensions"],
    "unknownExtKeyUsage": json["UnknownExtKeyUsage"] == null ? void 0 : json["UnknownExtKeyUsage"],
    "version": json["Version"] == null ? void 0 : json["Version"]
  };
}
function CertificateToJSON(json) {
  return CertificateToJSONTyped(json, false);
}
function CertificateToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "AuthorityKeyId": value["authorityKeyId"],
    "BasicConstraintsValid": value["basicConstraintsValid"],
    "CRLDistributionPoints": value["cRLDistributionPoints"],
    "DNSNames": value["dNSNames"],
    "EmailAddresses": value["emailAddresses"],
    "ExcludedDNSDomains": value["excludedDNSDomains"],
    "ExcludedEmailAddresses": value["excludedEmailAddresses"],
    "ExcludedIPRanges": value["excludedIPRanges"] == null ? void 0 : value["excludedIPRanges"].map(IPNetToJSON),
    "ExcludedURIDomains": value["excludedURIDomains"],
    "ExtKeyUsage": value["extKeyUsage"],
    "Extensions": value["extensions"] == null ? void 0 : value["extensions"].map(ExtensionToJSON),
    "ExtraExtensions": value["extraExtensions"] == null ? void 0 : value["extraExtensions"].map(ExtensionToJSON),
    "IPAddresses": value["iPAddresses"],
    "IsCA": value["isCA"],
    "Issuer": NameToJSON(value["issuer"]),
    "IssuingCertificateURL": value["issuingCertificateURL"],
    "KeyUsage": value["keyUsage"],
    "MaxPathLen": value["maxPathLen"],
    "MaxPathLenZero": value["maxPathLenZero"],
    "NotBefore": value["notBefore"] == null ? void 0 : value["notBefore"].toISOString(),
    "OCSPServer": value["oCSPServer"],
    "PermittedDNSDomains": value["permittedDNSDomains"],
    "PermittedDNSDomainsCritical": value["permittedDNSDomainsCritical"],
    "PermittedEmailAddresses": value["permittedEmailAddresses"],
    "PermittedIPRanges": value["permittedIPRanges"] == null ? void 0 : value["permittedIPRanges"].map(IPNetToJSON),
    "PermittedURIDomains": value["permittedURIDomains"],
    "PolicyIdentifiers": value["policyIdentifiers"],
    "PublicKey": value["publicKey"],
    "PublicKeyAlgorithm": value["publicKeyAlgorithm"],
    "Raw": value["raw"],
    "RawIssuer": value["rawIssuer"],
    "RawSubject": value["rawSubject"],
    "RawSubjectPublicKeyInfo": value["rawSubjectPublicKeyInfo"],
    "RawTBSCertificate": value["rawTBSCertificate"],
    "SerialNumber": value["serialNumber"],
    "Signature": value["signature"],
    "SignatureAlgorithm": value["signatureAlgorithm"],
    "Subject": NameToJSON(value["subject"]),
    "SubjectKeyId": value["subjectKeyId"],
    "URIs": value["uRIs"] == null ? void 0 : value["uRIs"].map(URLToJSON),
    "UnhandledCriticalExtensions": value["unhandledCriticalExtensions"],
    "UnknownExtKeyUsage": value["unknownExtKeyUsage"],
    "Version": value["version"]
  };
}

// models/ChangeUserPasswordCommand.ts
function instanceOfChangeUserPasswordCommand(value) {
  return true;
}
function ChangeUserPasswordCommandFromJSON(json) {
  return ChangeUserPasswordCommandFromJSONTyped(json);
}
function ChangeUserPasswordCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "newPassword": json["newPassword"] == null ? void 0 : json["newPassword"],
    "oldPassword": json["oldPassword"] == null ? void 0 : json["oldPassword"]
  };
}
function ChangeUserPasswordCommandToJSON(json) {
  return ChangeUserPasswordCommandToJSONTyped(json, false);
}
function ChangeUserPasswordCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "newPassword": value["newPassword"],
    "oldPassword": value["oldPassword"]
  };
}

// models/ClearHelpFlags200Response.ts
function instanceOfClearHelpFlags200Response(value) {
  return true;
}
function ClearHelpFlags200ResponseFromJSON(json) {
  return ClearHelpFlags200ResponseFromJSONTyped(json);
}
function ClearHelpFlags200ResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "helpFlags1": json["helpFlags1"] == null ? void 0 : json["helpFlags1"],
    "message": json["message"] == null ? void 0 : json["message"]
  };
}
function ClearHelpFlags200ResponseToJSON(json) {
  return ClearHelpFlags200ResponseToJSONTyped(json, false);
}
function ClearHelpFlags200ResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "helpFlags1": value["helpFlags1"],
    "message": value["message"]
  };
}

// models/InhibitRule.ts
function instanceOfInhibitRule(value) {
  return true;
}
function InhibitRuleFromJSON(json) {
  return InhibitRuleFromJSONTyped(json);
}
function InhibitRuleFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "equal": json["equal"] == null ? void 0 : json["equal"],
    "sourceMatch": json["source_match"] == null ? void 0 : json["source_match"],
    "sourceMatchRe": json["source_match_re"] == null ? void 0 : json["source_match_re"],
    "sourceMatchers": json["source_matchers"] == null ? void 0 : json["source_matchers"].map(MatcherFromJSON),
    "targetMatch": json["target_match"] == null ? void 0 : json["target_match"],
    "targetMatchRe": json["target_match_re"] == null ? void 0 : json["target_match_re"],
    "targetMatchers": json["target_matchers"] == null ? void 0 : json["target_matchers"].map(MatcherFromJSON)
  };
}
function InhibitRuleToJSON(json) {
  return InhibitRuleToJSONTyped(json, false);
}
function InhibitRuleToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "equal": value["equal"],
    "source_match": value["sourceMatch"],
    "source_match_re": value["sourceMatchRe"],
    "source_matchers": value["sourceMatchers"] == null ? void 0 : value["sourceMatchers"].map(MatcherToJSON),
    "target_match": value["targetMatch"],
    "target_match_re": value["targetMatchRe"],
    "target_matchers": value["targetMatchers"] == null ? void 0 : value["targetMatchers"].map(MatcherToJSON)
  };
}

// models/MuteTimeInterval.ts
function instanceOfMuteTimeInterval(value) {
  return true;
}
function MuteTimeIntervalFromJSON(json) {
  return MuteTimeIntervalFromJSONTyped(json);
}
function MuteTimeIntervalFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "timeIntervals": json["time_intervals"] == null ? void 0 : json["time_intervals"].map(TimeIntervalFromJSON)
  };
}
function MuteTimeIntervalToJSON(json) {
  return MuteTimeIntervalToJSONTyped(json, false);
}
function MuteTimeIntervalToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "time_intervals": value["timeIntervals"] == null ? void 0 : value["timeIntervals"].map(TimeIntervalToJSON)
  };
}

// models/HostPort.ts
function instanceOfHostPort(value) {
  return true;
}
function HostPortFromJSON(json) {
  return HostPortFromJSONTyped(json);
}
function HostPortFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "host": json["Host"] == null ? void 0 : json["Host"],
    "port": json["Port"] == null ? void 0 : json["Port"]
  };
}
function HostPortToJSON(json) {
  return HostPortToJSONTyped(json, false);
}
function HostPortToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "Host": value["host"],
    "Port": value["port"]
  };
}

// models/TLSConfig.ts
function instanceOfTLSConfig(value) {
  return true;
}
function TLSConfigFromJSON(json) {
  return TLSConfigFromJSONTyped(json);
}
function TLSConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "ca": json["ca"] == null ? void 0 : json["ca"],
    "caFile": json["ca_file"] == null ? void 0 : json["ca_file"],
    "cert": json["cert"] == null ? void 0 : json["cert"],
    "certFile": json["cert_file"] == null ? void 0 : json["cert_file"],
    "insecureSkipVerify": json["insecure_skip_verify"] == null ? void 0 : json["insecure_skip_verify"],
    "key": json["key"] == null ? void 0 : json["key"],
    "keyFile": json["key_file"] == null ? void 0 : json["key_file"],
    "maxVersion": json["max_version"] == null ? void 0 : json["max_version"],
    "minVersion": json["min_version"] == null ? void 0 : json["min_version"],
    "serverName": json["server_name"] == null ? void 0 : json["server_name"]
  };
}
function TLSConfigToJSON(json) {
  return TLSConfigToJSONTyped(json, false);
}
function TLSConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "ca": value["ca"],
    "ca_file": value["caFile"],
    "cert": value["cert"],
    "cert_file": value["certFile"],
    "insecure_skip_verify": value["insecureSkipVerify"],
    "key": value["key"],
    "key_file": value["keyFile"],
    "max_version": value["maxVersion"],
    "min_version": value["minVersion"],
    "server_name": value["serverName"]
  };
}

// models/OAuth2.ts
function instanceOfOAuth2(value) {
  return true;
}
function OAuth2FromJSON(json) {
  return OAuth2FromJSONTyped(json);
}
function OAuth2FromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "tLSConfig": json["TLSConfig"] == null ? void 0 : TLSConfigFromJSON(json["TLSConfig"]),
    "clientId": json["client_id"] == null ? void 0 : json["client_id"],
    "clientSecret": json["client_secret"] == null ? void 0 : json["client_secret"],
    "clientSecretFile": json["client_secret_file"] == null ? void 0 : json["client_secret_file"],
    "endpointParams": json["endpoint_params"] == null ? void 0 : json["endpoint_params"],
    "noProxy": json["no_proxy"] == null ? void 0 : json["no_proxy"],
    "proxyConnectHeader": json["proxy_connect_header"] == null ? void 0 : json["proxy_connect_header"],
    "proxyFromEnvironment": json["proxy_from_environment"] == null ? void 0 : json["proxy_from_environment"],
    "proxyUrl": json["proxy_url"] == null ? void 0 : URLFromJSON(json["proxy_url"]),
    "scopes": json["scopes"] == null ? void 0 : json["scopes"],
    "tokenUrl": json["token_url"] == null ? void 0 : json["token_url"]
  };
}
function OAuth2ToJSON(json) {
  return OAuth2ToJSONTyped(json, false);
}
function OAuth2ToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "TLSConfig": TLSConfigToJSON(value["tLSConfig"]),
    "client_id": value["clientId"],
    "client_secret": value["clientSecret"],
    "client_secret_file": value["clientSecretFile"],
    "endpoint_params": value["endpointParams"],
    "no_proxy": value["noProxy"],
    "proxy_connect_header": value["proxyConnectHeader"],
    "proxy_from_environment": value["proxyFromEnvironment"],
    "proxy_url": URLToJSON(value["proxyUrl"]),
    "scopes": value["scopes"],
    "token_url": value["tokenUrl"]
  };
}

// models/HTTPClientConfig.ts
function instanceOfHTTPClientConfig(value) {
  return true;
}
function HTTPClientConfigFromJSON(json) {
  return HTTPClientConfigFromJSONTyped(json);
}
function HTTPClientConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "authorization": json["authorization"] == null ? void 0 : AuthorizationFromJSON(json["authorization"]),
    "basicAuth": json["basic_auth"] == null ? void 0 : BasicAuthFromJSON(json["basic_auth"]),
    "bearerToken": json["bearer_token"] == null ? void 0 : json["bearer_token"],
    "bearerTokenFile": json["bearer_token_file"] == null ? void 0 : json["bearer_token_file"],
    "enableHttp2": json["enable_http2"] == null ? void 0 : json["enable_http2"],
    "followRedirects": json["follow_redirects"] == null ? void 0 : json["follow_redirects"],
    "noProxy": json["no_proxy"] == null ? void 0 : json["no_proxy"],
    "oauth2": json["oauth2"] == null ? void 0 : OAuth2FromJSON(json["oauth2"]),
    "proxyConnectHeader": json["proxy_connect_header"] == null ? void 0 : json["proxy_connect_header"],
    "proxyFromEnvironment": json["proxy_from_environment"] == null ? void 0 : json["proxy_from_environment"],
    "proxyUrl": json["proxy_url"] == null ? void 0 : URLFromJSON(json["proxy_url"]),
    "tlsConfig": json["tls_config"] == null ? void 0 : TLSConfigFromJSON(json["tls_config"])
  };
}
function HTTPClientConfigToJSON(json) {
  return HTTPClientConfigToJSONTyped(json, false);
}
function HTTPClientConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "authorization": AuthorizationToJSON(value["authorization"]),
    "basic_auth": BasicAuthToJSON(value["basicAuth"]),
    "bearer_token": value["bearerToken"],
    "bearer_token_file": value["bearerTokenFile"],
    "enable_http2": value["enableHttp2"],
    "follow_redirects": value["followRedirects"],
    "no_proxy": value["noProxy"],
    "oauth2": OAuth2ToJSON(value["oauth2"]),
    "proxy_connect_header": value["proxyConnectHeader"],
    "proxy_from_environment": value["proxyFromEnvironment"],
    "proxy_url": URLToJSON(value["proxyUrl"]),
    "tls_config": TLSConfigToJSON(value["tlsConfig"])
  };
}

// models/GlobalConfig.ts
function instanceOfGlobalConfig(value) {
  return true;
}
function GlobalConfigFromJSON(json) {
  return GlobalConfigFromJSONTyped(json);
}
function GlobalConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "httpConfig": json["http_config"] == null ? void 0 : HTTPClientConfigFromJSON(json["http_config"]),
    "opsgenieApiKey": json["opsgenie_api_key"] == null ? void 0 : json["opsgenie_api_key"],
    "opsgenieApiKeyFile": json["opsgenie_api_key_file"] == null ? void 0 : json["opsgenie_api_key_file"],
    "opsgenieApiUrl": json["opsgenie_api_url"] == null ? void 0 : URLFromJSON(json["opsgenie_api_url"]),
    "pagerdutyUrl": json["pagerduty_url"] == null ? void 0 : URLFromJSON(json["pagerduty_url"]),
    "resolveTimeout": json["resolve_timeout"] == null ? void 0 : json["resolve_timeout"],
    "slackApiUrl": json["slack_api_url"] == null ? void 0 : URLFromJSON(json["slack_api_url"]),
    "slackApiUrlFile": json["slack_api_url_file"] == null ? void 0 : json["slack_api_url_file"],
    "smtpAuthIdentity": json["smtp_auth_identity"] == null ? void 0 : json["smtp_auth_identity"],
    "smtpAuthPassword": json["smtp_auth_password"] == null ? void 0 : json["smtp_auth_password"],
    "smtpAuthPasswordFile": json["smtp_auth_password_file"] == null ? void 0 : json["smtp_auth_password_file"],
    "smtpAuthSecret": json["smtp_auth_secret"] == null ? void 0 : json["smtp_auth_secret"],
    "smtpAuthUsername": json["smtp_auth_username"] == null ? void 0 : json["smtp_auth_username"],
    "smtpFrom": json["smtp_from"] == null ? void 0 : json["smtp_from"],
    "smtpHello": json["smtp_hello"] == null ? void 0 : json["smtp_hello"],
    "smtpRequireTls": json["smtp_require_tls"] == null ? void 0 : json["smtp_require_tls"],
    "smtpSmarthost": json["smtp_smarthost"] == null ? void 0 : HostPortFromJSON(json["smtp_smarthost"]),
    "telegramApiUrl": json["telegram_api_url"] == null ? void 0 : URLFromJSON(json["telegram_api_url"]),
    "victoropsApiKey": json["victorops_api_key"] == null ? void 0 : json["victorops_api_key"],
    "victoropsApiKeyFile": json["victorops_api_key_file"] == null ? void 0 : json["victorops_api_key_file"],
    "victoropsApiUrl": json["victorops_api_url"] == null ? void 0 : URLFromJSON(json["victorops_api_url"]),
    "webexApiUrl": json["webex_api_url"] == null ? void 0 : URLFromJSON(json["webex_api_url"]),
    "wechatApiCorpId": json["wechat_api_corp_id"] == null ? void 0 : json["wechat_api_corp_id"],
    "wechatApiSecret": json["wechat_api_secret"] == null ? void 0 : json["wechat_api_secret"],
    "wechatApiUrl": json["wechat_api_url"] == null ? void 0 : URLFromJSON(json["wechat_api_url"])
  };
}
function GlobalConfigToJSON(json) {
  return GlobalConfigToJSONTyped(json, false);
}
function GlobalConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "http_config": HTTPClientConfigToJSON(value["httpConfig"]),
    "opsgenie_api_key": value["opsgenieApiKey"],
    "opsgenie_api_key_file": value["opsgenieApiKeyFile"],
    "opsgenie_api_url": URLToJSON(value["opsgenieApiUrl"]),
    "pagerduty_url": URLToJSON(value["pagerdutyUrl"]),
    "resolve_timeout": value["resolveTimeout"],
    "slack_api_url": URLToJSON(value["slackApiUrl"]),
    "slack_api_url_file": value["slackApiUrlFile"],
    "smtp_auth_identity": value["smtpAuthIdentity"],
    "smtp_auth_password": value["smtpAuthPassword"],
    "smtp_auth_password_file": value["smtpAuthPasswordFile"],
    "smtp_auth_secret": value["smtpAuthSecret"],
    "smtp_auth_username": value["smtpAuthUsername"],
    "smtp_from": value["smtpFrom"],
    "smtp_hello": value["smtpHello"],
    "smtp_require_tls": value["smtpRequireTls"],
    "smtp_smarthost": HostPortToJSON(value["smtpSmarthost"]),
    "telegram_api_url": URLToJSON(value["telegramApiUrl"]),
    "victorops_api_key": value["victoropsApiKey"],
    "victorops_api_key_file": value["victoropsApiKeyFile"],
    "victorops_api_url": URLToJSON(value["victoropsApiUrl"]),
    "webex_api_url": URLToJSON(value["webexApiUrl"]),
    "wechat_api_corp_id": value["wechatApiCorpId"],
    "wechat_api_secret": value["wechatApiSecret"],
    "wechat_api_url": URLToJSON(value["wechatApiUrl"])
  };
}

// models/Route.ts
function instanceOfRoute(value) {
  return true;
}
function RouteFromJSON(json) {
  return RouteFromJSONTyped(json);
}
function RouteFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "_continue": json["continue"] == null ? void 0 : json["continue"],
    "groupBy": json["group_by"] == null ? void 0 : json["group_by"],
    "groupInterval": json["group_interval"] == null ? void 0 : json["group_interval"],
    "groupWait": json["group_wait"] == null ? void 0 : json["group_wait"],
    "match": json["match"] == null ? void 0 : json["match"],
    "matchRe": json["match_re"] == null ? void 0 : json["match_re"],
    "matchers": json["matchers"] == null ? void 0 : json["matchers"].map(MatcherFromJSON),
    "muteTimeIntervals": json["mute_time_intervals"] == null ? void 0 : json["mute_time_intervals"],
    "objectMatchers": json["object_matchers"] == null ? void 0 : json["object_matchers"],
    "provenance": json["provenance"] == null ? void 0 : json["provenance"],
    "receiver": json["receiver"] == null ? void 0 : json["receiver"],
    "repeatInterval": json["repeat_interval"] == null ? void 0 : json["repeat_interval"],
    "routes": json["routes"] == null ? void 0 : json["routes"].map(RouteFromJSON)
  };
}
function RouteToJSON(json) {
  return RouteToJSONTyped(json, false);
}
function RouteToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "continue": value["_continue"],
    "group_by": value["groupBy"],
    "group_interval": value["groupInterval"],
    "group_wait": value["groupWait"],
    "match": value["match"],
    "match_re": value["matchRe"],
    "matchers": value["matchers"] == null ? void 0 : value["matchers"].map(MatcherToJSON),
    "mute_time_intervals": value["muteTimeIntervals"],
    "object_matchers": value["objectMatchers"],
    "provenance": value["provenance"],
    "receiver": value["receiver"],
    "repeat_interval": value["repeatInterval"],
    "routes": value["routes"] == null ? void 0 : value["routes"].map(RouteToJSON)
  };
}

// models/Config.ts
function instanceOfConfig(value) {
  return true;
}
function ConfigFromJSON(json) {
  return ConfigFromJSONTyped(json);
}
function ConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "global": json["global"] == null ? void 0 : GlobalConfigFromJSON(json["global"]),
    "inhibitRules": json["inhibit_rules"] == null ? void 0 : json["inhibit_rules"].map(InhibitRuleFromJSON),
    "muteTimeIntervals": json["mute_time_intervals"] == null ? void 0 : json["mute_time_intervals"].map(MuteTimeIntervalFromJSON),
    "route": json["route"] == null ? void 0 : RouteFromJSON(json["route"]),
    "templates": json["templates"] == null ? void 0 : json["templates"],
    "timeIntervals": json["time_intervals"] == null ? void 0 : json["time_intervals"].map(TimeIntervalFromJSON)
  };
}
function ConfigToJSON(json) {
  return ConfigToJSONTyped(json, false);
}
function ConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "global": GlobalConfigToJSON(value["global"]),
    "inhibit_rules": value["inhibitRules"] == null ? void 0 : value["inhibitRules"].map(InhibitRuleToJSON),
    "mute_time_intervals": value["muteTimeIntervals"] == null ? void 0 : value["muteTimeIntervals"].map(MuteTimeIntervalToJSON),
    "route": RouteToJSON(value["route"]),
    "templates": value["templates"],
    "time_intervals": value["timeIntervals"] == null ? void 0 : value["timeIntervals"].map(TimeIntervalToJSON)
  };
}

// models/CookiePreferences.ts
function instanceOfCookiePreferences(value) {
  return true;
}
function CookiePreferencesFromJSON(json) {
  return CookiePreferencesFromJSONTyped(json);
}
function CookiePreferencesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "analytics": json["analytics"] == null ? void 0 : json["analytics"],
    "functional": json["functional"] == null ? void 0 : json["functional"],
    "performance": json["performance"] == null ? void 0 : json["performance"]
  };
}
function CookiePreferencesToJSON(json) {
  return CookiePreferencesToJSONTyped(json, false);
}
function CookiePreferencesToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "analytics": value["analytics"],
    "functional": value["functional"],
    "performance": value["performance"]
  };
}

// models/Transformation.ts
var TransformationTypeEnum = {
  Regex: "regex",
  Logfmt: "logfmt"
};
function instanceOfTransformation(value) {
  return true;
}
function TransformationFromJSON(json) {
  return TransformationFromJSONTyped(json);
}
function TransformationFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "expression": json["expression"] == null ? void 0 : json["expression"],
    "field": json["field"] == null ? void 0 : json["field"],
    "mapValue": json["mapValue"] == null ? void 0 : json["mapValue"],
    "type": json["type"] == null ? void 0 : json["type"]
  };
}
function TransformationToJSON(json) {
  return TransformationToJSONTyped(json, false);
}
function TransformationToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "expression": value["expression"],
    "field": value["field"],
    "mapValue": value["mapValue"],
    "type": value["type"]
  };
}

// models/CorrelationConfig.ts
function instanceOfCorrelationConfig(value) {
  if (!("field" in value) || value["field"] === void 0) return false;
  if (!("target" in value) || value["target"] === void 0) return false;
  if (!("type" in value) || value["type"] === void 0) return false;
  return true;
}
function CorrelationConfigFromJSON(json) {
  return CorrelationConfigFromJSONTyped(json);
}
function CorrelationConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "field": json["field"],
    "target": json["target"],
    "transformations": json["transformations"] == null ? void 0 : json["transformations"].map(TransformationFromJSON),
    "type": json["type"]
  };
}
function CorrelationConfigToJSON(json) {
  return CorrelationConfigToJSONTyped(json, false);
}
function CorrelationConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "field": value["field"],
    "target": value["target"],
    "transformations": value["transformations"] == null ? void 0 : value["transformations"].map(TransformationToJSON),
    "type": value["type"]
  };
}

// models/Correlation.ts
function instanceOfCorrelation(value) {
  return true;
}
function CorrelationFromJSON(json) {
  return CorrelationFromJSONTyped(json);
}
function CorrelationFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "config": json["config"] == null ? void 0 : CorrelationConfigFromJSON(json["config"]),
    "description": json["description"] == null ? void 0 : json["description"],
    "label": json["label"] == null ? void 0 : json["label"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "provisioned": json["provisioned"] == null ? void 0 : json["provisioned"],
    "sourceUID": json["sourceUID"] == null ? void 0 : json["sourceUID"],
    "targetUID": json["targetUID"] == null ? void 0 : json["targetUID"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function CorrelationToJSON(json) {
  return CorrelationToJSONTyped(json, false);
}
function CorrelationToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "config": CorrelationConfigToJSON(value["config"]),
    "description": value["description"],
    "label": value["label"],
    "orgId": value["orgId"],
    "provisioned": value["provisioned"],
    "sourceUID": value["sourceUID"],
    "targetUID": value["targetUID"],
    "uid": value["uid"]
  };
}

// models/CorrelationConfigUpdateDTO.ts
function instanceOfCorrelationConfigUpdateDTO(value) {
  return true;
}
function CorrelationConfigUpdateDTOFromJSON(json) {
  return CorrelationConfigUpdateDTOFromJSONTyped(json);
}
function CorrelationConfigUpdateDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "field": json["field"] == null ? void 0 : json["field"],
    "target": json["target"] == null ? void 0 : json["target"],
    "transformations": json["transformations"] == null ? void 0 : json["transformations"].map(TransformationFromJSON),
    "type": json["type"] == null ? void 0 : json["type"]
  };
}
function CorrelationConfigUpdateDTOToJSON(json) {
  return CorrelationConfigUpdateDTOToJSONTyped(json, false);
}
function CorrelationConfigUpdateDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "field": value["field"],
    "target": value["target"],
    "transformations": value["transformations"] == null ? void 0 : value["transformations"].map(TransformationToJSON),
    "type": value["type"]
  };
}

// models/CreateCorrelationCommand.ts
function instanceOfCreateCorrelationCommand(value) {
  return true;
}
function CreateCorrelationCommandFromJSON(json) {
  return CreateCorrelationCommandFromJSONTyped(json);
}
function CreateCorrelationCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "config": json["config"] == null ? void 0 : CorrelationConfigFromJSON(json["config"]),
    "description": json["description"] == null ? void 0 : json["description"],
    "label": json["label"] == null ? void 0 : json["label"],
    "provisioned": json["provisioned"] == null ? void 0 : json["provisioned"],
    "targetUID": json["targetUID"] == null ? void 0 : json["targetUID"]
  };
}
function CreateCorrelationCommandToJSON(json) {
  return CreateCorrelationCommandToJSONTyped(json, false);
}
function CreateCorrelationCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "config": CorrelationConfigToJSON(value["config"]),
    "description": value["description"],
    "label": value["label"],
    "provisioned": value["provisioned"],
    "targetUID": value["targetUID"]
  };
}

// models/CreateCorrelationResponseBody.ts
function instanceOfCreateCorrelationResponseBody(value) {
  return true;
}
function CreateCorrelationResponseBodyFromJSON(json) {
  return CreateCorrelationResponseBodyFromJSONTyped(json);
}
function CreateCorrelationResponseBodyFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "message": json["message"] == null ? void 0 : json["message"],
    "result": json["result"] == null ? void 0 : CorrelationFromJSON(json["result"])
  };
}
function CreateCorrelationResponseBodyToJSON(json) {
  return CreateCorrelationResponseBodyToJSONTyped(json, false);
}
function CreateCorrelationResponseBodyToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "message": value["message"],
    "result": CorrelationToJSON(value["result"])
  };
}

// models/CreateDashboardSnapshot200Response.ts
function instanceOfCreateDashboardSnapshot200Response(value) {
  return true;
}
function CreateDashboardSnapshot200ResponseFromJSON(json) {
  return CreateDashboardSnapshot200ResponseFromJSONTyped(json);
}
function CreateDashboardSnapshot200ResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "deleteKey": json["deleteKey"] == null ? void 0 : json["deleteKey"],
    "deleteUrl": json["deleteUrl"] == null ? void 0 : json["deleteUrl"],
    "id": json["id"] == null ? void 0 : json["id"],
    "key": json["key"] == null ? void 0 : json["key"],
    "url": json["url"] == null ? void 0 : json["url"]
  };
}
function CreateDashboardSnapshot200ResponseToJSON(json) {
  return CreateDashboardSnapshot200ResponseToJSONTyped(json, false);
}
function CreateDashboardSnapshot200ResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "deleteKey": value["deleteKey"],
    "deleteUrl": value["deleteUrl"],
    "id": value["id"],
    "key": value["key"],
    "url": value["url"]
  };
}

// models/Unstructured.ts
function instanceOfUnstructured(value) {
  return true;
}
function UnstructuredFromJSON(json) {
  return UnstructuredFromJSONTyped(json);
}
function UnstructuredFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "object": json["Object"] == null ? void 0 : json["Object"]
  };
}
function UnstructuredToJSON(json) {
  return UnstructuredToJSONTyped(json, false);
}
function UnstructuredToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "Object": value["object"]
  };
}

// models/CreateDashboardSnapshotCommand.ts
function instanceOfCreateDashboardSnapshotCommand(value) {
  if (!("dashboard" in value) || value["dashboard"] === void 0) return false;
  return true;
}
function CreateDashboardSnapshotCommandFromJSON(json) {
  return CreateDashboardSnapshotCommandFromJSONTyped(json);
}
function CreateDashboardSnapshotCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "apiVersion": json["apiVersion"] == null ? void 0 : json["apiVersion"],
    "dashboard": UnstructuredFromJSON(json["dashboard"]),
    "deleteKey": json["deleteKey"] == null ? void 0 : json["deleteKey"],
    "expires": json["expires"] == null ? void 0 : json["expires"],
    "external": json["external"] == null ? void 0 : json["external"],
    "key": json["key"] == null ? void 0 : json["key"],
    "kind": json["kind"] == null ? void 0 : json["kind"],
    "name": json["name"] == null ? void 0 : json["name"]
  };
}
function CreateDashboardSnapshotCommandToJSON(json) {
  return CreateDashboardSnapshotCommandToJSONTyped(json, false);
}
function CreateDashboardSnapshotCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "apiVersion": value["apiVersion"],
    "dashboard": UnstructuredToJSON(value["dashboard"]),
    "deleteKey": value["deleteKey"],
    "expires": value["expires"],
    "external": value["external"],
    "key": value["key"],
    "kind": value["kind"],
    "name": value["name"]
  };
}

// models/CreateFolderCommand.ts
function instanceOfCreateFolderCommand(value) {
  return true;
}
function CreateFolderCommandFromJSON(json) {
  return CreateFolderCommandFromJSONTyped(json);
}
function CreateFolderCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "description": json["description"] == null ? void 0 : json["description"],
    "parentUid": json["parentUid"] == null ? void 0 : json["parentUid"],
    "title": json["title"] == null ? void 0 : json["title"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function CreateFolderCommandToJSON(json) {
  return CreateFolderCommandToJSONTyped(json, false);
}
function CreateFolderCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "description": value["description"],
    "parentUid": value["parentUid"],
    "title": value["title"],
    "uid": value["uid"]
  };
}

// models/CreateLibraryElementCommand.ts
var CreateLibraryElementCommandKindEnum = {
  NUMBER_1: 1,
  NUMBER_2: 2
};
function instanceOfCreateLibraryElementCommand(value) {
  return true;
}
function CreateLibraryElementCommandFromJSON(json) {
  return CreateLibraryElementCommandFromJSONTyped(json);
}
function CreateLibraryElementCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "folderId": json["folderId"] == null ? void 0 : json["folderId"],
    "folderUid": json["folderUid"] == null ? void 0 : json["folderUid"],
    "kind": json["kind"] == null ? void 0 : json["kind"],
    "model": json["model"] == null ? void 0 : json["model"],
    "name": json["name"] == null ? void 0 : json["name"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function CreateLibraryElementCommandToJSON(json) {
  return CreateLibraryElementCommandToJSONTyped(json, false);
}
function CreateLibraryElementCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "folderId": value["folderId"],
    "folderUid": value["folderUid"],
    "kind": value["kind"],
    "model": value["model"],
    "name": value["name"],
    "uid": value["uid"]
  };
}

// models/ReportDashboardID.ts
function instanceOfReportDashboardID(value) {
  return true;
}
function ReportDashboardIDFromJSON(json) {
  return ReportDashboardIDFromJSONTyped(json);
}
function ReportDashboardIDFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"] == null ? void 0 : json["id"],
    "name": json["name"] == null ? void 0 : json["name"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function ReportDashboardIDToJSON(json) {
  return ReportDashboardIDToJSONTyped(json, false);
}
function ReportDashboardIDToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "name": value["name"],
    "uid": value["uid"]
  };
}

// models/ReportTimeRange.ts
function instanceOfReportTimeRange(value) {
  return true;
}
function ReportTimeRangeFromJSON(json) {
  return ReportTimeRangeFromJSONTyped(json);
}
function ReportTimeRangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "from": json["from"] == null ? void 0 : json["from"],
    "to": json["to"] == null ? void 0 : json["to"]
  };
}
function ReportTimeRangeToJSON(json) {
  return ReportTimeRangeToJSONTyped(json, false);
}
function ReportTimeRangeToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "from": value["from"],
    "to": value["to"]
  };
}

// models/ReportDashboard.ts
function instanceOfReportDashboard(value) {
  return true;
}
function ReportDashboardFromJSON(json) {
  return ReportDashboardFromJSONTyped(json);
}
function ReportDashboardFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "dashboard": json["dashboard"] == null ? void 0 : ReportDashboardIDFromJSON(json["dashboard"]),
    "reportVariables": json["reportVariables"] == null ? void 0 : json["reportVariables"],
    "timeRange": json["timeRange"] == null ? void 0 : ReportTimeRangeFromJSON(json["timeRange"])
  };
}
function ReportDashboardToJSON(json) {
  return ReportDashboardToJSONTyped(json, false);
}
function ReportDashboardToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "dashboard": ReportDashboardIDToJSON(value["dashboard"]),
    "reportVariables": value["reportVariables"],
    "timeRange": ReportTimeRangeToJSON(value["timeRange"])
  };
}

// models/ReportSchedule.ts
function instanceOfReportSchedule(value) {
  return true;
}
function ReportScheduleFromJSON(json) {
  return ReportScheduleFromJSONTyped(json);
}
function ReportScheduleFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "dayOfMonth": json["dayOfMonth"] == null ? void 0 : json["dayOfMonth"],
    "endDate": json["endDate"] == null ? void 0 : new Date(json["endDate"]),
    "frequency": json["frequency"] == null ? void 0 : json["frequency"],
    "intervalAmount": json["intervalAmount"] == null ? void 0 : json["intervalAmount"],
    "intervalFrequency": json["intervalFrequency"] == null ? void 0 : json["intervalFrequency"],
    "startDate": json["startDate"] == null ? void 0 : new Date(json["startDate"]),
    "timeZone": json["timeZone"] == null ? void 0 : json["timeZone"],
    "workdaysOnly": json["workdaysOnly"] == null ? void 0 : json["workdaysOnly"]
  };
}
function ReportScheduleToJSON(json) {
  return ReportScheduleToJSONTyped(json, false);
}
function ReportScheduleToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "dayOfMonth": value["dayOfMonth"],
    "endDate": value["endDate"] == null ? void 0 : value["endDate"].toISOString(),
    "frequency": value["frequency"],
    "intervalAmount": value["intervalAmount"],
    "intervalFrequency": value["intervalFrequency"],
    "startDate": value["startDate"] == null ? void 0 : value["startDate"].toISOString(),
    "timeZone": value["timeZone"],
    "workdaysOnly": value["workdaysOnly"]
  };
}

// models/ReportOptions.ts
function instanceOfReportOptions(value) {
  return true;
}
function ReportOptionsFromJSON(json) {
  return ReportOptionsFromJSONTyped(json);
}
function ReportOptionsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "layout": json["layout"] == null ? void 0 : json["layout"],
    "orientation": json["orientation"] == null ? void 0 : json["orientation"],
    "timeRange": json["timeRange"] == null ? void 0 : ReportTimeRangeFromJSON(json["timeRange"])
  };
}
function ReportOptionsToJSON(json) {
  return ReportOptionsToJSONTyped(json, false);
}
function ReportOptionsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "layout": value["layout"],
    "orientation": value["orientation"],
    "timeRange": ReportTimeRangeToJSON(value["timeRange"])
  };
}

// models/CreateOrUpdateReportConfig.ts
function instanceOfCreateOrUpdateReportConfig(value) {
  return true;
}
function CreateOrUpdateReportConfigFromJSON(json) {
  return CreateOrUpdateReportConfigFromJSONTyped(json);
}
function CreateOrUpdateReportConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "dashboards": json["dashboards"] == null ? void 0 : json["dashboards"].map(ReportDashboardFromJSON),
    "enableCsv": json["enableCsv"] == null ? void 0 : json["enableCsv"],
    "enableDashboardUrl": json["enableDashboardUrl"] == null ? void 0 : json["enableDashboardUrl"],
    "formats": json["formats"] == null ? void 0 : json["formats"],
    "message": json["message"] == null ? void 0 : json["message"],
    "name": json["name"] == null ? void 0 : json["name"],
    "options": json["options"] == null ? void 0 : ReportOptionsFromJSON(json["options"]),
    "recipients": json["recipients"] == null ? void 0 : json["recipients"],
    "replyTo": json["replyTo"] == null ? void 0 : json["replyTo"],
    "scaleFactor": json["scaleFactor"] == null ? void 0 : json["scaleFactor"],
    "schedule": json["schedule"] == null ? void 0 : ReportScheduleFromJSON(json["schedule"]),
    "state": json["state"] == null ? void 0 : json["state"]
  };
}
function CreateOrUpdateReportConfigToJSON(json) {
  return CreateOrUpdateReportConfigToJSONTyped(json, false);
}
function CreateOrUpdateReportConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "dashboards": value["dashboards"] == null ? void 0 : value["dashboards"].map(ReportDashboardToJSON),
    "enableCsv": value["enableCsv"],
    "enableDashboardUrl": value["enableDashboardUrl"],
    "formats": value["formats"],
    "message": value["message"],
    "name": value["name"],
    "options": ReportOptionsToJSON(value["options"]),
    "recipients": value["recipients"],
    "replyTo": value["replyTo"],
    "scaleFactor": value["scaleFactor"],
    "schedule": ReportScheduleToJSON(value["schedule"]),
    "state": value["state"]
  };
}

// models/CreateOrg200Response.ts
function instanceOfCreateOrg200Response(value) {
  if (!("message" in value) || value["message"] === void 0) return false;
  if (!("orgId" in value) || value["orgId"] === void 0) return false;
  return true;
}
function CreateOrg200ResponseFromJSON(json) {
  return CreateOrg200ResponseFromJSONTyped(json);
}
function CreateOrg200ResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "message": json["message"],
    "orgId": json["orgId"]
  };
}
function CreateOrg200ResponseToJSON(json) {
  return CreateOrg200ResponseToJSONTyped(json, false);
}
function CreateOrg200ResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "message": value["message"],
    "orgId": value["orgId"]
  };
}

// models/CreateOrgCommand.ts
function instanceOfCreateOrgCommand(value) {
  return true;
}
function CreateOrgCommandFromJSON(json) {
  return CreateOrgCommandFromJSONTyped(json);
}
function CreateOrgCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"]
  };
}
function CreateOrgCommandToJSON(json) {
  return CreateOrgCommandToJSONTyped(json, false);
}
function CreateOrgCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"]
  };
}

// models/PlaylistItem.ts
function instanceOfPlaylistItem(value) {
  return true;
}
function PlaylistItemFromJSON(json) {
  return PlaylistItemFromJSONTyped(json);
}
function PlaylistItemFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["Id"] == null ? void 0 : json["Id"],
    "playlistId": json["PlaylistId"] == null ? void 0 : json["PlaylistId"],
    "order": json["order"] == null ? void 0 : json["order"],
    "title": json["title"] == null ? void 0 : json["title"],
    "type": json["type"] == null ? void 0 : json["type"],
    "value": json["value"] == null ? void 0 : json["value"]
  };
}
function PlaylistItemToJSON(json) {
  return PlaylistItemToJSONTyped(json, false);
}
function PlaylistItemToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "Id": value["id"],
    "PlaylistId": value["playlistId"],
    "order": value["order"],
    "title": value["title"],
    "type": value["type"],
    "value": value["value"]
  };
}

// models/CreatePlaylistCommand.ts
function instanceOfCreatePlaylistCommand(value) {
  return true;
}
function CreatePlaylistCommandFromJSON(json) {
  return CreatePlaylistCommandFromJSONTyped(json);
}
function CreatePlaylistCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "interval": json["interval"] == null ? void 0 : json["interval"],
    "items": json["items"] == null ? void 0 : json["items"].map(PlaylistItemFromJSON),
    "name": json["name"] == null ? void 0 : json["name"]
  };
}
function CreatePlaylistCommandToJSON(json) {
  return CreatePlaylistCommandToJSONTyped(json, false);
}
function CreatePlaylistCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "interval": value["interval"],
    "items": value["items"] == null ? void 0 : value["items"].map(PlaylistItemToJSON),
    "name": value["name"]
  };
}

// models/CreateQueryInQueryHistoryCommand.ts
function instanceOfCreateQueryInQueryHistoryCommand(value) {
  if (!("queries" in value) || value["queries"] === void 0) return false;
  return true;
}
function CreateQueryInQueryHistoryCommandFromJSON(json) {
  return CreateQueryInQueryHistoryCommandFromJSONTyped(json);
}
function CreateQueryInQueryHistoryCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "datasourceUid": json["datasourceUid"] == null ? void 0 : json["datasourceUid"],
    "queries": json["queries"]
  };
}
function CreateQueryInQueryHistoryCommandToJSON(json) {
  return CreateQueryInQueryHistoryCommandToJSONTyped(json, false);
}
function CreateQueryInQueryHistoryCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "datasourceUid": value["datasourceUid"],
    "queries": value["queries"]
  };
}

// models/CreateReport200Response.ts
function instanceOfCreateReport200Response(value) {
  return true;
}
function CreateReport200ResponseFromJSON(json) {
  return CreateReport200ResponseFromJSONTyped(json);
}
function CreateReport200ResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"] == null ? void 0 : json["id"],
    "message": json["message"] == null ? void 0 : json["message"]
  };
}
function CreateReport200ResponseToJSON(json) {
  return CreateReport200ResponseToJSONTyped(json, false);
}
function CreateReport200ResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "message": value["message"]
  };
}

// models/Permission.ts
function instanceOfPermission(value) {
  return true;
}
function PermissionFromJSON(json) {
  return PermissionFromJSONTyped(json);
}
function PermissionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "action": json["action"] == null ? void 0 : json["action"],
    "created": json["created"] == null ? void 0 : new Date(json["created"]),
    "scope": json["scope"] == null ? void 0 : json["scope"],
    "updated": json["updated"] == null ? void 0 : new Date(json["updated"])
  };
}
function PermissionToJSON(json) {
  return PermissionToJSONTyped(json, false);
}
function PermissionToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "action": value["action"],
    "created": value["created"] == null ? void 0 : value["created"].toISOString(),
    "scope": value["scope"],
    "updated": value["updated"] == null ? void 0 : value["updated"].toISOString()
  };
}

// models/CreateRoleForm.ts
function instanceOfCreateRoleForm(value) {
  return true;
}
function CreateRoleFormFromJSON(json) {
  return CreateRoleFormFromJSONTyped(json);
}
function CreateRoleFormFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "description": json["description"] == null ? void 0 : json["description"],
    "displayName": json["displayName"] == null ? void 0 : json["displayName"],
    "global": json["global"] == null ? void 0 : json["global"],
    "group": json["group"] == null ? void 0 : json["group"],
    "hidden": json["hidden"] == null ? void 0 : json["hidden"],
    "name": json["name"] == null ? void 0 : json["name"],
    "permissions": json["permissions"] == null ? void 0 : json["permissions"].map(PermissionFromJSON),
    "uid": json["uid"] == null ? void 0 : json["uid"],
    "version": json["version"] == null ? void 0 : json["version"]
  };
}
function CreateRoleFormToJSON(json) {
  return CreateRoleFormToJSONTyped(json, false);
}
function CreateRoleFormToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "description": value["description"],
    "displayName": value["displayName"],
    "global": value["global"],
    "group": value["group"],
    "hidden": value["hidden"],
    "name": value["name"],
    "permissions": value["permissions"] == null ? void 0 : value["permissions"].map(PermissionToJSON),
    "uid": value["uid"],
    "version": value["version"]
  };
}

// models/CreateServiceAccountForm.ts
var CreateServiceAccountFormRoleEnum = {
  None: "None",
  Viewer: "Viewer",
  Editor: "Editor",
  Admin: "Admin"
};
function instanceOfCreateServiceAccountForm(value) {
  return true;
}
function CreateServiceAccountFormFromJSON(json) {
  return CreateServiceAccountFormFromJSONTyped(json);
}
function CreateServiceAccountFormFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "isDisabled": json["isDisabled"] == null ? void 0 : json["isDisabled"],
    "name": json["name"] == null ? void 0 : json["name"],
    "role": json["role"] == null ? void 0 : json["role"]
  };
}
function CreateServiceAccountFormToJSON(json) {
  return CreateServiceAccountFormToJSONTyped(json, false);
}
function CreateServiceAccountFormToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "isDisabled": value["isDisabled"],
    "name": value["name"],
    "role": value["role"]
  };
}

// models/CreateTeam200Response.ts
function instanceOfCreateTeam200Response(value) {
  return true;
}
function CreateTeam200ResponseFromJSON(json) {
  return CreateTeam200ResponseFromJSONTyped(json);
}
function CreateTeam200ResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "message": json["message"] == null ? void 0 : json["message"],
    "teamId": json["teamId"] == null ? void 0 : json["teamId"]
  };
}
function CreateTeam200ResponseToJSON(json) {
  return CreateTeam200ResponseToJSONTyped(json, false);
}
function CreateTeam200ResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "message": value["message"],
    "teamId": value["teamId"]
  };
}

// models/CreateTeamCommand.ts
function instanceOfCreateTeamCommand(value) {
  return true;
}
function CreateTeamCommandFromJSON(json) {
  return CreateTeamCommandFromJSONTyped(json);
}
function CreateTeamCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "email": json["email"] == null ? void 0 : json["email"],
    "name": json["name"] == null ? void 0 : json["name"]
  };
}
function CreateTeamCommandToJSON(json) {
  return CreateTeamCommandToJSONTyped(json, false);
}
function CreateTeamCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "email": value["email"],
    "name": value["name"]
  };
}

// models/DashboardACLInfoDTO.ts
var DashboardACLInfoDTORoleEnum = {
  None: "None",
  Viewer: "Viewer",
  Editor: "Editor",
  Admin: "Admin"
};
function instanceOfDashboardACLInfoDTO(value) {
  return true;
}
function DashboardACLInfoDTOFromJSON(json) {
  return DashboardACLInfoDTOFromJSONTyped(json);
}
function DashboardACLInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "created": json["created"] == null ? void 0 : new Date(json["created"]),
    "dashboardId": json["dashboardId"] == null ? void 0 : json["dashboardId"],
    "folderId": json["folderId"] == null ? void 0 : json["folderId"],
    "folderUid": json["folderUid"] == null ? void 0 : json["folderUid"],
    "inherited": json["inherited"] == null ? void 0 : json["inherited"],
    "isFolder": json["isFolder"] == null ? void 0 : json["isFolder"],
    "permission": json["permission"] == null ? void 0 : json["permission"],
    "permissionName": json["permissionName"] == null ? void 0 : json["permissionName"],
    "role": json["role"] == null ? void 0 : json["role"],
    "slug": json["slug"] == null ? void 0 : json["slug"],
    "team": json["team"] == null ? void 0 : json["team"],
    "teamAvatarUrl": json["teamAvatarUrl"] == null ? void 0 : json["teamAvatarUrl"],
    "teamEmail": json["teamEmail"] == null ? void 0 : json["teamEmail"],
    "teamId": json["teamId"] == null ? void 0 : json["teamId"],
    "title": json["title"] == null ? void 0 : json["title"],
    "uid": json["uid"] == null ? void 0 : json["uid"],
    "updated": json["updated"] == null ? void 0 : new Date(json["updated"]),
    "url": json["url"] == null ? void 0 : json["url"],
    "userAvatarUrl": json["userAvatarUrl"] == null ? void 0 : json["userAvatarUrl"],
    "userEmail": json["userEmail"] == null ? void 0 : json["userEmail"],
    "userId": json["userId"] == null ? void 0 : json["userId"],
    "userLogin": json["userLogin"] == null ? void 0 : json["userLogin"]
  };
}
function DashboardACLInfoDTOToJSON(json) {
  return DashboardACLInfoDTOToJSONTyped(json, false);
}
function DashboardACLInfoDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "created": value["created"] == null ? void 0 : value["created"].toISOString(),
    "dashboardId": value["dashboardId"],
    "folderId": value["folderId"],
    "folderUid": value["folderUid"],
    "inherited": value["inherited"],
    "isFolder": value["isFolder"],
    "permission": value["permission"],
    "permissionName": value["permissionName"],
    "role": value["role"],
    "slug": value["slug"],
    "team": value["team"],
    "teamAvatarUrl": value["teamAvatarUrl"],
    "teamEmail": value["teamEmail"],
    "teamId": value["teamId"],
    "title": value["title"],
    "uid": value["uid"],
    "updated": value["updated"] == null ? void 0 : value["updated"].toISOString(),
    "url": value["url"],
    "userAvatarUrl": value["userAvatarUrl"],
    "userEmail": value["userEmail"],
    "userId": value["userId"],
    "userLogin": value["userLogin"]
  };
}

// models/DashboardACLUpdateItem.ts
var DashboardACLUpdateItemRoleEnum = {
  None: "None",
  Viewer: "Viewer",
  Editor: "Editor",
  Admin: "Admin"
};
function instanceOfDashboardACLUpdateItem(value) {
  return true;
}
function DashboardACLUpdateItemFromJSON(json) {
  return DashboardACLUpdateItemFromJSONTyped(json);
}
function DashboardACLUpdateItemFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "permission": json["permission"] == null ? void 0 : json["permission"],
    "role": json["role"] == null ? void 0 : json["role"],
    "teamId": json["teamId"] == null ? void 0 : json["teamId"],
    "userId": json["userId"] == null ? void 0 : json["userId"]
  };
}
function DashboardACLUpdateItemToJSON(json) {
  return DashboardACLUpdateItemToJSONTyped(json, false);
}
function DashboardACLUpdateItemToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "permission": value["permission"],
    "role": value["role"],
    "teamId": value["teamId"],
    "userId": value["userId"]
  };
}

// models/DashboardCreateCommand.ts
function instanceOfDashboardCreateCommand(value) {
  if (!("dashboard" in value) || value["dashboard"] === void 0) return false;
  return true;
}
function DashboardCreateCommandFromJSON(json) {
  return DashboardCreateCommandFromJSONTyped(json);
}
function DashboardCreateCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "apiVersion": json["apiVersion"] == null ? void 0 : json["apiVersion"],
    "dashboard": UnstructuredFromJSON(json["dashboard"]),
    "expires": json["expires"] == null ? void 0 : json["expires"],
    "external": json["external"] == null ? void 0 : json["external"],
    "kind": json["kind"] == null ? void 0 : json["kind"],
    "name": json["name"] == null ? void 0 : json["name"]
  };
}
function DashboardCreateCommandToJSON(json) {
  return DashboardCreateCommandToJSONTyped(json, false);
}
function DashboardCreateCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "apiVersion": value["apiVersion"],
    "dashboard": UnstructuredToJSON(value["dashboard"]),
    "expires": value["expires"],
    "external": value["external"],
    "kind": value["kind"],
    "name": value["name"]
  };
}

// models/DashboardMeta.ts
function instanceOfDashboardMeta(value) {
  return true;
}
function DashboardMetaFromJSON(json) {
  return DashboardMetaFromJSONTyped(json);
}
function DashboardMetaFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "annotationsPermissions": json["annotationsPermissions"] == null ? void 0 : AnnotationPermissionFromJSON(json["annotationsPermissions"]),
    "canAdmin": json["canAdmin"] == null ? void 0 : json["canAdmin"],
    "canDelete": json["canDelete"] == null ? void 0 : json["canDelete"],
    "canEdit": json["canEdit"] == null ? void 0 : json["canEdit"],
    "canSave": json["canSave"] == null ? void 0 : json["canSave"],
    "canStar": json["canStar"] == null ? void 0 : json["canStar"],
    "created": json["created"] == null ? void 0 : new Date(json["created"]),
    "createdBy": json["createdBy"] == null ? void 0 : json["createdBy"],
    "expires": json["expires"] == null ? void 0 : new Date(json["expires"]),
    "folderId": json["folderId"] == null ? void 0 : json["folderId"],
    "folderTitle": json["folderTitle"] == null ? void 0 : json["folderTitle"],
    "folderUid": json["folderUid"] == null ? void 0 : json["folderUid"],
    "folderUrl": json["folderUrl"] == null ? void 0 : json["folderUrl"],
    "hasAcl": json["hasAcl"] == null ? void 0 : json["hasAcl"],
    "isFolder": json["isFolder"] == null ? void 0 : json["isFolder"],
    "isSnapshot": json["isSnapshot"] == null ? void 0 : json["isSnapshot"],
    "isStarred": json["isStarred"] == null ? void 0 : json["isStarred"],
    "provisioned": json["provisioned"] == null ? void 0 : json["provisioned"],
    "provisionedExternalId": json["provisionedExternalId"] == null ? void 0 : json["provisionedExternalId"],
    "publicDashboardEnabled": json["publicDashboardEnabled"] == null ? void 0 : json["publicDashboardEnabled"],
    "publicDashboardUid": json["publicDashboardUid"] == null ? void 0 : json["publicDashboardUid"],
    "slug": json["slug"] == null ? void 0 : json["slug"],
    "type": json["type"] == null ? void 0 : json["type"],
    "updated": json["updated"] == null ? void 0 : new Date(json["updated"]),
    "updatedBy": json["updatedBy"] == null ? void 0 : json["updatedBy"],
    "url": json["url"] == null ? void 0 : json["url"],
    "version": json["version"] == null ? void 0 : json["version"]
  };
}
function DashboardMetaToJSON(json) {
  return DashboardMetaToJSONTyped(json, false);
}
function DashboardMetaToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "annotationsPermissions": AnnotationPermissionToJSON(value["annotationsPermissions"]),
    "canAdmin": value["canAdmin"],
    "canDelete": value["canDelete"],
    "canEdit": value["canEdit"],
    "canSave": value["canSave"],
    "canStar": value["canStar"],
    "created": value["created"] == null ? void 0 : value["created"].toISOString(),
    "createdBy": value["createdBy"],
    "expires": value["expires"] == null ? void 0 : value["expires"].toISOString(),
    "folderId": value["folderId"],
    "folderTitle": value["folderTitle"],
    "folderUid": value["folderUid"],
    "folderUrl": value["folderUrl"],
    "hasAcl": value["hasAcl"],
    "isFolder": value["isFolder"],
    "isSnapshot": value["isSnapshot"],
    "isStarred": value["isStarred"],
    "provisioned": value["provisioned"],
    "provisionedExternalId": value["provisionedExternalId"],
    "publicDashboardEnabled": value["publicDashboardEnabled"],
    "publicDashboardUid": value["publicDashboardUid"],
    "slug": value["slug"],
    "type": value["type"],
    "updated": value["updated"] == null ? void 0 : value["updated"].toISOString(),
    "updatedBy": value["updatedBy"],
    "url": value["url"],
    "version": value["version"]
  };
}

// models/DashboardFullWithMeta.ts
function instanceOfDashboardFullWithMeta(value) {
  return true;
}
function DashboardFullWithMetaFromJSON(json) {
  return DashboardFullWithMetaFromJSONTyped(json);
}
function DashboardFullWithMetaFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "dashboard": json["dashboard"] == null ? void 0 : json["dashboard"],
    "meta": json["meta"] == null ? void 0 : DashboardMetaFromJSON(json["meta"])
  };
}
function DashboardFullWithMetaToJSON(json) {
  return DashboardFullWithMetaToJSONTyped(json, false);
}
function DashboardFullWithMetaToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "dashboard": value["dashboard"],
    "meta": DashboardMetaToJSON(value["meta"])
  };
}

// models/DashboardRedirect.ts
function instanceOfDashboardRedirect(value) {
  return true;
}
function DashboardRedirectFromJSON(json) {
  return DashboardRedirectFromJSONTyped(json);
}
function DashboardRedirectFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "redirectUri": json["redirectUri"] == null ? void 0 : json["redirectUri"]
  };
}
function DashboardRedirectToJSON(json) {
  return DashboardRedirectToJSONTyped(json, false);
}
function DashboardRedirectToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "redirectUri": value["redirectUri"]
  };
}

// models/DashboardSnapshotDTO.ts
function instanceOfDashboardSnapshotDTO(value) {
  return true;
}
function DashboardSnapshotDTOFromJSON(json) {
  return DashboardSnapshotDTOFromJSONTyped(json);
}
function DashboardSnapshotDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "created": json["created"] == null ? void 0 : new Date(json["created"]),
    "expires": json["expires"] == null ? void 0 : new Date(json["expires"]),
    "external": json["external"] == null ? void 0 : json["external"],
    "externalUrl": json["externalUrl"] == null ? void 0 : json["externalUrl"],
    "key": json["key"] == null ? void 0 : json["key"],
    "name": json["name"] == null ? void 0 : json["name"],
    "updated": json["updated"] == null ? void 0 : new Date(json["updated"])
  };
}
function DashboardSnapshotDTOToJSON(json) {
  return DashboardSnapshotDTOToJSONTyped(json, false);
}
function DashboardSnapshotDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "created": value["created"] == null ? void 0 : value["created"].toISOString(),
    "expires": value["expires"] == null ? void 0 : value["expires"].toISOString(),
    "external": value["external"],
    "externalUrl": value["externalUrl"],
    "key": value["key"],
    "name": value["name"],
    "updated": value["updated"] == null ? void 0 : value["updated"].toISOString()
  };
}

// models/DashboardTagCloudItem.ts
function instanceOfDashboardTagCloudItem(value) {
  return true;
}
function DashboardTagCloudItemFromJSON(json) {
  return DashboardTagCloudItemFromJSONTyped(json);
}
function DashboardTagCloudItemFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "count": json["count"] == null ? void 0 : json["count"],
    "term": json["term"] == null ? void 0 : json["term"]
  };
}
function DashboardTagCloudItemToJSON(json) {
  return DashboardTagCloudItemToJSONTyped(json, false);
}
function DashboardTagCloudItemToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "count": value["count"],
    "term": value["term"]
  };
}

// models/DashboardVersionMeta.ts
function instanceOfDashboardVersionMeta(value) {
  return true;
}
function DashboardVersionMetaFromJSON(json) {
  return DashboardVersionMetaFromJSONTyped(json);
}
function DashboardVersionMetaFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "created": json["created"] == null ? void 0 : new Date(json["created"]),
    "createdBy": json["createdBy"] == null ? void 0 : json["createdBy"],
    "dashboardId": json["dashboardId"] == null ? void 0 : json["dashboardId"],
    "data": json["data"] == null ? void 0 : json["data"],
    "id": json["id"] == null ? void 0 : json["id"],
    "message": json["message"] == null ? void 0 : json["message"],
    "parentVersion": json["parentVersion"] == null ? void 0 : json["parentVersion"],
    "restoredFrom": json["restoredFrom"] == null ? void 0 : json["restoredFrom"],
    "uid": json["uid"] == null ? void 0 : json["uid"],
    "version": json["version"] == null ? void 0 : json["version"]
  };
}
function DashboardVersionMetaToJSON(json) {
  return DashboardVersionMetaToJSONTyped(json, false);
}
function DashboardVersionMetaToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "created": value["created"] == null ? void 0 : value["created"].toISOString(),
    "createdBy": value["createdBy"],
    "dashboardId": value["dashboardId"],
    "data": value["data"],
    "id": value["id"],
    "message": value["message"],
    "parentVersion": value["parentVersion"],
    "restoredFrom": value["restoredFrom"],
    "uid": value["uid"],
    "version": value["version"]
  };
}

// models/TimeRange.ts
function instanceOfTimeRange(value) {
  return true;
}
function TimeRangeFromJSON(json) {
  return TimeRangeFromJSONTyped(json);
}
function TimeRangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "from": json["from"] == null ? void 0 : new Date(json["from"]),
    "to": json["to"] == null ? void 0 : new Date(json["to"])
  };
}
function TimeRangeToJSON(json) {
  return TimeRangeToJSONTyped(json, false);
}
function TimeRangeToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "from": value["from"] == null ? void 0 : value["from"].toISOString(),
    "to": value["to"] == null ? void 0 : value["to"].toISOString()
  };
}

// models/LinkTransformationConfig.ts
function instanceOfLinkTransformationConfig(value) {
  return true;
}
function LinkTransformationConfigFromJSON(json) {
  return LinkTransformationConfigFromJSONTyped(json);
}
function LinkTransformationConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "expression": json["expression"] == null ? void 0 : json["expression"],
    "field": json["field"] == null ? void 0 : json["field"],
    "mapValue": json["mapValue"] == null ? void 0 : json["mapValue"],
    "type": json["type"] == null ? void 0 : json["type"]
  };
}
function LinkTransformationConfigToJSON(json) {
  return LinkTransformationConfigToJSONTyped(json, false);
}
function LinkTransformationConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "expression": value["expression"],
    "field": value["field"],
    "mapValue": value["mapValue"],
    "type": value["type"]
  };
}

// models/InternalDataLink.ts
function instanceOfInternalDataLink(value) {
  return true;
}
function InternalDataLinkFromJSON(json) {
  return InternalDataLinkFromJSONTyped(json);
}
function InternalDataLinkFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "datasourceName": json["datasourceName"] == null ? void 0 : json["datasourceName"],
    "datasourceUid": json["datasourceUid"] == null ? void 0 : json["datasourceUid"],
    "panelsState": json["panelsState"] == null ? void 0 : json["panelsState"],
    "query": json["query"] == null ? void 0 : json["query"],
    "timeRange": json["timeRange"] == null ? void 0 : TimeRangeFromJSON(json["timeRange"]),
    "transformations": json["transformations"] == null ? void 0 : json["transformations"].map(LinkTransformationConfigFromJSON)
  };
}
function InternalDataLinkToJSON(json) {
  return InternalDataLinkToJSONTyped(json, false);
}
function InternalDataLinkToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "datasourceName": value["datasourceName"],
    "datasourceUid": value["datasourceUid"],
    "panelsState": value["panelsState"],
    "query": value["query"],
    "timeRange": TimeRangeToJSON(value["timeRange"]),
    "transformations": value["transformations"] == null ? void 0 : value["transformations"].map(LinkTransformationConfigToJSON)
  };
}

// models/DataLink.ts
function instanceOfDataLink(value) {
  return true;
}
function DataLinkFromJSON(json) {
  return DataLinkFromJSONTyped(json);
}
function DataLinkFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "internal": json["internal"] == null ? void 0 : InternalDataLinkFromJSON(json["internal"]),
    "targetBlank": json["targetBlank"] == null ? void 0 : json["targetBlank"],
    "title": json["title"] == null ? void 0 : json["title"],
    "url": json["url"] == null ? void 0 : json["url"]
  };
}
function DataLinkToJSON(json) {
  return DataLinkToJSONTyped(json, false);
}
function DataLinkToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "internal": InternalDataLinkToJSON(value["internal"]),
    "targetBlank": value["targetBlank"],
    "title": value["title"],
    "url": value["url"]
  };
}

// models/Threshold.ts
function instanceOfThreshold(value) {
  return true;
}
function ThresholdFromJSON(json) {
  return ThresholdFromJSONTyped(json);
}
function ThresholdFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "color": json["color"] == null ? void 0 : json["color"],
    "state": json["state"] == null ? void 0 : json["state"],
    "value": json["value"] == null ? void 0 : json["value"]
  };
}
function ThresholdToJSON(json) {
  return ThresholdToJSONTyped(json, false);
}
function ThresholdToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "color": value["color"],
    "state": value["state"],
    "value": value["value"]
  };
}

// models/ThresholdsConfig.ts
function instanceOfThresholdsConfig(value) {
  return true;
}
function ThresholdsConfigFromJSON(json) {
  return ThresholdsConfigFromJSONTyped(json);
}
function ThresholdsConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "mode": json["mode"] == null ? void 0 : json["mode"],
    "steps": json["steps"] == null ? void 0 : json["steps"].map(ThresholdFromJSON)
  };
}
function ThresholdsConfigToJSON(json) {
  return ThresholdsConfigToJSONTyped(json, false);
}
function ThresholdsConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "mode": value["mode"],
    "steps": value["steps"] == null ? void 0 : value["steps"].map(ThresholdToJSON)
  };
}

// models/EnumFieldConfig.ts
function instanceOfEnumFieldConfig(value) {
  return true;
}
function EnumFieldConfigFromJSON(json) {
  return EnumFieldConfigFromJSONTyped(json);
}
function EnumFieldConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "color": json["color"] == null ? void 0 : json["color"],
    "description": json["description"] == null ? void 0 : json["description"],
    "icon": json["icon"] == null ? void 0 : json["icon"],
    "text": json["text"] == null ? void 0 : json["text"]
  };
}
function EnumFieldConfigToJSON(json) {
  return EnumFieldConfigToJSONTyped(json, false);
}
function EnumFieldConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "color": value["color"],
    "description": value["description"],
    "icon": value["icon"],
    "text": value["text"]
  };
}

// models/FieldTypeConfig.ts
function instanceOfFieldTypeConfig(value) {
  return true;
}
function FieldTypeConfigFromJSON(json) {
  return FieldTypeConfigFromJSONTyped(json);
}
function FieldTypeConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "_enum": json["enum"] == null ? void 0 : EnumFieldConfigFromJSON(json["enum"])
  };
}
function FieldTypeConfigToJSON(json) {
  return FieldTypeConfigToJSONTyped(json, false);
}
function FieldTypeConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "enum": EnumFieldConfigToJSON(value["_enum"])
  };
}

// models/FieldConfig.ts
function instanceOfFieldConfig(value) {
  return true;
}
function FieldConfigFromJSON(json) {
  return FieldConfigFromJSONTyped(json);
}
function FieldConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "color": json["color"] == null ? void 0 : json["color"],
    "custom": json["custom"] == null ? void 0 : json["custom"],
    "decimals": json["decimals"] == null ? void 0 : json["decimals"],
    "description": json["description"] == null ? void 0 : json["description"],
    "displayName": json["displayName"] == null ? void 0 : json["displayName"],
    "displayNameFromDS": json["displayNameFromDS"] == null ? void 0 : json["displayNameFromDS"],
    "filterable": json["filterable"] == null ? void 0 : json["filterable"],
    "interval": json["interval"] == null ? void 0 : json["interval"],
    "links": json["links"] == null ? void 0 : json["links"].map(DataLinkFromJSON),
    "mappings": json["mappings"] == null ? void 0 : json["mappings"],
    "max": json["max"] == null ? void 0 : json["max"],
    "min": json["min"] == null ? void 0 : json["min"],
    "noValue": json["noValue"] == null ? void 0 : json["noValue"],
    "path": json["path"] == null ? void 0 : json["path"],
    "thresholds": json["thresholds"] == null ? void 0 : ThresholdsConfigFromJSON(json["thresholds"]),
    "type": json["type"] == null ? void 0 : FieldTypeConfigFromJSON(json["type"]),
    "unit": json["unit"] == null ? void 0 : json["unit"],
    "writeable": json["writeable"] == null ? void 0 : json["writeable"]
  };
}
function FieldConfigToJSON(json) {
  return FieldConfigToJSONTyped(json, false);
}
function FieldConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "color": value["color"],
    "custom": value["custom"],
    "decimals": value["decimals"],
    "description": value["description"],
    "displayName": value["displayName"],
    "displayNameFromDS": value["displayNameFromDS"],
    "filterable": value["filterable"],
    "interval": value["interval"],
    "links": value["links"] == null ? void 0 : value["links"].map(DataLinkToJSON),
    "mappings": value["mappings"],
    "max": value["max"],
    "min": value["min"],
    "noValue": value["noValue"],
    "path": value["path"],
    "thresholds": ThresholdsConfigToJSON(value["thresholds"]),
    "type": FieldTypeConfigToJSON(value["type"]),
    "unit": value["unit"],
    "writeable": value["writeable"]
  };
}

// models/Field.ts
function instanceOfField(value) {
  return true;
}
function FieldFromJSON(json) {
  return FieldFromJSONTyped(json);
}
function FieldFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "config": json["config"] == null ? void 0 : FieldConfigFromJSON(json["config"]),
    "labels": json["labels"] == null ? void 0 : json["labels"],
    "name": json["name"] == null ? void 0 : json["name"]
  };
}
function FieldToJSON(json) {
  return FieldToJSONTyped(json, false);
}
function FieldToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "config": FieldConfigToJSON(value["config"]),
    "labels": value["labels"],
    "name": value["name"]
  };
}

// models/QueryStat.ts
function instanceOfQueryStat(value) {
  return true;
}
function QueryStatFromJSON(json) {
  return QueryStatFromJSONTyped(json);
}
function QueryStatFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "color": json["color"] == null ? void 0 : json["color"],
    "custom": json["custom"] == null ? void 0 : json["custom"],
    "decimals": json["decimals"] == null ? void 0 : json["decimals"],
    "description": json["description"] == null ? void 0 : json["description"],
    "displayName": json["displayName"] == null ? void 0 : json["displayName"],
    "displayNameFromDS": json["displayNameFromDS"] == null ? void 0 : json["displayNameFromDS"],
    "filterable": json["filterable"] == null ? void 0 : json["filterable"],
    "interval": json["interval"] == null ? void 0 : json["interval"],
    "links": json["links"] == null ? void 0 : json["links"].map(DataLinkFromJSON),
    "mappings": json["mappings"] == null ? void 0 : json["mappings"],
    "max": json["max"] == null ? void 0 : json["max"],
    "min": json["min"] == null ? void 0 : json["min"],
    "noValue": json["noValue"] == null ? void 0 : json["noValue"],
    "path": json["path"] == null ? void 0 : json["path"],
    "thresholds": json["thresholds"] == null ? void 0 : ThresholdsConfigFromJSON(json["thresholds"]),
    "type": json["type"] == null ? void 0 : FieldTypeConfigFromJSON(json["type"]),
    "unit": json["unit"] == null ? void 0 : json["unit"],
    "value": json["value"] == null ? void 0 : json["value"],
    "writeable": json["writeable"] == null ? void 0 : json["writeable"]
  };
}
function QueryStatToJSON(json) {
  return QueryStatToJSONTyped(json, false);
}
function QueryStatToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "color": value["color"],
    "custom": value["custom"],
    "decimals": value["decimals"],
    "description": value["description"],
    "displayName": value["displayName"],
    "displayNameFromDS": value["displayNameFromDS"],
    "filterable": value["filterable"],
    "interval": value["interval"],
    "links": value["links"] == null ? void 0 : value["links"].map(DataLinkToJSON),
    "mappings": value["mappings"],
    "max": value["max"],
    "min": value["min"],
    "noValue": value["noValue"],
    "path": value["path"],
    "thresholds": ThresholdsConfigToJSON(value["thresholds"]),
    "type": FieldTypeConfigToJSON(value["type"]),
    "unit": value["unit"],
    "value": value["value"],
    "writeable": value["writeable"]
  };
}

// models/Notice.ts
function instanceOfNotice(value) {
  return true;
}
function NoticeFromJSON(json) {
  return NoticeFromJSONTyped(json);
}
function NoticeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "inspect": json["inspect"] == null ? void 0 : json["inspect"],
    "link": json["link"] == null ? void 0 : json["link"],
    "severity": json["severity"] == null ? void 0 : json["severity"],
    "text": json["text"] == null ? void 0 : json["text"]
  };
}
function NoticeToJSON(json) {
  return NoticeToJSONTyped(json, false);
}
function NoticeToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "inspect": value["inspect"],
    "link": value["link"],
    "severity": value["severity"],
    "text": value["text"]
  };
}

// models/FrameMeta.ts
function instanceOfFrameMeta(value) {
  return true;
}
function FrameMetaFromJSON(json) {
  return FrameMetaFromJSONTyped(json);
}
function FrameMetaFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "channel": json["channel"] == null ? void 0 : json["channel"],
    "custom": json["custom"] == null ? void 0 : json["custom"],
    "dataTopic": json["dataTopic"] == null ? void 0 : json["dataTopic"],
    "executedQueryString": json["executedQueryString"] == null ? void 0 : json["executedQueryString"],
    "notices": json["notices"] == null ? void 0 : json["notices"].map(NoticeFromJSON),
    "path": json["path"] == null ? void 0 : json["path"],
    "pathSeparator": json["pathSeparator"] == null ? void 0 : json["pathSeparator"],
    "preferredVisualisationPluginId": json["preferredVisualisationPluginId"] == null ? void 0 : json["preferredVisualisationPluginId"],
    "preferredVisualisationType": json["preferredVisualisationType"] == null ? void 0 : json["preferredVisualisationType"],
    "stats": json["stats"] == null ? void 0 : json["stats"].map(QueryStatFromJSON),
    "type": json["type"] == null ? void 0 : json["type"],
    "typeVersion": json["typeVersion"] == null ? void 0 : json["typeVersion"],
    "uniqueRowIdFields": json["uniqueRowIdFields"] == null ? void 0 : json["uniqueRowIdFields"]
  };
}
function FrameMetaToJSON(json) {
  return FrameMetaToJSONTyped(json, false);
}
function FrameMetaToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "channel": value["channel"],
    "custom": value["custom"],
    "dataTopic": value["dataTopic"],
    "executedQueryString": value["executedQueryString"],
    "notices": value["notices"] == null ? void 0 : value["notices"].map(NoticeToJSON),
    "path": value["path"],
    "pathSeparator": value["pathSeparator"],
    "preferredVisualisationPluginId": value["preferredVisualisationPluginId"],
    "preferredVisualisationType": value["preferredVisualisationType"],
    "stats": value["stats"] == null ? void 0 : value["stats"].map(QueryStatToJSON),
    "type": value["type"],
    "typeVersion": value["typeVersion"],
    "uniqueRowIdFields": value["uniqueRowIdFields"]
  };
}

// models/Frame.ts
function instanceOfFrame(value) {
  return true;
}
function FrameFromJSON(json) {
  return FrameFromJSONTyped(json);
}
function FrameFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "fields": json["Fields"] == null ? void 0 : json["Fields"].map(FieldFromJSON),
    "meta": json["Meta"] == null ? void 0 : FrameMetaFromJSON(json["Meta"]),
    "name": json["Name"] == null ? void 0 : json["Name"],
    "refID": json["RefID"] == null ? void 0 : json["RefID"]
  };
}
function FrameToJSON(json) {
  return FrameToJSONTyped(json, false);
}
function FrameToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "Fields": value["fields"] == null ? void 0 : value["fields"].map(FieldToJSON),
    "Meta": FrameMetaToJSON(value["meta"]),
    "Name": value["name"],
    "RefID": value["refID"]
  };
}

// models/DataResponse.ts
function instanceOfDataResponse(value) {
  return true;
}
function DataResponseFromJSON(json) {
  return DataResponseFromJSONTyped(json);
}
function DataResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "error": json["Error"] == null ? void 0 : json["Error"],
    "errorSource": json["ErrorSource"] == null ? void 0 : json["ErrorSource"],
    "frames": json["Frames"] == null ? void 0 : json["Frames"].map(FrameFromJSON),
    "status": json["Status"] == null ? void 0 : json["Status"]
  };
}
function DataResponseToJSON(json) {
  return DataResponseToJSONTyped(json, false);
}
function DataResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "Error": value["error"],
    "ErrorSource": value["errorSource"],
    "Frames": value["frames"] == null ? void 0 : value["frames"].map(FrameToJSON),
    "Status": value["status"]
  };
}

// models/DataSourceListItemDTO.ts
function instanceOfDataSourceListItemDTO(value) {
  return true;
}
function DataSourceListItemDTOFromJSON(json) {
  return DataSourceListItemDTOFromJSONTyped(json);
}
function DataSourceListItemDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "access": json["access"] == null ? void 0 : json["access"],
    "basicAuth": json["basicAuth"] == null ? void 0 : json["basicAuth"],
    "database": json["database"] == null ? void 0 : json["database"],
    "id": json["id"] == null ? void 0 : json["id"],
    "isDefault": json["isDefault"] == null ? void 0 : json["isDefault"],
    "jsonData": json["jsonData"] == null ? void 0 : json["jsonData"],
    "name": json["name"] == null ? void 0 : json["name"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "readOnly": json["readOnly"] == null ? void 0 : json["readOnly"],
    "type": json["type"] == null ? void 0 : json["type"],
    "typeLogoUrl": json["typeLogoUrl"] == null ? void 0 : json["typeLogoUrl"],
    "typeName": json["typeName"] == null ? void 0 : json["typeName"],
    "uid": json["uid"] == null ? void 0 : json["uid"],
    "url": json["url"] == null ? void 0 : json["url"],
    "user": json["user"] == null ? void 0 : json["user"]
  };
}
function DataSourceListItemDTOToJSON(json) {
  return DataSourceListItemDTOToJSONTyped(json, false);
}
function DataSourceListItemDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "access": value["access"],
    "basicAuth": value["basicAuth"],
    "database": value["database"],
    "id": value["id"],
    "isDefault": value["isDefault"],
    "jsonData": value["jsonData"],
    "name": value["name"],
    "orgId": value["orgId"],
    "readOnly": value["readOnly"],
    "type": value["type"],
    "typeLogoUrl": value["typeLogoUrl"],
    "typeName": value["typeName"],
    "uid": value["uid"],
    "url": value["url"],
    "user": value["user"]
  };
}

// models/DeleteCorrelationResponseBody.ts
function instanceOfDeleteCorrelationResponseBody(value) {
  return true;
}
function DeleteCorrelationResponseBodyFromJSON(json) {
  return DeleteCorrelationResponseBodyFromJSONTyped(json);
}
function DeleteCorrelationResponseBodyFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "message": json["message"] == null ? void 0 : json["message"]
  };
}
function DeleteCorrelationResponseBodyToJSON(json) {
  return DeleteCorrelationResponseBodyToJSONTyped(json, false);
}
function DeleteCorrelationResponseBodyToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "message": value["message"]
  };
}

// models/DeleteDashboardByUID200Response.ts
function instanceOfDeleteDashboardByUID200Response(value) {
  if (!("id" in value) || value["id"] === void 0) return false;
  if (!("message" in value) || value["message"] === void 0) return false;
  if (!("title" in value) || value["title"] === void 0) return false;
  return true;
}
function DeleteDashboardByUID200ResponseFromJSON(json) {
  return DeleteDashboardByUID200ResponseFromJSONTyped(json);
}
function DeleteDashboardByUID200ResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "message": json["message"],
    "title": json["title"]
  };
}
function DeleteDashboardByUID200ResponseToJSON(json) {
  return DeleteDashboardByUID200ResponseToJSONTyped(json, false);
}
function DeleteDashboardByUID200ResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "message": value["message"],
    "title": value["title"]
  };
}

// models/DeleteDataSourceByName200Response.ts
function instanceOfDeleteDataSourceByName200Response(value) {
  if (!("id" in value) || value["id"] === void 0) return false;
  if (!("message" in value) || value["message"] === void 0) return false;
  return true;
}
function DeleteDataSourceByName200ResponseFromJSON(json) {
  return DeleteDataSourceByName200ResponseFromJSONTyped(json);
}
function DeleteDataSourceByName200ResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "message": json["message"]
  };
}
function DeleteDataSourceByName200ResponseToJSON(json) {
  return DeleteDataSourceByName200ResponseToJSONTyped(json, false);
}
function DeleteDataSourceByName200ResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "message": value["message"]
  };
}

// models/DeleteFolder200Response.ts
function instanceOfDeleteFolder200Response(value) {
  if (!("id" in value) || value["id"] === void 0) return false;
  if (!("message" in value) || value["message"] === void 0) return false;
  if (!("title" in value) || value["title"] === void 0) return false;
  return true;
}
function DeleteFolder200ResponseFromJSON(json) {
  return DeleteFolder200ResponseFromJSONTyped(json);
}
function DeleteFolder200ResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "message": json["message"],
    "title": json["title"]
  };
}
function DeleteFolder200ResponseToJSON(json) {
  return DeleteFolder200ResponseToJSONTyped(json, false);
}
function DeleteFolder200ResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "message": value["message"],
    "title": value["title"]
  };
}

// models/DeleteTokenCommand.ts
function instanceOfDeleteTokenCommand(value) {
  return true;
}
function DeleteTokenCommandFromJSON(json) {
  return DeleteTokenCommandFromJSONTyped(json);
}
function DeleteTokenCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "instance": json["instance"] == null ? void 0 : json["instance"]
  };
}
function DeleteTokenCommandToJSON(json) {
  return DeleteTokenCommandToJSONTyped(json, false);
}
function DeleteTokenCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "instance": value["instance"]
  };
}

// models/Description.ts
function instanceOfDescription(value) {
  return true;
}
function DescriptionFromJSON(json) {
  return DescriptionFromJSONTyped(json);
}
function DescriptionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "assignments": json["assignments"] == null ? void 0 : AssignmentsFromJSON(json["assignments"]),
    "permissions": json["permissions"] == null ? void 0 : json["permissions"]
  };
}
function DescriptionToJSON(json) {
  return DescriptionToJSONTyped(json, false);
}
function DescriptionToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "assignments": AssignmentsToJSON(value["assignments"]),
    "permissions": value["permissions"]
  };
}

// models/DeviceDTO.ts
function instanceOfDeviceDTO(value) {
  return true;
}
function DeviceDTOFromJSON(json) {
  return DeviceDTOFromJSONTyped(json);
}
function DeviceDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "avatarUrl": json["avatarUrl"] == null ? void 0 : json["avatarUrl"],
    "clientIp": json["clientIp"] == null ? void 0 : json["clientIp"],
    "createdAt": json["createdAt"] == null ? void 0 : new Date(json["createdAt"]),
    "deviceId": json["deviceId"] == null ? void 0 : json["deviceId"],
    "lastSeenAt": json["lastSeenAt"] == null ? void 0 : json["lastSeenAt"],
    "updatedAt": json["updatedAt"] == null ? void 0 : new Date(json["updatedAt"]),
    "userAgent": json["userAgent"] == null ? void 0 : json["userAgent"]
  };
}
function DeviceDTOToJSON(json) {
  return DeviceDTOToJSONTyped(json, false);
}
function DeviceDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "avatarUrl": value["avatarUrl"],
    "clientIp": value["clientIp"],
    "createdAt": value["createdAt"] == null ? void 0 : value["createdAt"].toISOString(),
    "deviceId": value["deviceId"],
    "lastSeenAt": value["lastSeenAt"],
    "updatedAt": value["updatedAt"] == null ? void 0 : value["updatedAt"].toISOString(),
    "userAgent": value["userAgent"]
  };
}

// models/DeviceSearchHitDTO.ts
function instanceOfDeviceSearchHitDTO(value) {
  return true;
}
function DeviceSearchHitDTOFromJSON(json) {
  return DeviceSearchHitDTOFromJSONTyped(json);
}
function DeviceSearchHitDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "clientIp": json["clientIp"] == null ? void 0 : json["clientIp"],
    "createdAt": json["createdAt"] == null ? void 0 : new Date(json["createdAt"]),
    "deviceId": json["deviceId"] == null ? void 0 : json["deviceId"],
    "lastSeenAt": json["lastSeenAt"] == null ? void 0 : new Date(json["lastSeenAt"]),
    "updatedAt": json["updatedAt"] == null ? void 0 : new Date(json["updatedAt"]),
    "userAgent": json["userAgent"] == null ? void 0 : json["userAgent"]
  };
}
function DeviceSearchHitDTOToJSON(json) {
  return DeviceSearchHitDTOToJSONTyped(json, false);
}
function DeviceSearchHitDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "clientIp": value["clientIp"],
    "createdAt": value["createdAt"] == null ? void 0 : value["createdAt"].toISOString(),
    "deviceId": value["deviceId"],
    "lastSeenAt": value["lastSeenAt"] == null ? void 0 : value["lastSeenAt"].toISOString(),
    "updatedAt": value["updatedAt"] == null ? void 0 : value["updatedAt"].toISOString(),
    "userAgent": value["userAgent"]
  };
}

// models/DiscordConfig.ts
function instanceOfDiscordConfig(value) {
  return true;
}
function DiscordConfigFromJSON(json) {
  return DiscordConfigFromJSONTyped(json);
}
function DiscordConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "httpConfig": json["http_config"] == null ? void 0 : HTTPClientConfigFromJSON(json["http_config"]),
    "message": json["message"] == null ? void 0 : json["message"],
    "sendResolved": json["send_resolved"] == null ? void 0 : json["send_resolved"],
    "title": json["title"] == null ? void 0 : json["title"],
    "webhookUrl": json["webhook_url"] == null ? void 0 : URLFromJSON(json["webhook_url"]),
    "webhookUrlFile": json["webhook_url_file"] == null ? void 0 : json["webhook_url_file"]
  };
}
function DiscordConfigToJSON(json) {
  return DiscordConfigToJSONTyped(json, false);
}
function DiscordConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "http_config": HTTPClientConfigToJSON(value["httpConfig"]),
    "message": value["message"],
    "send_resolved": value["sendResolved"],
    "title": value["title"],
    "webhook_url": URLToJSON(value["webhookUrl"]),
    "webhook_url_file": value["webhookUrlFile"]
  };
}

// models/DiscoveryBase.ts
function instanceOfDiscoveryBase(value) {
  if (!("status" in value) || value["status"] === void 0) return false;
  return true;
}
function DiscoveryBaseFromJSON(json) {
  return DiscoveryBaseFromJSONTyped(json);
}
function DiscoveryBaseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "error": json["error"] == null ? void 0 : json["error"],
    "errorType": json["errorType"] == null ? void 0 : json["errorType"],
    "status": json["status"]
  };
}
function DiscoveryBaseToJSON(json) {
  return DiscoveryBaseToJSONTyped(json, false);
}
function DiscoveryBaseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "error": value["error"],
    "errorType": value["errorType"],
    "status": value["status"]
  };
}

// models/EmailConfig.ts
function instanceOfEmailConfig(value) {
  return true;
}
function EmailConfigFromJSON(json) {
  return EmailConfigFromJSONTyped(json);
}
function EmailConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "authIdentity": json["auth_identity"] == null ? void 0 : json["auth_identity"],
    "authPassword": json["auth_password"] == null ? void 0 : json["auth_password"],
    "authPasswordFile": json["auth_password_file"] == null ? void 0 : json["auth_password_file"],
    "authSecret": json["auth_secret"] == null ? void 0 : json["auth_secret"],
    "authUsername": json["auth_username"] == null ? void 0 : json["auth_username"],
    "from": json["from"] == null ? void 0 : json["from"],
    "headers": json["headers"] == null ? void 0 : json["headers"],
    "hello": json["hello"] == null ? void 0 : json["hello"],
    "html": json["html"] == null ? void 0 : json["html"],
    "requireTls": json["require_tls"] == null ? void 0 : json["require_tls"],
    "sendResolved": json["send_resolved"] == null ? void 0 : json["send_resolved"],
    "smarthost": json["smarthost"] == null ? void 0 : HostPortFromJSON(json["smarthost"]),
    "text": json["text"] == null ? void 0 : json["text"],
    "tlsConfig": json["tls_config"] == null ? void 0 : TLSConfigFromJSON(json["tls_config"]),
    "to": json["to"] == null ? void 0 : json["to"]
  };
}
function EmailConfigToJSON(json) {
  return EmailConfigToJSONTyped(json, false);
}
function EmailConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "auth_identity": value["authIdentity"],
    "auth_password": value["authPassword"],
    "auth_password_file": value["authPasswordFile"],
    "auth_secret": value["authSecret"],
    "auth_username": value["authUsername"],
    "from": value["from"],
    "headers": value["headers"],
    "hello": value["hello"],
    "html": value["html"],
    "require_tls": value["requireTls"],
    "send_resolved": value["sendResolved"],
    "smarthost": HostPortToJSON(value["smarthost"]),
    "text": value["text"],
    "tls_config": TLSConfigToJSON(value["tlsConfig"]),
    "to": value["to"]
  };
}

// models/EmailDTO.ts
function instanceOfEmailDTO(value) {
  return true;
}
function EmailDTOFromJSON(json) {
  return EmailDTOFromJSONTyped(json);
}
function EmailDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "recipient": json["recipient"] == null ? void 0 : json["recipient"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function EmailDTOToJSON(json) {
  return EmailDTOToJSONTyped(json, false);
}
function EmailDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "recipient": value["recipient"],
    "uid": value["uid"]
  };
}

// models/EmbeddedContactPoint.ts
var EmbeddedContactPointTypeEnum = {
  Alertmanager: "alertmanager",
  Dingding: " dingding",
  Discord: " discord",
  Email: " email",
  Googlechat: " googlechat",
  Kafka: " kafka",
  Line: " line",
  Opsgenie: " opsgenie",
  Pagerduty: " pagerduty",
  Pushover: " pushover",
  Sensugo: " sensugo",
  Slack: " slack",
  Teams: " teams",
  Telegram: " telegram",
  Threema: " threema",
  Victorops: " victorops",
  Webhook: " webhook",
  Wecom: " wecom"
};
function instanceOfEmbeddedContactPoint(value) {
  if (!("settings" in value) || value["settings"] === void 0) return false;
  if (!("type" in value) || value["type"] === void 0) return false;
  return true;
}
function EmbeddedContactPointFromJSON(json) {
  return EmbeddedContactPointFromJSONTyped(json);
}
function EmbeddedContactPointFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "disableResolveMessage": json["disableResolveMessage"] == null ? void 0 : json["disableResolveMessage"],
    "name": json["name"] == null ? void 0 : json["name"],
    "provenance": json["provenance"] == null ? void 0 : json["provenance"],
    "settings": json["settings"],
    "type": json["type"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function EmbeddedContactPointToJSON(json) {
  return EmbeddedContactPointToJSONTyped(json, false);
}
function EmbeddedContactPointToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "disableResolveMessage": value["disableResolveMessage"],
    "name": value["name"],
    "settings": value["settings"],
    "type": value["type"],
    "uid": value["uid"]
  };
}

// models/ErrorResponseBody.ts
function instanceOfErrorResponseBody(value) {
  if (!("message" in value) || value["message"] === void 0) return false;
  return true;
}
function ErrorResponseBodyFromJSON(json) {
  return ErrorResponseBodyFromJSONTyped(json);
}
function ErrorResponseBodyFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "error": json["error"] == null ? void 0 : json["error"],
    "message": json["message"],
    "status": json["status"] == null ? void 0 : json["status"]
  };
}
function ErrorResponseBodyToJSON(json) {
  return ErrorResponseBodyToJSONTyped(json, false);
}
function ErrorResponseBodyToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "error": value["error"],
    "message": value["message"],
    "status": value["status"]
  };
}

// models/EvalAlertConditionCommand.ts
function instanceOfEvalAlertConditionCommand(value) {
  return true;
}
function EvalAlertConditionCommandFromJSON(json) {
  return EvalAlertConditionCommandFromJSONTyped(json);
}
function EvalAlertConditionCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "condition": json["condition"] == null ? void 0 : json["condition"],
    "data": json["data"] == null ? void 0 : json["data"].map(AlertQueryFromJSON),
    "now": json["now"] == null ? void 0 : new Date(json["now"])
  };
}
function EvalAlertConditionCommandToJSON(json) {
  return EvalAlertConditionCommandToJSONTyped(json, false);
}
function EvalAlertConditionCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "condition": value["condition"],
    "data": value["data"] == null ? void 0 : value["data"].map(AlertQueryToJSON),
    "now": value["now"] == null ? void 0 : value["now"].toISOString()
  };
}

// models/EvalQueriesPayload.ts
function instanceOfEvalQueriesPayload(value) {
  return true;
}
function EvalQueriesPayloadFromJSON(json) {
  return EvalQueriesPayloadFromJSONTyped(json);
}
function EvalQueriesPayloadFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "condition": json["condition"] == null ? void 0 : json["condition"],
    "data": json["data"] == null ? void 0 : json["data"].map(AlertQueryFromJSON),
    "now": json["now"] == null ? void 0 : new Date(json["now"])
  };
}
function EvalQueriesPayloadToJSON(json) {
  return EvalQueriesPayloadToJSONTyped(json, false);
}
function EvalQueriesPayloadToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "condition": value["condition"],
    "data": value["data"] == null ? void 0 : value["data"].map(AlertQueryToJSON),
    "now": value["now"] == null ? void 0 : value["now"].toISOString()
  };
}

// models/SlackField.ts
function instanceOfSlackField(value) {
  return true;
}
function SlackFieldFromJSON(json) {
  return SlackFieldFromJSONTyped(json);
}
function SlackFieldFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "_short": json["short"] == null ? void 0 : json["short"],
    "title": json["title"] == null ? void 0 : json["title"],
    "value": json["value"] == null ? void 0 : json["value"]
  };
}
function SlackFieldToJSON(json) {
  return SlackFieldToJSONTyped(json, false);
}
function SlackFieldToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "short": value["_short"],
    "title": value["title"],
    "value": value["value"]
  };
}

// models/SlackConfirmationField.ts
function instanceOfSlackConfirmationField(value) {
  return true;
}
function SlackConfirmationFieldFromJSON(json) {
  return SlackConfirmationFieldFromJSONTyped(json);
}
function SlackConfirmationFieldFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "dismissText": json["dismiss_text"] == null ? void 0 : json["dismiss_text"],
    "okText": json["ok_text"] == null ? void 0 : json["ok_text"],
    "text": json["text"] == null ? void 0 : json["text"],
    "title": json["title"] == null ? void 0 : json["title"]
  };
}
function SlackConfirmationFieldToJSON(json) {
  return SlackConfirmationFieldToJSONTyped(json, false);
}
function SlackConfirmationFieldToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "dismiss_text": value["dismissText"],
    "ok_text": value["okText"],
    "text": value["text"],
    "title": value["title"]
  };
}

// models/SlackAction.ts
function instanceOfSlackAction(value) {
  return true;
}
function SlackActionFromJSON(json) {
  return SlackActionFromJSONTyped(json);
}
function SlackActionFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "confirm": json["confirm"] == null ? void 0 : SlackConfirmationFieldFromJSON(json["confirm"]),
    "name": json["name"] == null ? void 0 : json["name"],
    "style": json["style"] == null ? void 0 : json["style"],
    "text": json["text"] == null ? void 0 : json["text"],
    "type": json["type"] == null ? void 0 : json["type"],
    "url": json["url"] == null ? void 0 : json["url"],
    "value": json["value"] == null ? void 0 : json["value"]
  };
}
function SlackActionToJSON(json) {
  return SlackActionToJSONTyped(json, false);
}
function SlackActionToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "confirm": SlackConfirmationFieldToJSON(value["confirm"]),
    "name": value["name"],
    "style": value["style"],
    "text": value["text"],
    "type": value["type"],
    "url": value["url"],
    "value": value["value"]
  };
}

// models/SlackConfig.ts
function instanceOfSlackConfig(value) {
  return true;
}
function SlackConfigFromJSON(json) {
  return SlackConfigFromJSONTyped(json);
}
function SlackConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "actions": json["actions"] == null ? void 0 : json["actions"].map(SlackActionFromJSON),
    "apiUrl": json["api_url"] == null ? void 0 : URLFromJSON(json["api_url"]),
    "apiUrlFile": json["api_url_file"] == null ? void 0 : json["api_url_file"],
    "callbackId": json["callback_id"] == null ? void 0 : json["callback_id"],
    "channel": json["channel"] == null ? void 0 : json["channel"],
    "color": json["color"] == null ? void 0 : json["color"],
    "fallback": json["fallback"] == null ? void 0 : json["fallback"],
    "fields": json["fields"] == null ? void 0 : json["fields"].map(SlackFieldFromJSON),
    "footer": json["footer"] == null ? void 0 : json["footer"],
    "httpConfig": json["http_config"] == null ? void 0 : HTTPClientConfigFromJSON(json["http_config"]),
    "iconEmoji": json["icon_emoji"] == null ? void 0 : json["icon_emoji"],
    "iconUrl": json["icon_url"] == null ? void 0 : json["icon_url"],
    "imageUrl": json["image_url"] == null ? void 0 : json["image_url"],
    "linkNames": json["link_names"] == null ? void 0 : json["link_names"],
    "mrkdwnIn": json["mrkdwn_in"] == null ? void 0 : json["mrkdwn_in"],
    "pretext": json["pretext"] == null ? void 0 : json["pretext"],
    "sendResolved": json["send_resolved"] == null ? void 0 : json["send_resolved"],
    "shortFields": json["short_fields"] == null ? void 0 : json["short_fields"],
    "text": json["text"] == null ? void 0 : json["text"],
    "thumbUrl": json["thumb_url"] == null ? void 0 : json["thumb_url"],
    "title": json["title"] == null ? void 0 : json["title"],
    "titleLink": json["title_link"] == null ? void 0 : json["title_link"],
    "username": json["username"] == null ? void 0 : json["username"]
  };
}
function SlackConfigToJSON(json) {
  return SlackConfigToJSONTyped(json, false);
}
function SlackConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "actions": value["actions"] == null ? void 0 : value["actions"].map(SlackActionToJSON),
    "api_url": URLToJSON(value["apiUrl"]),
    "api_url_file": value["apiUrlFile"],
    "callback_id": value["callbackId"],
    "channel": value["channel"],
    "color": value["color"],
    "fallback": value["fallback"],
    "fields": value["fields"] == null ? void 0 : value["fields"].map(SlackFieldToJSON),
    "footer": value["footer"],
    "http_config": HTTPClientConfigToJSON(value["httpConfig"]),
    "icon_emoji": value["iconEmoji"],
    "icon_url": value["iconUrl"],
    "image_url": value["imageUrl"],
    "link_names": value["linkNames"],
    "mrkdwn_in": value["mrkdwnIn"],
    "pretext": value["pretext"],
    "send_resolved": value["sendResolved"],
    "short_fields": value["shortFields"],
    "text": value["text"],
    "thumb_url": value["thumbUrl"],
    "title": value["title"],
    "title_link": value["titleLink"],
    "username": value["username"]
  };
}

// models/PostableGrafanaReceiver.ts
function instanceOfPostableGrafanaReceiver(value) {
  return true;
}
function PostableGrafanaReceiverFromJSON(json) {
  return PostableGrafanaReceiverFromJSONTyped(json);
}
function PostableGrafanaReceiverFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "disableResolveMessage": json["disableResolveMessage"] == null ? void 0 : json["disableResolveMessage"],
    "name": json["name"] == null ? void 0 : json["name"],
    "secureSettings": json["secureSettings"] == null ? void 0 : json["secureSettings"],
    "settings": json["settings"] == null ? void 0 : json["settings"],
    "type": json["type"] == null ? void 0 : json["type"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function PostableGrafanaReceiverToJSON(json) {
  return PostableGrafanaReceiverToJSONTyped(json, false);
}
function PostableGrafanaReceiverToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "disableResolveMessage": value["disableResolveMessage"],
    "name": value["name"],
    "secureSettings": value["secureSettings"],
    "settings": value["settings"],
    "type": value["type"],
    "uid": value["uid"]
  };
}

// models/WebhookConfig.ts
function instanceOfWebhookConfig(value) {
  return true;
}
function WebhookConfigFromJSON(json) {
  return WebhookConfigFromJSONTyped(json);
}
function WebhookConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "httpConfig": json["http_config"] == null ? void 0 : HTTPClientConfigFromJSON(json["http_config"]),
    "maxAlerts": json["max_alerts"] == null ? void 0 : json["max_alerts"],
    "sendResolved": json["send_resolved"] == null ? void 0 : json["send_resolved"],
    "url": json["url"] == null ? void 0 : URLFromJSON(json["url"]),
    "urlFile": json["url_file"] == null ? void 0 : json["url_file"]
  };
}
function WebhookConfigToJSON(json) {
  return WebhookConfigToJSONTyped(json, false);
}
function WebhookConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "http_config": HTTPClientConfigToJSON(value["httpConfig"]),
    "max_alerts": value["maxAlerts"],
    "send_resolved": value["sendResolved"],
    "url": URLToJSON(value["url"]),
    "url_file": value["urlFile"]
  };
}

// models/VictorOpsConfig.ts
function instanceOfVictorOpsConfig(value) {
  return true;
}
function VictorOpsConfigFromJSON(json) {
  return VictorOpsConfigFromJSONTyped(json);
}
function VictorOpsConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "apiKey": json["api_key"] == null ? void 0 : json["api_key"],
    "apiKeyFile": json["api_key_file"] == null ? void 0 : json["api_key_file"],
    "apiUrl": json["api_url"] == null ? void 0 : URLFromJSON(json["api_url"]),
    "customFields": json["custom_fields"] == null ? void 0 : json["custom_fields"],
    "entityDisplayName": json["entity_display_name"] == null ? void 0 : json["entity_display_name"],
    "httpConfig": json["http_config"] == null ? void 0 : HTTPClientConfigFromJSON(json["http_config"]),
    "messageType": json["message_type"] == null ? void 0 : json["message_type"],
    "monitoringTool": json["monitoring_tool"] == null ? void 0 : json["monitoring_tool"],
    "routingKey": json["routing_key"] == null ? void 0 : json["routing_key"],
    "sendResolved": json["send_resolved"] == null ? void 0 : json["send_resolved"],
    "stateMessage": json["state_message"] == null ? void 0 : json["state_message"]
  };
}
function VictorOpsConfigToJSON(json) {
  return VictorOpsConfigToJSONTyped(json, false);
}
function VictorOpsConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "api_key": value["apiKey"],
    "api_key_file": value["apiKeyFile"],
    "api_url": URLToJSON(value["apiUrl"]),
    "custom_fields": value["customFields"],
    "entity_display_name": value["entityDisplayName"],
    "http_config": HTTPClientConfigToJSON(value["httpConfig"]),
    "message_type": value["messageType"],
    "monitoring_tool": value["monitoringTool"],
    "routing_key": value["routingKey"],
    "send_resolved": value["sendResolved"],
    "state_message": value["stateMessage"]
  };
}

// models/OpsGenieConfigResponder.ts
function instanceOfOpsGenieConfigResponder(value) {
  return true;
}
function OpsGenieConfigResponderFromJSON(json) {
  return OpsGenieConfigResponderFromJSONTyped(json);
}
function OpsGenieConfigResponderFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"] == null ? void 0 : json["id"],
    "name": json["name"] == null ? void 0 : json["name"],
    "type": json["type"] == null ? void 0 : json["type"],
    "username": json["username"] == null ? void 0 : json["username"]
  };
}
function OpsGenieConfigResponderToJSON(json) {
  return OpsGenieConfigResponderToJSONTyped(json, false);
}
function OpsGenieConfigResponderToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "name": value["name"],
    "type": value["type"],
    "username": value["username"]
  };
}

// models/OpsGenieConfig.ts
function instanceOfOpsGenieConfig(value) {
  return true;
}
function OpsGenieConfigFromJSON(json) {
  return OpsGenieConfigFromJSONTyped(json);
}
function OpsGenieConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "actions": json["actions"] == null ? void 0 : json["actions"],
    "apiKey": json["api_key"] == null ? void 0 : json["api_key"],
    "apiKeyFile": json["api_key_file"] == null ? void 0 : json["api_key_file"],
    "apiUrl": json["api_url"] == null ? void 0 : URLFromJSON(json["api_url"]),
    "description": json["description"] == null ? void 0 : json["description"],
    "details": json["details"] == null ? void 0 : json["details"],
    "entity": json["entity"] == null ? void 0 : json["entity"],
    "httpConfig": json["http_config"] == null ? void 0 : HTTPClientConfigFromJSON(json["http_config"]),
    "message": json["message"] == null ? void 0 : json["message"],
    "note": json["note"] == null ? void 0 : json["note"],
    "priority": json["priority"] == null ? void 0 : json["priority"],
    "responders": json["responders"] == null ? void 0 : json["responders"].map(OpsGenieConfigResponderFromJSON),
    "sendResolved": json["send_resolved"] == null ? void 0 : json["send_resolved"],
    "source": json["source"] == null ? void 0 : json["source"],
    "tags": json["tags"] == null ? void 0 : json["tags"],
    "updateAlerts": json["update_alerts"] == null ? void 0 : json["update_alerts"]
  };
}
function OpsGenieConfigToJSON(json) {
  return OpsGenieConfigToJSONTyped(json, false);
}
function OpsGenieConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "actions": value["actions"],
    "api_key": value["apiKey"],
    "api_key_file": value["apiKeyFile"],
    "api_url": URLToJSON(value["apiUrl"]),
    "description": value["description"],
    "details": value["details"],
    "entity": value["entity"],
    "http_config": HTTPClientConfigToJSON(value["httpConfig"]),
    "message": value["message"],
    "note": value["note"],
    "priority": value["priority"],
    "responders": value["responders"] == null ? void 0 : value["responders"].map(OpsGenieConfigResponderToJSON),
    "send_resolved": value["sendResolved"],
    "source": value["source"],
    "tags": value["tags"],
    "update_alerts": value["updateAlerts"]
  };
}

// models/PushoverConfig.ts
function instanceOfPushoverConfig(value) {
  return true;
}
function PushoverConfigFromJSON(json) {
  return PushoverConfigFromJSONTyped(json);
}
function PushoverConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "device": json["device"] == null ? void 0 : json["device"],
    "expire": json["expire"] == null ? void 0 : json["expire"],
    "html": json["html"] == null ? void 0 : json["html"],
    "httpConfig": json["http_config"] == null ? void 0 : HTTPClientConfigFromJSON(json["http_config"]),
    "message": json["message"] == null ? void 0 : json["message"],
    "priority": json["priority"] == null ? void 0 : json["priority"],
    "retry": json["retry"] == null ? void 0 : json["retry"],
    "sendResolved": json["send_resolved"] == null ? void 0 : json["send_resolved"],
    "sound": json["sound"] == null ? void 0 : json["sound"],
    "title": json["title"] == null ? void 0 : json["title"],
    "token": json["token"] == null ? void 0 : json["token"],
    "tokenFile": json["token_file"] == null ? void 0 : json["token_file"],
    "ttl": json["ttl"] == null ? void 0 : json["ttl"],
    "url": json["url"] == null ? void 0 : json["url"],
    "urlTitle": json["url_title"] == null ? void 0 : json["url_title"],
    "userKey": json["user_key"] == null ? void 0 : json["user_key"],
    "userKeyFile": json["user_key_file"] == null ? void 0 : json["user_key_file"]
  };
}
function PushoverConfigToJSON(json) {
  return PushoverConfigToJSONTyped(json, false);
}
function PushoverConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "device": value["device"],
    "expire": value["expire"],
    "html": value["html"],
    "http_config": HTTPClientConfigToJSON(value["httpConfig"]),
    "message": value["message"],
    "priority": value["priority"],
    "retry": value["retry"],
    "send_resolved": value["sendResolved"],
    "sound": value["sound"],
    "title": value["title"],
    "token": value["token"],
    "token_file": value["tokenFile"],
    "ttl": value["ttl"],
    "url": value["url"],
    "url_title": value["urlTitle"],
    "user_key": value["userKey"],
    "user_key_file": value["userKeyFile"]
  };
}

// models/PagerdutyImage.ts
function instanceOfPagerdutyImage(value) {
  return true;
}
function PagerdutyImageFromJSON(json) {
  return PagerdutyImageFromJSONTyped(json);
}
function PagerdutyImageFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "alt": json["alt"] == null ? void 0 : json["alt"],
    "href": json["href"] == null ? void 0 : json["href"],
    "src": json["src"] == null ? void 0 : json["src"]
  };
}
function PagerdutyImageToJSON(json) {
  return PagerdutyImageToJSONTyped(json, false);
}
function PagerdutyImageToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "alt": value["alt"],
    "href": value["href"],
    "src": value["src"]
  };
}

// models/PagerdutyLink.ts
function instanceOfPagerdutyLink(value) {
  return true;
}
function PagerdutyLinkFromJSON(json) {
  return PagerdutyLinkFromJSONTyped(json);
}
function PagerdutyLinkFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "href": json["href"] == null ? void 0 : json["href"],
    "text": json["text"] == null ? void 0 : json["text"]
  };
}
function PagerdutyLinkToJSON(json) {
  return PagerdutyLinkToJSONTyped(json, false);
}
function PagerdutyLinkToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "href": value["href"],
    "text": value["text"]
  };
}

// models/PagerdutyConfig.ts
function instanceOfPagerdutyConfig(value) {
  return true;
}
function PagerdutyConfigFromJSON(json) {
  return PagerdutyConfigFromJSONTyped(json);
}
function PagerdutyConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "_class": json["class"] == null ? void 0 : json["class"],
    "client": json["client"] == null ? void 0 : json["client"],
    "clientUrl": json["client_url"] == null ? void 0 : json["client_url"],
    "component": json["component"] == null ? void 0 : json["component"],
    "description": json["description"] == null ? void 0 : json["description"],
    "details": json["details"] == null ? void 0 : json["details"],
    "group": json["group"] == null ? void 0 : json["group"],
    "httpConfig": json["http_config"] == null ? void 0 : HTTPClientConfigFromJSON(json["http_config"]),
    "images": json["images"] == null ? void 0 : json["images"].map(PagerdutyImageFromJSON),
    "links": json["links"] == null ? void 0 : json["links"].map(PagerdutyLinkFromJSON),
    "routingKey": json["routing_key"] == null ? void 0 : json["routing_key"],
    "routingKeyFile": json["routing_key_file"] == null ? void 0 : json["routing_key_file"],
    "sendResolved": json["send_resolved"] == null ? void 0 : json["send_resolved"],
    "serviceKey": json["service_key"] == null ? void 0 : json["service_key"],
    "serviceKeyFile": json["service_key_file"] == null ? void 0 : json["service_key_file"],
    "severity": json["severity"] == null ? void 0 : json["severity"],
    "source": json["source"] == null ? void 0 : json["source"],
    "url": json["url"] == null ? void 0 : URLFromJSON(json["url"])
  };
}
function PagerdutyConfigToJSON(json) {
  return PagerdutyConfigToJSONTyped(json, false);
}
function PagerdutyConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "class": value["_class"],
    "client": value["client"],
    "client_url": value["clientUrl"],
    "component": value["component"],
    "description": value["description"],
    "details": value["details"],
    "group": value["group"],
    "http_config": HTTPClientConfigToJSON(value["httpConfig"]),
    "images": value["images"] == null ? void 0 : value["images"].map(PagerdutyImageToJSON),
    "links": value["links"] == null ? void 0 : value["links"].map(PagerdutyLinkToJSON),
    "routing_key": value["routingKey"],
    "routing_key_file": value["routingKeyFile"],
    "send_resolved": value["sendResolved"],
    "service_key": value["serviceKey"],
    "service_key_file": value["serviceKeyFile"],
    "severity": value["severity"],
    "source": value["source"],
    "url": URLToJSON(value["url"])
  };
}

// models/WechatConfig.ts
function instanceOfWechatConfig(value) {
  return true;
}
function WechatConfigFromJSON(json) {
  return WechatConfigFromJSONTyped(json);
}
function WechatConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "agentId": json["agent_id"] == null ? void 0 : json["agent_id"],
    "apiSecret": json["api_secret"] == null ? void 0 : json["api_secret"],
    "apiUrl": json["api_url"] == null ? void 0 : URLFromJSON(json["api_url"]),
    "corpId": json["corp_id"] == null ? void 0 : json["corp_id"],
    "httpConfig": json["http_config"] == null ? void 0 : HTTPClientConfigFromJSON(json["http_config"]),
    "message": json["message"] == null ? void 0 : json["message"],
    "messageType": json["message_type"] == null ? void 0 : json["message_type"],
    "sendResolved": json["send_resolved"] == null ? void 0 : json["send_resolved"],
    "toParty": json["to_party"] == null ? void 0 : json["to_party"],
    "toTag": json["to_tag"] == null ? void 0 : json["to_tag"],
    "toUser": json["to_user"] == null ? void 0 : json["to_user"]
  };
}
function WechatConfigToJSON(json) {
  return WechatConfigToJSONTyped(json, false);
}
function WechatConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "agent_id": value["agentId"],
    "api_secret": value["apiSecret"],
    "api_url": URLToJSON(value["apiUrl"]),
    "corp_id": value["corpId"],
    "http_config": HTTPClientConfigToJSON(value["httpConfig"]),
    "message": value["message"],
    "message_type": value["messageType"],
    "send_resolved": value["sendResolved"],
    "to_party": value["toParty"],
    "to_tag": value["toTag"],
    "to_user": value["toUser"]
  };
}

// models/ExtendedReceiver.ts
function instanceOfExtendedReceiver(value) {
  return true;
}
function ExtendedReceiverFromJSON(json) {
  return ExtendedReceiverFromJSONTyped(json);
}
function ExtendedReceiverFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "emailConfigs": json["email_configs"] == null ? void 0 : EmailConfigFromJSON(json["email_configs"]),
    "grafanaManagedReceiver": json["grafana_managed_receiver"] == null ? void 0 : PostableGrafanaReceiverFromJSON(json["grafana_managed_receiver"]),
    "opsgenieConfigs": json["opsgenie_configs"] == null ? void 0 : OpsGenieConfigFromJSON(json["opsgenie_configs"]),
    "pagerdutyConfigs": json["pagerduty_configs"] == null ? void 0 : PagerdutyConfigFromJSON(json["pagerduty_configs"]),
    "pushoverConfigs": json["pushover_configs"] == null ? void 0 : PushoverConfigFromJSON(json["pushover_configs"]),
    "slackConfigs": json["slack_configs"] == null ? void 0 : SlackConfigFromJSON(json["slack_configs"]),
    "victoropsConfigs": json["victorops_configs"] == null ? void 0 : VictorOpsConfigFromJSON(json["victorops_configs"]),
    "webhookConfigs": json["webhook_configs"] == null ? void 0 : WebhookConfigFromJSON(json["webhook_configs"]),
    "wechatConfigs": json["wechat_configs"] == null ? void 0 : WechatConfigFromJSON(json["wechat_configs"])
  };
}
function ExtendedReceiverToJSON(json) {
  return ExtendedReceiverToJSONTyped(json, false);
}
function ExtendedReceiverToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "email_configs": EmailConfigToJSON(value["emailConfigs"]),
    "grafana_managed_receiver": PostableGrafanaReceiverToJSON(value["grafanaManagedReceiver"]),
    "opsgenie_configs": OpsGenieConfigToJSON(value["opsgenieConfigs"]),
    "pagerduty_configs": PagerdutyConfigToJSON(value["pagerdutyConfigs"]),
    "pushover_configs": PushoverConfigToJSON(value["pushoverConfigs"]),
    "slack_configs": SlackConfigToJSON(value["slackConfigs"]),
    "victorops_configs": VictorOpsConfigToJSON(value["victoropsConfigs"]),
    "webhook_configs": WebhookConfigToJSON(value["webhookConfigs"]),
    "wechat_configs": WechatConfigToJSON(value["wechatConfigs"])
  };
}

// models/TagsDTO.ts
function instanceOfTagsDTO(value) {
  return true;
}
function TagsDTOFromJSON(json) {
  return TagsDTOFromJSONTyped(json);
}
function TagsDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "count": json["count"] == null ? void 0 : json["count"],
    "tag": json["tag"] == null ? void 0 : json["tag"]
  };
}
function TagsDTOToJSON(json) {
  return TagsDTOToJSONTyped(json, false);
}
function TagsDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "count": value["count"],
    "tag": value["tag"]
  };
}

// models/FindTagsResult.ts
function instanceOfFindTagsResult(value) {
  return true;
}
function FindTagsResultFromJSON(json) {
  return FindTagsResultFromJSONTyped(json);
}
function FindTagsResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "tags": json["tags"] == null ? void 0 : json["tags"].map(TagsDTOFromJSON)
  };
}
function FindTagsResultToJSON(json) {
  return FindTagsResultToJSONTyped(json, false);
}
function FindTagsResultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "tags": value["tags"] == null ? void 0 : value["tags"].map(TagsDTOToJSON)
  };
}

// models/Span.ts
function instanceOfSpan(value) {
  return true;
}
function SpanFromJSON(json) {
  return SpanFromJSONTyped(json);
}
function SpanFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "length": json["Length"] == null ? void 0 : json["Length"],
    "offset": json["Offset"] == null ? void 0 : json["Offset"]
  };
}
function SpanToJSON(json) {
  return SpanToJSONTyped(json, false);
}
function SpanToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "Length": value["length"],
    "Offset": value["offset"]
  };
}

// models/FloatHistogram.ts
function instanceOfFloatHistogram(value) {
  return true;
}
function FloatHistogramFromJSON(json) {
  return FloatHistogramFromJSONTyped(json);
}
function FloatHistogramFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "count": json["Count"] == null ? void 0 : json["Count"],
    "counterResetHint": json["CounterResetHint"] == null ? void 0 : json["CounterResetHint"],
    "positiveBuckets": json["PositiveBuckets"] == null ? void 0 : json["PositiveBuckets"],
    "positiveSpans": json["PositiveSpans"] == null ? void 0 : json["PositiveSpans"].map(SpanFromJSON),
    "schema": json["Schema"] == null ? void 0 : json["Schema"],
    "sum": json["Sum"] == null ? void 0 : json["Sum"],
    "zeroCount": json["ZeroCount"] == null ? void 0 : json["ZeroCount"],
    "zeroThreshold": json["ZeroThreshold"] == null ? void 0 : json["ZeroThreshold"]
  };
}
function FloatHistogramToJSON(json) {
  return FloatHistogramToJSONTyped(json, false);
}
function FloatHistogramToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "Count": value["count"],
    "CounterResetHint": value["counterResetHint"],
    "PositiveBuckets": value["positiveBuckets"],
    "PositiveSpans": value["positiveSpans"] == null ? void 0 : value["positiveSpans"].map(SpanToJSON),
    "Schema": value["schema"],
    "Sum": value["sum"],
    "ZeroCount": value["zeroCount"],
    "ZeroThreshold": value["zeroThreshold"]
  };
}

// models/Folder.ts
function instanceOfFolder(value) {
  return true;
}
function FolderFromJSON(json) {
  return FolderFromJSONTyped(json);
}
function FolderFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "accessControl": json["accessControl"] == null ? void 0 : json["accessControl"],
    "canAdmin": json["canAdmin"] == null ? void 0 : json["canAdmin"],
    "canDelete": json["canDelete"] == null ? void 0 : json["canDelete"],
    "canEdit": json["canEdit"] == null ? void 0 : json["canEdit"],
    "canSave": json["canSave"] == null ? void 0 : json["canSave"],
    "created": json["created"] == null ? void 0 : new Date(json["created"]),
    "createdBy": json["createdBy"] == null ? void 0 : json["createdBy"],
    "hasAcl": json["hasAcl"] == null ? void 0 : json["hasAcl"],
    "id": json["id"] == null ? void 0 : json["id"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "parentUid": json["parentUid"] == null ? void 0 : json["parentUid"],
    "parents": json["parents"] == null ? void 0 : json["parents"].map(FolderFromJSON),
    "title": json["title"] == null ? void 0 : json["title"],
    "uid": json["uid"] == null ? void 0 : json["uid"],
    "updated": json["updated"] == null ? void 0 : new Date(json["updated"]),
    "updatedBy": json["updatedBy"] == null ? void 0 : json["updatedBy"],
    "url": json["url"] == null ? void 0 : json["url"],
    "version": json["version"] == null ? void 0 : json["version"]
  };
}
function FolderToJSON(json) {
  return FolderToJSONTyped(json, false);
}
function FolderToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "accessControl": value["accessControl"],
    "canAdmin": value["canAdmin"],
    "canDelete": value["canDelete"],
    "canEdit": value["canEdit"],
    "canSave": value["canSave"],
    "created": value["created"] == null ? void 0 : value["created"].toISOString(),
    "createdBy": value["createdBy"],
    "hasAcl": value["hasAcl"],
    "id": value["id"],
    "orgId": value["orgId"],
    "parentUid": value["parentUid"],
    "parents": value["parents"] == null ? void 0 : value["parents"].map(FolderToJSON),
    "title": value["title"],
    "uid": value["uid"],
    "updated": value["updated"] == null ? void 0 : value["updated"].toISOString(),
    "updatedBy": value["updatedBy"],
    "url": value["url"],
    "version": value["version"]
  };
}

// models/FolderSearchHit.ts
function instanceOfFolderSearchHit(value) {
  return true;
}
function FolderSearchHitFromJSON(json) {
  return FolderSearchHitFromJSONTyped(json);
}
function FolderSearchHitFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"] == null ? void 0 : json["id"],
    "parentUid": json["parentUid"] == null ? void 0 : json["parentUid"],
    "title": json["title"] == null ? void 0 : json["title"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function FolderSearchHitToJSON(json) {
  return FolderSearchHitToJSONTyped(json, false);
}
function FolderSearchHitToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "parentUid": value["parentUid"],
    "title": value["title"],
    "uid": value["uid"]
  };
}

// models/PublicError.ts
function instanceOfPublicError(value) {
  if (!("messageId" in value) || value["messageId"] === void 0) return false;
  if (!("statusCode" in value) || value["statusCode"] === void 0) return false;
  return true;
}
function PublicErrorFromJSON(json) {
  return PublicErrorFromJSONTyped(json);
}
function PublicErrorFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "extra": json["extra"] == null ? void 0 : json["extra"],
    "message": json["message"] == null ? void 0 : json["message"],
    "messageId": json["messageId"],
    "statusCode": json["statusCode"]
  };
}
function PublicErrorToJSON(json) {
  return PublicErrorToJSONTyped(json, false);
}
function PublicErrorToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "extra": value["extra"],
    "message": value["message"],
    "messageId": value["messageId"],
    "statusCode": value["statusCode"]
  };
}

// models/ForbiddenError.ts
function instanceOfForbiddenError(value) {
  return true;
}
function ForbiddenErrorFromJSON(json) {
  return ForbiddenErrorFromJSONTyped(json);
}
function ForbiddenErrorFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "body": json["body"] == null ? void 0 : PublicErrorFromJSON(json["body"])
  };
}
function ForbiddenErrorToJSON(json) {
  return ForbiddenErrorToJSONTyped(json, false);
}
function ForbiddenErrorToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "body": PublicErrorToJSON(value["body"])
  };
}

// models/GenericPublicError.ts
function instanceOfGenericPublicError(value) {
  return true;
}
function GenericPublicErrorFromJSON(json) {
  return GenericPublicErrorFromJSONTyped(json);
}
function GenericPublicErrorFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "body": json["body"] == null ? void 0 : PublicErrorFromJSON(json["body"])
  };
}
function GenericPublicErrorToJSON(json) {
  return GenericPublicErrorToJSONTyped(json, false);
}
function GenericPublicErrorToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "body": PublicErrorToJSON(value["body"])
  };
}

// models/GetAnnotationTagsResponse.ts
function instanceOfGetAnnotationTagsResponse(value) {
  return true;
}
function GetAnnotationTagsResponseFromJSON(json) {
  return GetAnnotationTagsResponseFromJSONTyped(json);
}
function GetAnnotationTagsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "result": json["result"] == null ? void 0 : FindTagsResultFromJSON(json["result"])
  };
}
function GetAnnotationTagsResponseToJSON(json) {
  return GetAnnotationTagsResponseToJSONTyped(json, false);
}
function GetAnnotationTagsResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "result": FindTagsResultToJSON(value["result"])
  };
}

// models/GetDataSourceIdByName200Response.ts
function instanceOfGetDataSourceIdByName200Response(value) {
  if (!("id" in value) || value["id"] === void 0) return false;
  return true;
}
function GetDataSourceIdByName200ResponseFromJSON(json) {
  return GetDataSourceIdByName200ResponseFromJSONTyped(json);
}
function GetDataSourceIdByName200ResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"]
  };
}
function GetDataSourceIdByName200ResponseToJSON(json) {
  return GetDataSourceIdByName200ResponseToJSONTyped(json, false);
}
function GetDataSourceIdByName200ResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"]
  };
}

// models/GetHomeDashboardResponse.ts
function instanceOfGetHomeDashboardResponse(value) {
  return true;
}
function GetHomeDashboardResponseFromJSON(json) {
  return GetHomeDashboardResponseFromJSONTyped(json);
}
function GetHomeDashboardResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "dashboard": json["dashboard"] == null ? void 0 : json["dashboard"],
    "meta": json["meta"] == null ? void 0 : DashboardMetaFromJSON(json["meta"]),
    "redirectUri": json["redirectUri"] == null ? void 0 : json["redirectUri"]
  };
}
function GetHomeDashboardResponseToJSON(json) {
  return GetHomeDashboardResponseToJSONTyped(json, false);
}
function GetHomeDashboardResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "dashboard": value["dashboard"],
    "meta": DashboardMetaToJSON(value["meta"]),
    "redirectUri": value["redirectUri"]
  };
}

// models/GetSharingOptions200Response.ts
function instanceOfGetSharingOptions200Response(value) {
  return true;
}
function GetSharingOptions200ResponseFromJSON(json) {
  return GetSharingOptions200ResponseFromJSONTyped(json);
}
function GetSharingOptions200ResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "externalEnabled": json["externalEnabled"] == null ? void 0 : json["externalEnabled"],
    "externalSnapshotName": json["externalSnapshotName"] == null ? void 0 : json["externalSnapshotName"],
    "externalSnapshotURL": json["externalSnapshotURL"] == null ? void 0 : json["externalSnapshotURL"]
  };
}
function GetSharingOptions200ResponseToJSON(json) {
  return GetSharingOptions200ResponseToJSONTyped(json, false);
}
function GetSharingOptions200ResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "externalEnabled": value["externalEnabled"],
    "externalSnapshotName": value["externalSnapshotName"],
    "externalSnapshotURL": value["externalSnapshotURL"]
  };
}

// models/GettableAlertmanagers.ts
function instanceOfGettableAlertmanagers(value) {
  return true;
}
function GettableAlertmanagersFromJSON(json) {
  return GettableAlertmanagersFromJSONTyped(json);
}
function GettableAlertmanagersFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "data": json["data"] == null ? void 0 : AlertManagersResultFromJSON(json["data"]),
    "status": json["status"] == null ? void 0 : json["status"]
  };
}
function GettableAlertmanagersToJSON(json) {
  return GettableAlertmanagersToJSONTyped(json, false);
}
function GettableAlertmanagersToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "data": AlertManagersResultToJSON(value["data"]),
    "status": value["status"]
  };
}

// models/WebexConfig.ts
function instanceOfWebexConfig(value) {
  return true;
}
function WebexConfigFromJSON(json) {
  return WebexConfigFromJSONTyped(json);
}
function WebexConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "apiUrl": json["api_url"] == null ? void 0 : URLFromJSON(json["api_url"]),
    "httpConfig": json["http_config"] == null ? void 0 : HTTPClientConfigFromJSON(json["http_config"]),
    "message": json["message"] == null ? void 0 : json["message"],
    "roomId": json["room_id"] == null ? void 0 : json["room_id"],
    "sendResolved": json["send_resolved"] == null ? void 0 : json["send_resolved"]
  };
}
function WebexConfigToJSON(json) {
  return WebexConfigToJSONTyped(json, false);
}
function WebexConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "api_url": URLToJSON(value["apiUrl"]),
    "http_config": HTTPClientConfigToJSON(value["httpConfig"]),
    "message": value["message"],
    "room_id": value["roomId"],
    "send_resolved": value["sendResolved"]
  };
}

// models/TelegramConfig.ts
function instanceOfTelegramConfig(value) {
  return true;
}
function TelegramConfigFromJSON(json) {
  return TelegramConfigFromJSONTyped(json);
}
function TelegramConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "apiUrl": json["api_url"] == null ? void 0 : URLFromJSON(json["api_url"]),
    "chat": json["chat"] == null ? void 0 : json["chat"],
    "disableNotifications": json["disable_notifications"] == null ? void 0 : json["disable_notifications"],
    "httpConfig": json["http_config"] == null ? void 0 : HTTPClientConfigFromJSON(json["http_config"]),
    "message": json["message"] == null ? void 0 : json["message"],
    "parseMode": json["parse_mode"] == null ? void 0 : json["parse_mode"],
    "sendResolved": json["send_resolved"] == null ? void 0 : json["send_resolved"],
    "token": json["token"] == null ? void 0 : json["token"],
    "tokenFile": json["token_file"] == null ? void 0 : json["token_file"]
  };
}
function TelegramConfigToJSON(json) {
  return TelegramConfigToJSONTyped(json, false);
}
function TelegramConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "api_url": URLToJSON(value["apiUrl"]),
    "chat": value["chat"],
    "disable_notifications": value["disableNotifications"],
    "http_config": HTTPClientConfigToJSON(value["httpConfig"]),
    "message": value["message"],
    "parse_mode": value["parseMode"],
    "send_resolved": value["sendResolved"],
    "token": value["token"],
    "token_file": value["tokenFile"]
  };
}

// models/GettableGrafanaReceiver.ts
function instanceOfGettableGrafanaReceiver(value) {
  return true;
}
function GettableGrafanaReceiverFromJSON(json) {
  return GettableGrafanaReceiverFromJSONTyped(json);
}
function GettableGrafanaReceiverFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "disableResolveMessage": json["disableResolveMessage"] == null ? void 0 : json["disableResolveMessage"],
    "name": json["name"] == null ? void 0 : json["name"],
    "provenance": json["provenance"] == null ? void 0 : json["provenance"],
    "secureFields": json["secureFields"] == null ? void 0 : json["secureFields"],
    "settings": json["settings"] == null ? void 0 : json["settings"],
    "type": json["type"] == null ? void 0 : json["type"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function GettableGrafanaReceiverToJSON(json) {
  return GettableGrafanaReceiverToJSONTyped(json, false);
}
function GettableGrafanaReceiverToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "disableResolveMessage": value["disableResolveMessage"],
    "name": value["name"],
    "provenance": value["provenance"],
    "secureFields": value["secureFields"],
    "settings": value["settings"],
    "type": value["type"],
    "uid": value["uid"]
  };
}

// models/SigV4Config.ts
function instanceOfSigV4Config(value) {
  return true;
}
function SigV4ConfigFromJSON(json) {
  return SigV4ConfigFromJSONTyped(json);
}
function SigV4ConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "accessKey": json["AccessKey"] == null ? void 0 : json["AccessKey"],
    "profile": json["Profile"] == null ? void 0 : json["Profile"],
    "region": json["Region"] == null ? void 0 : json["Region"],
    "roleARN": json["RoleARN"] == null ? void 0 : json["RoleARN"],
    "secretKey": json["SecretKey"] == null ? void 0 : json["SecretKey"]
  };
}
function SigV4ConfigToJSON(json) {
  return SigV4ConfigToJSONTyped(json, false);
}
function SigV4ConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "AccessKey": value["accessKey"],
    "Profile": value["profile"],
    "Region": value["region"],
    "RoleARN": value["roleARN"],
    "SecretKey": value["secretKey"]
  };
}

// models/SNSConfig.ts
function instanceOfSNSConfig(value) {
  return true;
}
function SNSConfigFromJSON(json) {
  return SNSConfigFromJSONTyped(json);
}
function SNSConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "apiUrl": json["api_url"] == null ? void 0 : json["api_url"],
    "attributes": json["attributes"] == null ? void 0 : json["attributes"],
    "httpConfig": json["http_config"] == null ? void 0 : HTTPClientConfigFromJSON(json["http_config"]),
    "message": json["message"] == null ? void 0 : json["message"],
    "phoneNumber": json["phone_number"] == null ? void 0 : json["phone_number"],
    "sendResolved": json["send_resolved"] == null ? void 0 : json["send_resolved"],
    "sigv4": json["sigv4"] == null ? void 0 : SigV4ConfigFromJSON(json["sigv4"]),
    "subject": json["subject"] == null ? void 0 : json["subject"],
    "targetArn": json["target_arn"] == null ? void 0 : json["target_arn"],
    "topicArn": json["topic_arn"] == null ? void 0 : json["topic_arn"]
  };
}
function SNSConfigToJSON(json) {
  return SNSConfigToJSONTyped(json, false);
}
function SNSConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "api_url": value["apiUrl"],
    "attributes": value["attributes"],
    "http_config": HTTPClientConfigToJSON(value["httpConfig"]),
    "message": value["message"],
    "phone_number": value["phoneNumber"],
    "send_resolved": value["sendResolved"],
    "sigv4": SigV4ConfigToJSON(value["sigv4"]),
    "subject": value["subject"],
    "target_arn": value["targetArn"],
    "topic_arn": value["topicArn"]
  };
}

// models/MSTeamsConfig.ts
function instanceOfMSTeamsConfig(value) {
  return true;
}
function MSTeamsConfigFromJSON(json) {
  return MSTeamsConfigFromJSONTyped(json);
}
function MSTeamsConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "httpConfig": json["http_config"] == null ? void 0 : HTTPClientConfigFromJSON(json["http_config"]),
    "sendResolved": json["send_resolved"] == null ? void 0 : json["send_resolved"],
    "summary": json["summary"] == null ? void 0 : json["summary"],
    "text": json["text"] == null ? void 0 : json["text"],
    "title": json["title"] == null ? void 0 : json["title"],
    "webhookUrl": json["webhook_url"] == null ? void 0 : URLFromJSON(json["webhook_url"]),
    "webhookUrlFile": json["webhook_url_file"] == null ? void 0 : json["webhook_url_file"]
  };
}
function MSTeamsConfigToJSON(json) {
  return MSTeamsConfigToJSONTyped(json, false);
}
function MSTeamsConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "http_config": HTTPClientConfigToJSON(value["httpConfig"]),
    "send_resolved": value["sendResolved"],
    "summary": value["summary"],
    "text": value["text"],
    "title": value["title"],
    "webhook_url": URLToJSON(value["webhookUrl"]),
    "webhook_url_file": value["webhookUrlFile"]
  };
}

// models/GettableApiReceiver.ts
function instanceOfGettableApiReceiver(value) {
  return true;
}
function GettableApiReceiverFromJSON(json) {
  return GettableApiReceiverFromJSONTyped(json);
}
function GettableApiReceiverFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "discordConfigs": json["discord_configs"] == null ? void 0 : json["discord_configs"].map(DiscordConfigFromJSON),
    "emailConfigs": json["email_configs"] == null ? void 0 : json["email_configs"].map(EmailConfigFromJSON),
    "grafanaManagedReceiverConfigs": json["grafana_managed_receiver_configs"] == null ? void 0 : json["grafana_managed_receiver_configs"].map(GettableGrafanaReceiverFromJSON),
    "msteamsConfigs": json["msteams_configs"] == null ? void 0 : json["msteams_configs"].map(MSTeamsConfigFromJSON),
    "name": json["name"] == null ? void 0 : json["name"],
    "opsgenieConfigs": json["opsgenie_configs"] == null ? void 0 : json["opsgenie_configs"].map(OpsGenieConfigFromJSON),
    "pagerdutyConfigs": json["pagerduty_configs"] == null ? void 0 : json["pagerduty_configs"].map(PagerdutyConfigFromJSON),
    "pushoverConfigs": json["pushover_configs"] == null ? void 0 : json["pushover_configs"].map(PushoverConfigFromJSON),
    "slackConfigs": json["slack_configs"] == null ? void 0 : json["slack_configs"].map(SlackConfigFromJSON),
    "snsConfigs": json["sns_configs"] == null ? void 0 : json["sns_configs"].map(SNSConfigFromJSON),
    "telegramConfigs": json["telegram_configs"] == null ? void 0 : json["telegram_configs"].map(TelegramConfigFromJSON),
    "victoropsConfigs": json["victorops_configs"] == null ? void 0 : json["victorops_configs"].map(VictorOpsConfigFromJSON),
    "webexConfigs": json["webex_configs"] == null ? void 0 : json["webex_configs"].map(WebexConfigFromJSON),
    "webhookConfigs": json["webhook_configs"] == null ? void 0 : json["webhook_configs"].map(WebhookConfigFromJSON),
    "wechatConfigs": json["wechat_configs"] == null ? void 0 : json["wechat_configs"].map(WechatConfigFromJSON)
  };
}
function GettableApiReceiverToJSON(json) {
  return GettableApiReceiverToJSONTyped(json, false);
}
function GettableApiReceiverToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "discord_configs": value["discordConfigs"] == null ? void 0 : value["discordConfigs"].map(DiscordConfigToJSON),
    "email_configs": value["emailConfigs"] == null ? void 0 : value["emailConfigs"].map(EmailConfigToJSON),
    "grafana_managed_receiver_configs": value["grafanaManagedReceiverConfigs"] == null ? void 0 : value["grafanaManagedReceiverConfigs"].map(GettableGrafanaReceiverToJSON),
    "msteams_configs": value["msteamsConfigs"] == null ? void 0 : value["msteamsConfigs"].map(MSTeamsConfigToJSON),
    "name": value["name"],
    "opsgenie_configs": value["opsgenieConfigs"] == null ? void 0 : value["opsgenieConfigs"].map(OpsGenieConfigToJSON),
    "pagerduty_configs": value["pagerdutyConfigs"] == null ? void 0 : value["pagerdutyConfigs"].map(PagerdutyConfigToJSON),
    "pushover_configs": value["pushoverConfigs"] == null ? void 0 : value["pushoverConfigs"].map(PushoverConfigToJSON),
    "slack_configs": value["slackConfigs"] == null ? void 0 : value["slackConfigs"].map(SlackConfigToJSON),
    "sns_configs": value["snsConfigs"] == null ? void 0 : value["snsConfigs"].map(SNSConfigToJSON),
    "telegram_configs": value["telegramConfigs"] == null ? void 0 : value["telegramConfigs"].map(TelegramConfigToJSON),
    "victorops_configs": value["victoropsConfigs"] == null ? void 0 : value["victoropsConfigs"].map(VictorOpsConfigToJSON),
    "webex_configs": value["webexConfigs"] == null ? void 0 : value["webexConfigs"].map(WebexConfigToJSON),
    "webhook_configs": value["webhookConfigs"] == null ? void 0 : value["webhookConfigs"].map(WebhookConfigToJSON),
    "wechat_configs": value["wechatConfigs"] == null ? void 0 : value["wechatConfigs"].map(WechatConfigToJSON)
  };
}

// models/GettableApiAlertingConfig.ts
function instanceOfGettableApiAlertingConfig(value) {
  return true;
}
function GettableApiAlertingConfigFromJSON(json) {
  return GettableApiAlertingConfigFromJSONTyped(json);
}
function GettableApiAlertingConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "global": json["global"] == null ? void 0 : GlobalConfigFromJSON(json["global"]),
    "inhibitRules": json["inhibit_rules"] == null ? void 0 : json["inhibit_rules"].map(InhibitRuleFromJSON),
    "muteTimeProvenances": json["muteTimeProvenances"] == null ? void 0 : json["muteTimeProvenances"],
    "muteTimeIntervals": json["mute_time_intervals"] == null ? void 0 : json["mute_time_intervals"].map(MuteTimeIntervalFromJSON),
    "receivers": json["receivers"] == null ? void 0 : json["receivers"].map(GettableApiReceiverFromJSON),
    "route": json["route"] == null ? void 0 : RouteFromJSON(json["route"]),
    "templates": json["templates"] == null ? void 0 : json["templates"],
    "timeIntervals": json["time_intervals"] == null ? void 0 : json["time_intervals"].map(TimeIntervalFromJSON)
  };
}
function GettableApiAlertingConfigToJSON(json) {
  return GettableApiAlertingConfigToJSONTyped(json, false);
}
function GettableApiAlertingConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "global": GlobalConfigToJSON(value["global"]),
    "inhibit_rules": value["inhibitRules"] == null ? void 0 : value["inhibitRules"].map(InhibitRuleToJSON),
    "muteTimeProvenances": value["muteTimeProvenances"],
    "mute_time_intervals": value["muteTimeIntervals"] == null ? void 0 : value["muteTimeIntervals"].map(MuteTimeIntervalToJSON),
    "receivers": value["receivers"] == null ? void 0 : value["receivers"].map(GettableApiReceiverToJSON),
    "route": RouteToJSON(value["route"]),
    "templates": value["templates"],
    "time_intervals": value["timeIntervals"] == null ? void 0 : value["timeIntervals"].map(TimeIntervalToJSON)
  };
}

// models/GettableGrafanaRule.ts
var GettableGrafanaRuleExecErrStateEnum = {
  Ok: "OK",
  Alerting: "Alerting",
  Error: "Error"
};
var GettableGrafanaRuleNoDataStateEnum = {
  Alerting: "Alerting",
  NoData: "NoData",
  Ok: "OK"
};
function instanceOfGettableGrafanaRule(value) {
  return true;
}
function GettableGrafanaRuleFromJSON(json) {
  return GettableGrafanaRuleFromJSONTyped(json);
}
function GettableGrafanaRuleFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "condition": json["condition"] == null ? void 0 : json["condition"],
    "data": json["data"] == null ? void 0 : json["data"].map(AlertQueryFromJSON),
    "execErrState": json["exec_err_state"] == null ? void 0 : json["exec_err_state"],
    "id": json["id"] == null ? void 0 : json["id"],
    "intervalSeconds": json["intervalSeconds"] == null ? void 0 : json["intervalSeconds"],
    "isPaused": json["is_paused"] == null ? void 0 : json["is_paused"],
    "namespaceUid": json["namespace_uid"] == null ? void 0 : json["namespace_uid"],
    "noDataState": json["no_data_state"] == null ? void 0 : json["no_data_state"],
    "notificationSettings": json["notification_settings"] == null ? void 0 : AlertRuleNotificationSettingsFromJSON(json["notification_settings"]),
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "provenance": json["provenance"] == null ? void 0 : json["provenance"],
    "ruleGroup": json["rule_group"] == null ? void 0 : json["rule_group"],
    "title": json["title"] == null ? void 0 : json["title"],
    "uid": json["uid"] == null ? void 0 : json["uid"],
    "updated": json["updated"] == null ? void 0 : new Date(json["updated"]),
    "version": json["version"] == null ? void 0 : json["version"]
  };
}
function GettableGrafanaRuleToJSON(json) {
  return GettableGrafanaRuleToJSONTyped(json, false);
}
function GettableGrafanaRuleToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "condition": value["condition"],
    "data": value["data"] == null ? void 0 : value["data"].map(AlertQueryToJSON),
    "exec_err_state": value["execErrState"],
    "id": value["id"],
    "intervalSeconds": value["intervalSeconds"],
    "is_paused": value["isPaused"],
    "namespace_uid": value["namespaceUid"],
    "no_data_state": value["noDataState"],
    "notification_settings": AlertRuleNotificationSettingsToJSON(value["notificationSettings"]),
    "orgId": value["orgId"],
    "provenance": value["provenance"],
    "rule_group": value["ruleGroup"],
    "title": value["title"],
    "uid": value["uid"],
    "updated": value["updated"] == null ? void 0 : value["updated"].toISOString(),
    "version": value["version"]
  };
}

// models/GettableExtendedRuleNode.ts
function instanceOfGettableExtendedRuleNode(value) {
  return true;
}
function GettableExtendedRuleNodeFromJSON(json) {
  return GettableExtendedRuleNodeFromJSONTyped(json);
}
function GettableExtendedRuleNodeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "alert": json["alert"] == null ? void 0 : json["alert"],
    "annotations": json["annotations"] == null ? void 0 : json["annotations"],
    "expr": json["expr"] == null ? void 0 : json["expr"],
    "_for": json["for"] == null ? void 0 : json["for"],
    "grafanaAlert": json["grafana_alert"] == null ? void 0 : GettableGrafanaRuleFromJSON(json["grafana_alert"]),
    "keepFiringFor": json["keep_firing_for"] == null ? void 0 : json["keep_firing_for"],
    "labels": json["labels"] == null ? void 0 : json["labels"],
    "record": json["record"] == null ? void 0 : json["record"]
  };
}
function GettableExtendedRuleNodeToJSON(json) {
  return GettableExtendedRuleNodeToJSONTyped(json, false);
}
function GettableExtendedRuleNodeToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "alert": value["alert"],
    "annotations": value["annotations"],
    "expr": value["expr"],
    "for": value["_for"],
    "grafana_alert": GettableGrafanaRuleToJSON(value["grafanaAlert"]),
    "keep_firing_for": value["keepFiringFor"],
    "labels": value["labels"],
    "record": value["record"]
  };
}

// models/GettableGrafanaReceivers.ts
function instanceOfGettableGrafanaReceivers(value) {
  return true;
}
function GettableGrafanaReceiversFromJSON(json) {
  return GettableGrafanaReceiversFromJSONTyped(json);
}
function GettableGrafanaReceiversFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "grafanaManagedReceiverConfigs": json["grafana_managed_receiver_configs"] == null ? void 0 : json["grafana_managed_receiver_configs"].map(GettableGrafanaReceiverFromJSON)
  };
}
function GettableGrafanaReceiversToJSON(json) {
  return GettableGrafanaReceiversToJSONTyped(json, false);
}
function GettableGrafanaReceiversToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "grafana_managed_receiver_configs": value["grafanaManagedReceiverConfigs"] == null ? void 0 : value["grafanaManagedReceiverConfigs"].map(GettableGrafanaReceiverToJSON)
  };
}

// models/GettableHistoricUserConfig.ts
function instanceOfGettableHistoricUserConfig(value) {
  return true;
}
function GettableHistoricUserConfigFromJSON(json) {
  return GettableHistoricUserConfigFromJSONTyped(json);
}
function GettableHistoricUserConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "alertmanagerConfig": json["alertmanager_config"] == null ? void 0 : GettableApiAlertingConfigFromJSON(json["alertmanager_config"]),
    "id": json["id"] == null ? void 0 : json["id"],
    "lastApplied": json["last_applied"] == null ? void 0 : new Date(json["last_applied"]),
    "templateFileProvenances": json["template_file_provenances"] == null ? void 0 : json["template_file_provenances"],
    "templateFiles": json["template_files"] == null ? void 0 : json["template_files"]
  };
}
function GettableHistoricUserConfigToJSON(json) {
  return GettableHistoricUserConfigToJSONTyped(json, false);
}
function GettableHistoricUserConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "alertmanager_config": GettableApiAlertingConfigToJSON(value["alertmanagerConfig"]),
    "id": value["id"],
    "last_applied": value["lastApplied"] == null ? void 0 : value["lastApplied"].toISOString(),
    "template_file_provenances": value["templateFileProvenances"],
    "template_files": value["templateFiles"]
  };
}

// models/GettableNGalertConfig.ts
var GettableNGalertConfigAlertmanagersChoiceEnum = {
  All: "all",
  Internal: "internal",
  External: "external"
};
function instanceOfGettableNGalertConfig(value) {
  return true;
}
function GettableNGalertConfigFromJSON(json) {
  return GettableNGalertConfigFromJSONTyped(json);
}
function GettableNGalertConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "alertmanagersChoice": json["alertmanagersChoice"] == null ? void 0 : json["alertmanagersChoice"]
  };
}
function GettableNGalertConfigToJSON(json) {
  return GettableNGalertConfigToJSONTyped(json, false);
}
function GettableNGalertConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "alertmanagersChoice": value["alertmanagersChoice"]
  };
}

// models/GettableRuleGroupConfig.ts
function instanceOfGettableRuleGroupConfig(value) {
  return true;
}
function GettableRuleGroupConfigFromJSON(json) {
  return GettableRuleGroupConfigFromJSONTyped(json);
}
function GettableRuleGroupConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "interval": json["interval"] == null ? void 0 : json["interval"],
    "name": json["name"] == null ? void 0 : json["name"],
    "rules": json["rules"] == null ? void 0 : json["rules"].map(GettableExtendedRuleNodeFromJSON),
    "sourceTenants": json["source_tenants"] == null ? void 0 : json["source_tenants"]
  };
}
function GettableRuleGroupConfigToJSON(json) {
  return GettableRuleGroupConfigToJSONTyped(json, false);
}
function GettableRuleGroupConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "interval": value["interval"],
    "name": value["name"],
    "rules": value["rules"] == null ? void 0 : value["rules"].map(GettableExtendedRuleNodeToJSON),
    "source_tenants": value["sourceTenants"]
  };
}

// models/SilenceStatus.ts
var SilenceStatusStateEnum = {
  ExpiredActivePending: "[expired active pending]"
};
function instanceOfSilenceStatus(value) {
  if (!("state" in value) || value["state"] === void 0) return false;
  return true;
}
function SilenceStatusFromJSON(json) {
  return SilenceStatusFromJSONTyped(json);
}
function SilenceStatusFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "state": json["state"]
  };
}
function SilenceStatusToJSON(json) {
  return SilenceStatusToJSONTyped(json, false);
}
function SilenceStatusToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "state": value["state"]
  };
}

// models/GettableSilence.ts
function instanceOfGettableSilence(value) {
  if (!("comment" in value) || value["comment"] === void 0) return false;
  if (!("createdBy" in value) || value["createdBy"] === void 0) return false;
  if (!("endsAt" in value) || value["endsAt"] === void 0) return false;
  if (!("id" in value) || value["id"] === void 0) return false;
  if (!("matchers" in value) || value["matchers"] === void 0) return false;
  if (!("startsAt" in value) || value["startsAt"] === void 0) return false;
  if (!("status" in value) || value["status"] === void 0) return false;
  if (!("updatedAt" in value) || value["updatedAt"] === void 0) return false;
  return true;
}
function GettableSilenceFromJSON(json) {
  return GettableSilenceFromJSONTyped(json);
}
function GettableSilenceFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "comment": json["comment"],
    "createdBy": json["createdBy"],
    "endsAt": new Date(json["endsAt"]),
    "id": json["id"],
    "matchers": json["matchers"].map(MatcherFromJSON),
    "startsAt": new Date(json["startsAt"]),
    "status": SilenceStatusFromJSON(json["status"]),
    "updatedAt": new Date(json["updatedAt"])
  };
}
function GettableSilenceToJSON(json) {
  return GettableSilenceToJSONTyped(json, false);
}
function GettableSilenceToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "comment": value["comment"],
    "createdBy": value["createdBy"],
    "endsAt": value["endsAt"].toISOString(),
    "id": value["id"],
    "matchers": value["matchers"].map(MatcherToJSON),
    "startsAt": value["startsAt"].toISOString(),
    "status": SilenceStatusToJSON(value["status"]),
    "updatedAt": value["updatedAt"].toISOString()
  };
}

// models/PostableApiReceiver.ts
function instanceOfPostableApiReceiver(value) {
  return true;
}
function PostableApiReceiverFromJSON(json) {
  return PostableApiReceiverFromJSONTyped(json);
}
function PostableApiReceiverFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "discordConfigs": json["discord_configs"] == null ? void 0 : json["discord_configs"].map(DiscordConfigFromJSON),
    "emailConfigs": json["email_configs"] == null ? void 0 : json["email_configs"].map(EmailConfigFromJSON),
    "grafanaManagedReceiverConfigs": json["grafana_managed_receiver_configs"] == null ? void 0 : json["grafana_managed_receiver_configs"].map(PostableGrafanaReceiverFromJSON),
    "msteamsConfigs": json["msteams_configs"] == null ? void 0 : json["msteams_configs"].map(MSTeamsConfigFromJSON),
    "name": json["name"] == null ? void 0 : json["name"],
    "opsgenieConfigs": json["opsgenie_configs"] == null ? void 0 : json["opsgenie_configs"].map(OpsGenieConfigFromJSON),
    "pagerdutyConfigs": json["pagerduty_configs"] == null ? void 0 : json["pagerduty_configs"].map(PagerdutyConfigFromJSON),
    "pushoverConfigs": json["pushover_configs"] == null ? void 0 : json["pushover_configs"].map(PushoverConfigFromJSON),
    "slackConfigs": json["slack_configs"] == null ? void 0 : json["slack_configs"].map(SlackConfigFromJSON),
    "snsConfigs": json["sns_configs"] == null ? void 0 : json["sns_configs"].map(SNSConfigFromJSON),
    "telegramConfigs": json["telegram_configs"] == null ? void 0 : json["telegram_configs"].map(TelegramConfigFromJSON),
    "victoropsConfigs": json["victorops_configs"] == null ? void 0 : json["victorops_configs"].map(VictorOpsConfigFromJSON),
    "webexConfigs": json["webex_configs"] == null ? void 0 : json["webex_configs"].map(WebexConfigFromJSON),
    "webhookConfigs": json["webhook_configs"] == null ? void 0 : json["webhook_configs"].map(WebhookConfigFromJSON),
    "wechatConfigs": json["wechat_configs"] == null ? void 0 : json["wechat_configs"].map(WechatConfigFromJSON)
  };
}
function PostableApiReceiverToJSON(json) {
  return PostableApiReceiverToJSONTyped(json, false);
}
function PostableApiReceiverToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "discord_configs": value["discordConfigs"] == null ? void 0 : value["discordConfigs"].map(DiscordConfigToJSON),
    "email_configs": value["emailConfigs"] == null ? void 0 : value["emailConfigs"].map(EmailConfigToJSON),
    "grafana_managed_receiver_configs": value["grafanaManagedReceiverConfigs"] == null ? void 0 : value["grafanaManagedReceiverConfigs"].map(PostableGrafanaReceiverToJSON),
    "msteams_configs": value["msteamsConfigs"] == null ? void 0 : value["msteamsConfigs"].map(MSTeamsConfigToJSON),
    "name": value["name"],
    "opsgenie_configs": value["opsgenieConfigs"] == null ? void 0 : value["opsgenieConfigs"].map(OpsGenieConfigToJSON),
    "pagerduty_configs": value["pagerdutyConfigs"] == null ? void 0 : value["pagerdutyConfigs"].map(PagerdutyConfigToJSON),
    "pushover_configs": value["pushoverConfigs"] == null ? void 0 : value["pushoverConfigs"].map(PushoverConfigToJSON),
    "slack_configs": value["slackConfigs"] == null ? void 0 : value["slackConfigs"].map(SlackConfigToJSON),
    "sns_configs": value["snsConfigs"] == null ? void 0 : value["snsConfigs"].map(SNSConfigToJSON),
    "telegram_configs": value["telegramConfigs"] == null ? void 0 : value["telegramConfigs"].map(TelegramConfigToJSON),
    "victorops_configs": value["victoropsConfigs"] == null ? void 0 : value["victoropsConfigs"].map(VictorOpsConfigToJSON),
    "webex_configs": value["webexConfigs"] == null ? void 0 : value["webexConfigs"].map(WebexConfigToJSON),
    "webhook_configs": value["webhookConfigs"] == null ? void 0 : value["webhookConfigs"].map(WebhookConfigToJSON),
    "wechat_configs": value["wechatConfigs"] == null ? void 0 : value["wechatConfigs"].map(WechatConfigToJSON)
  };
}

// models/PostableApiAlertingConfig.ts
function instanceOfPostableApiAlertingConfig(value) {
  return true;
}
function PostableApiAlertingConfigFromJSON(json) {
  return PostableApiAlertingConfigFromJSONTyped(json);
}
function PostableApiAlertingConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "global": json["global"] == null ? void 0 : GlobalConfigFromJSON(json["global"]),
    "inhibitRules": json["inhibit_rules"] == null ? void 0 : json["inhibit_rules"].map(InhibitRuleFromJSON),
    "muteTimeIntervals": json["mute_time_intervals"] == null ? void 0 : json["mute_time_intervals"].map(MuteTimeIntervalFromJSON),
    "receivers": json["receivers"] == null ? void 0 : json["receivers"].map(PostableApiReceiverFromJSON),
    "route": json["route"] == null ? void 0 : RouteFromJSON(json["route"]),
    "templates": json["templates"] == null ? void 0 : json["templates"],
    "timeIntervals": json["time_intervals"] == null ? void 0 : json["time_intervals"].map(TimeIntervalFromJSON)
  };
}
function PostableApiAlertingConfigToJSON(json) {
  return PostableApiAlertingConfigToJSONTyped(json, false);
}
function PostableApiAlertingConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "global": GlobalConfigToJSON(value["global"]),
    "inhibit_rules": value["inhibitRules"] == null ? void 0 : value["inhibitRules"].map(InhibitRuleToJSON),
    "mute_time_intervals": value["muteTimeIntervals"] == null ? void 0 : value["muteTimeIntervals"].map(MuteTimeIntervalToJSON),
    "receivers": value["receivers"] == null ? void 0 : value["receivers"].map(PostableApiReceiverToJSON),
    "route": RouteToJSON(value["route"]),
    "templates": value["templates"],
    "time_intervals": value["timeIntervals"] == null ? void 0 : value["timeIntervals"].map(TimeIntervalToJSON)
  };
}

// models/GettableStatus.ts
function instanceOfGettableStatus(value) {
  if (!("cluster" in value) || value["cluster"] === void 0) return false;
  if (!("config" in value) || value["config"] === void 0) return false;
  if (!("uptime" in value) || value["uptime"] === void 0) return false;
  if (!("versionInfo" in value) || value["versionInfo"] === void 0) return false;
  return true;
}
function GettableStatusFromJSON(json) {
  return GettableStatusFromJSONTyped(json);
}
function GettableStatusFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "cluster": ClusterStatusFromJSON(json["cluster"]),
    "config": PostableApiAlertingConfigFromJSON(json["config"]),
    "uptime": new Date(json["uptime"]),
    "versionInfo": VersionInfoFromJSON(json["versionInfo"])
  };
}
function GettableStatusToJSON(json) {
  return GettableStatusToJSONTyped(json, false);
}
function GettableStatusToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "cluster": ClusterStatusToJSON(value["cluster"]),
    "config": PostableApiAlertingConfigToJSON(value["config"]),
    "uptime": value["uptime"].toISOString(),
    "versionInfo": VersionInfoToJSON(value["versionInfo"])
  };
}

// models/TimeIntervalTimeRange.ts
function instanceOfTimeIntervalTimeRange(value) {
  return true;
}
function TimeIntervalTimeRangeFromJSON(json) {
  return TimeIntervalTimeRangeFromJSONTyped(json);
}
function TimeIntervalTimeRangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "endTime": json["end_time"] == null ? void 0 : json["end_time"],
    "startTime": json["start_time"] == null ? void 0 : json["start_time"]
  };
}
function TimeIntervalTimeRangeToJSON(json) {
  return TimeIntervalTimeRangeToJSONTyped(json, false);
}
function TimeIntervalTimeRangeToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "end_time": value["endTime"],
    "start_time": value["startTime"]
  };
}

// models/TimeIntervalItem.ts
function instanceOfTimeIntervalItem(value) {
  return true;
}
function TimeIntervalItemFromJSON(json) {
  return TimeIntervalItemFromJSONTyped(json);
}
function TimeIntervalItemFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "daysOfMonth": json["days_of_month"] == null ? void 0 : json["days_of_month"],
    "location": json["location"] == null ? void 0 : json["location"],
    "months": json["months"] == null ? void 0 : json["months"],
    "times": json["times"] == null ? void 0 : json["times"].map(TimeIntervalTimeRangeFromJSON),
    "weekdays": json["weekdays"] == null ? void 0 : json["weekdays"],
    "years": json["years"] == null ? void 0 : json["years"]
  };
}
function TimeIntervalItemToJSON(json) {
  return TimeIntervalItemToJSONTyped(json, false);
}
function TimeIntervalItemToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "days_of_month": value["daysOfMonth"],
    "location": value["location"],
    "months": value["months"],
    "times": value["times"] == null ? void 0 : value["times"].map(TimeIntervalTimeRangeToJSON),
    "weekdays": value["weekdays"],
    "years": value["years"]
  };
}

// models/GettableTimeIntervals.ts
function instanceOfGettableTimeIntervals(value) {
  return true;
}
function GettableTimeIntervalsFromJSON(json) {
  return GettableTimeIntervalsFromJSONTyped(json);
}
function GettableTimeIntervalsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "provenance": json["provenance"] == null ? void 0 : json["provenance"],
    "timeIntervals": json["time_intervals"] == null ? void 0 : json["time_intervals"].map(TimeIntervalItemFromJSON)
  };
}
function GettableTimeIntervalsToJSON(json) {
  return GettableTimeIntervalsToJSONTyped(json, false);
}
function GettableTimeIntervalsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "provenance": value["provenance"],
    "time_intervals": value["timeIntervals"] == null ? void 0 : value["timeIntervals"].map(TimeIntervalItemToJSON)
  };
}

// models/GettableUserConfig.ts
function instanceOfGettableUserConfig(value) {
  return true;
}
function GettableUserConfigFromJSON(json) {
  return GettableUserConfigFromJSONTyped(json);
}
function GettableUserConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "alertmanagerConfig": json["alertmanager_config"] == null ? void 0 : GettableApiAlertingConfigFromJSON(json["alertmanager_config"]),
    "templateFileProvenances": json["template_file_provenances"] == null ? void 0 : json["template_file_provenances"],
    "templateFiles": json["template_files"] == null ? void 0 : json["template_files"]
  };
}
function GettableUserConfigToJSON(json) {
  return GettableUserConfigToJSONTyped(json, false);
}
function GettableUserConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "alertmanager_config": GettableApiAlertingConfigToJSON(value["alertmanagerConfig"]),
    "template_file_provenances": value["templateFileProvenances"],
    "template_files": value["templateFiles"]
  };
}

// models/Hit.ts
function instanceOfHit(value) {
  return true;
}
function HitFromJSON(json) {
  return HitFromJSONTyped(json);
}
function HitFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "folderId": json["folderId"] == null ? void 0 : json["folderId"],
    "folderTitle": json["folderTitle"] == null ? void 0 : json["folderTitle"],
    "folderUid": json["folderUid"] == null ? void 0 : json["folderUid"],
    "folderUrl": json["folderUrl"] == null ? void 0 : json["folderUrl"],
    "id": json["id"] == null ? void 0 : json["id"],
    "isStarred": json["isStarred"] == null ? void 0 : json["isStarred"],
    "slug": json["slug"] == null ? void 0 : json["slug"],
    "sortMeta": json["sortMeta"] == null ? void 0 : json["sortMeta"],
    "sortMetaName": json["sortMetaName"] == null ? void 0 : json["sortMetaName"],
    "tags": json["tags"] == null ? void 0 : json["tags"],
    "title": json["title"] == null ? void 0 : json["title"],
    "type": json["type"] == null ? void 0 : json["type"],
    "uid": json["uid"] == null ? void 0 : json["uid"],
    "uri": json["uri"] == null ? void 0 : json["uri"],
    "url": json["url"] == null ? void 0 : json["url"]
  };
}
function HitToJSON(json) {
  return HitToJSONTyped(json, false);
}
function HitToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "folderId": value["folderId"],
    "folderTitle": value["folderTitle"],
    "folderUid": value["folderUid"],
    "folderUrl": value["folderUrl"],
    "id": value["id"],
    "isStarred": value["isStarred"],
    "slug": value["slug"],
    "sortMeta": value["sortMeta"],
    "sortMetaName": value["sortMetaName"],
    "tags": value["tags"],
    "title": value["title"],
    "type": value["type"],
    "uid": value["uid"],
    "uri": value["uri"],
    "url": value["url"]
  };
}

// models/ImportDashboardInput.ts
function instanceOfImportDashboardInput(value) {
  return true;
}
function ImportDashboardInputFromJSON(json) {
  return ImportDashboardInputFromJSONTyped(json);
}
function ImportDashboardInputFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "pluginId": json["pluginId"] == null ? void 0 : json["pluginId"],
    "type": json["type"] == null ? void 0 : json["type"],
    "value": json["value"] == null ? void 0 : json["value"]
  };
}
function ImportDashboardInputToJSON(json) {
  return ImportDashboardInputToJSONTyped(json, false);
}
function ImportDashboardInputToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "pluginId": value["pluginId"],
    "type": value["type"],
    "value": value["value"]
  };
}

// models/ImportDashboardRequest.ts
function instanceOfImportDashboardRequest(value) {
  return true;
}
function ImportDashboardRequestFromJSON(json) {
  return ImportDashboardRequestFromJSONTyped(json);
}
function ImportDashboardRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "dashboard": json["dashboard"] == null ? void 0 : json["dashboard"],
    "folderId": json["folderId"] == null ? void 0 : json["folderId"],
    "folderUid": json["folderUid"] == null ? void 0 : json["folderUid"],
    "inputs": json["inputs"] == null ? void 0 : json["inputs"].map(ImportDashboardInputFromJSON),
    "overwrite": json["overwrite"] == null ? void 0 : json["overwrite"],
    "path": json["path"] == null ? void 0 : json["path"],
    "pluginId": json["pluginId"] == null ? void 0 : json["pluginId"]
  };
}
function ImportDashboardRequestToJSON(json) {
  return ImportDashboardRequestToJSONTyped(json, false);
}
function ImportDashboardRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "dashboard": value["dashboard"],
    "folderId": value["folderId"],
    "folderUid": value["folderUid"],
    "inputs": value["inputs"] == null ? void 0 : value["inputs"].map(ImportDashboardInputToJSON),
    "overwrite": value["overwrite"],
    "path": value["path"],
    "pluginId": value["pluginId"]
  };
}

// models/ImportDashboardResponse.ts
function instanceOfImportDashboardResponse(value) {
  return true;
}
function ImportDashboardResponseFromJSON(json) {
  return ImportDashboardResponseFromJSONTyped(json);
}
function ImportDashboardResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "dashboardId": json["dashboardId"] == null ? void 0 : json["dashboardId"],
    "description": json["description"] == null ? void 0 : json["description"],
    "folderId": json["folderId"] == null ? void 0 : json["folderId"],
    "folderUid": json["folderUid"] == null ? void 0 : json["folderUid"],
    "imported": json["imported"] == null ? void 0 : json["imported"],
    "importedRevision": json["importedRevision"] == null ? void 0 : json["importedRevision"],
    "importedUri": json["importedUri"] == null ? void 0 : json["importedUri"],
    "importedUrl": json["importedUrl"] == null ? void 0 : json["importedUrl"],
    "path": json["path"] == null ? void 0 : json["path"],
    "pluginId": json["pluginId"] == null ? void 0 : json["pluginId"],
    "removed": json["removed"] == null ? void 0 : json["removed"],
    "revision": json["revision"] == null ? void 0 : json["revision"],
    "slug": json["slug"] == null ? void 0 : json["slug"],
    "title": json["title"] == null ? void 0 : json["title"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function ImportDashboardResponseToJSON(json) {
  return ImportDashboardResponseToJSONTyped(json, false);
}
function ImportDashboardResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "dashboardId": value["dashboardId"],
    "description": value["description"],
    "folderId": value["folderId"],
    "folderUid": value["folderUid"],
    "imported": value["imported"],
    "importedRevision": value["importedRevision"],
    "importedUri": value["importedUri"],
    "importedUrl": value["importedUrl"],
    "path": value["path"],
    "pluginId": value["pluginId"],
    "removed": value["removed"],
    "revision": value["revision"],
    "slug": value["slug"],
    "title": value["title"],
    "uid": value["uid"]
  };
}

// models/JSONWebKey.ts
function instanceOfJSONWebKey(value) {
  return true;
}
function JSONWebKeyFromJSON(json) {
  return JSONWebKeyFromJSONTyped(json);
}
function JSONWebKeyFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "algorithm": json["Algorithm"] == null ? void 0 : json["Algorithm"],
    "certificateThumbprintSHA1": json["CertificateThumbprintSHA1"] == null ? void 0 : json["CertificateThumbprintSHA1"],
    "certificateThumbprintSHA256": json["CertificateThumbprintSHA256"] == null ? void 0 : json["CertificateThumbprintSHA256"],
    "certificates": json["Certificates"] == null ? void 0 : json["Certificates"].map(CertificateFromJSON),
    "certificatesURL": json["CertificatesURL"] == null ? void 0 : URLFromJSON(json["CertificatesURL"]),
    "key": json["Key"] == null ? void 0 : json["Key"],
    "keyID": json["KeyID"] == null ? void 0 : json["KeyID"],
    "use": json["Use"] == null ? void 0 : json["Use"]
  };
}
function JSONWebKeyToJSON(json) {
  return JSONWebKeyToJSONTyped(json, false);
}
function JSONWebKeyToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "Algorithm": value["algorithm"],
    "CertificateThumbprintSHA1": value["certificateThumbprintSHA1"],
    "CertificateThumbprintSHA256": value["certificateThumbprintSHA256"],
    "Certificates": value["certificates"] == null ? void 0 : value["certificates"].map(CertificateToJSON),
    "CertificatesURL": URLToJSON(value["certificatesURL"]),
    "Key": value["key"],
    "KeyID": value["keyID"],
    "Use": value["use"]
  };
}

// models/Label.ts
function instanceOfLabel(value) {
  return true;
}
function LabelFromJSON(json) {
  return LabelFromJSONTyped(json);
}
function LabelFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["Name"] == null ? void 0 : json["Name"]
  };
}
function LabelToJSON(json) {
  return LabelToJSONTyped(json, false);
}
function LabelToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "Name": value["name"]
  };
}

// models/LibraryElementDTOMetaUser.ts
function instanceOfLibraryElementDTOMetaUser(value) {
  return true;
}
function LibraryElementDTOMetaUserFromJSON(json) {
  return LibraryElementDTOMetaUserFromJSONTyped(json);
}
function LibraryElementDTOMetaUserFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "avatarUrl": json["avatarUrl"] == null ? void 0 : json["avatarUrl"],
    "id": json["id"] == null ? void 0 : json["id"],
    "name": json["name"] == null ? void 0 : json["name"]
  };
}
function LibraryElementDTOMetaUserToJSON(json) {
  return LibraryElementDTOMetaUserToJSONTyped(json, false);
}
function LibraryElementDTOMetaUserToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "avatarUrl": value["avatarUrl"],
    "id": value["id"],
    "name": value["name"]
  };
}

// models/LibraryElementDTOMeta.ts
function instanceOfLibraryElementDTOMeta(value) {
  return true;
}
function LibraryElementDTOMetaFromJSON(json) {
  return LibraryElementDTOMetaFromJSONTyped(json);
}
function LibraryElementDTOMetaFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "connectedDashboards": json["connectedDashboards"] == null ? void 0 : json["connectedDashboards"],
    "created": json["created"] == null ? void 0 : new Date(json["created"]),
    "createdBy": json["createdBy"] == null ? void 0 : LibraryElementDTOMetaUserFromJSON(json["createdBy"]),
    "folderName": json["folderName"] == null ? void 0 : json["folderName"],
    "folderUid": json["folderUid"] == null ? void 0 : json["folderUid"],
    "updated": json["updated"] == null ? void 0 : new Date(json["updated"]),
    "updatedBy": json["updatedBy"] == null ? void 0 : LibraryElementDTOMetaUserFromJSON(json["updatedBy"])
  };
}
function LibraryElementDTOMetaToJSON(json) {
  return LibraryElementDTOMetaToJSONTyped(json, false);
}
function LibraryElementDTOMetaToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "connectedDashboards": value["connectedDashboards"],
    "created": value["created"] == null ? void 0 : value["created"].toISOString(),
    "createdBy": LibraryElementDTOMetaUserToJSON(value["createdBy"]),
    "folderName": value["folderName"],
    "folderUid": value["folderUid"],
    "updated": value["updated"] == null ? void 0 : value["updated"].toISOString(),
    "updatedBy": LibraryElementDTOMetaUserToJSON(value["updatedBy"])
  };
}

// models/LibraryElementDTO.ts
function instanceOfLibraryElementDTO(value) {
  return true;
}
function LibraryElementDTOFromJSON(json) {
  return LibraryElementDTOFromJSONTyped(json);
}
function LibraryElementDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "description": json["description"] == null ? void 0 : json["description"],
    "folderId": json["folderId"] == null ? void 0 : json["folderId"],
    "folderUid": json["folderUid"] == null ? void 0 : json["folderUid"],
    "id": json["id"] == null ? void 0 : json["id"],
    "kind": json["kind"] == null ? void 0 : json["kind"],
    "meta": json["meta"] == null ? void 0 : LibraryElementDTOMetaFromJSON(json["meta"]),
    "model": json["model"] == null ? void 0 : json["model"],
    "name": json["name"] == null ? void 0 : json["name"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "schemaVersion": json["schemaVersion"] == null ? void 0 : json["schemaVersion"],
    "type": json["type"] == null ? void 0 : json["type"],
    "uid": json["uid"] == null ? void 0 : json["uid"],
    "version": json["version"] == null ? void 0 : json["version"]
  };
}
function LibraryElementDTOToJSON(json) {
  return LibraryElementDTOToJSONTyped(json, false);
}
function LibraryElementDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "description": value["description"],
    "folderId": value["folderId"],
    "folderUid": value["folderUid"],
    "id": value["id"],
    "kind": value["kind"],
    "meta": LibraryElementDTOMetaToJSON(value["meta"]),
    "model": value["model"],
    "name": value["name"],
    "orgId": value["orgId"],
    "schemaVersion": value["schemaVersion"],
    "type": value["type"],
    "uid": value["uid"],
    "version": value["version"]
  };
}

// models/LibraryElementArrayResponse.ts
function instanceOfLibraryElementArrayResponse(value) {
  return true;
}
function LibraryElementArrayResponseFromJSON(json) {
  return LibraryElementArrayResponseFromJSONTyped(json);
}
function LibraryElementArrayResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "result": json["result"] == null ? void 0 : json["result"].map(LibraryElementDTOFromJSON)
  };
}
function LibraryElementArrayResponseToJSON(json) {
  return LibraryElementArrayResponseToJSONTyped(json, false);
}
function LibraryElementArrayResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "result": value["result"] == null ? void 0 : value["result"].map(LibraryElementDTOToJSON)
  };
}

// models/LibraryElementConnectionDTO.ts
function instanceOfLibraryElementConnectionDTO(value) {
  return true;
}
function LibraryElementConnectionDTOFromJSON(json) {
  return LibraryElementConnectionDTOFromJSONTyped(json);
}
function LibraryElementConnectionDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "connectionId": json["connectionId"] == null ? void 0 : json["connectionId"],
    "connectionUid": json["connectionUid"] == null ? void 0 : json["connectionUid"],
    "created": json["created"] == null ? void 0 : new Date(json["created"]),
    "createdBy": json["createdBy"] == null ? void 0 : LibraryElementDTOMetaUserFromJSON(json["createdBy"]),
    "elementId": json["elementId"] == null ? void 0 : json["elementId"],
    "id": json["id"] == null ? void 0 : json["id"],
    "kind": json["kind"] == null ? void 0 : json["kind"]
  };
}
function LibraryElementConnectionDTOToJSON(json) {
  return LibraryElementConnectionDTOToJSONTyped(json, false);
}
function LibraryElementConnectionDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "connectionId": value["connectionId"],
    "connectionUid": value["connectionUid"],
    "created": value["created"] == null ? void 0 : value["created"].toISOString(),
    "createdBy": LibraryElementDTOMetaUserToJSON(value["createdBy"]),
    "elementId": value["elementId"],
    "id": value["id"],
    "kind": value["kind"]
  };
}

// models/LibraryElementConnectionsResponse.ts
function instanceOfLibraryElementConnectionsResponse(value) {
  return true;
}
function LibraryElementConnectionsResponseFromJSON(json) {
  return LibraryElementConnectionsResponseFromJSONTyped(json);
}
function LibraryElementConnectionsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "result": json["result"] == null ? void 0 : json["result"].map(LibraryElementConnectionDTOFromJSON)
  };
}
function LibraryElementConnectionsResponseToJSON(json) {
  return LibraryElementConnectionsResponseToJSONTyped(json, false);
}
function LibraryElementConnectionsResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "result": value["result"] == null ? void 0 : value["result"].map(LibraryElementConnectionDTOToJSON)
  };
}

// models/LibraryElementResponse.ts
function instanceOfLibraryElementResponse(value) {
  return true;
}
function LibraryElementResponseFromJSON(json) {
  return LibraryElementResponseFromJSONTyped(json);
}
function LibraryElementResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "result": json["result"] == null ? void 0 : LibraryElementDTOFromJSON(json["result"])
  };
}
function LibraryElementResponseToJSON(json) {
  return LibraryElementResponseToJSONTyped(json, false);
}
function LibraryElementResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "result": LibraryElementDTOToJSON(value["result"])
  };
}

// models/LibraryElementSearchResult.ts
function instanceOfLibraryElementSearchResult(value) {
  return true;
}
function LibraryElementSearchResultFromJSON(json) {
  return LibraryElementSearchResultFromJSONTyped(json);
}
function LibraryElementSearchResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "elements": json["elements"] == null ? void 0 : json["elements"].map(LibraryElementDTOFromJSON),
    "page": json["page"] == null ? void 0 : json["page"],
    "perPage": json["perPage"] == null ? void 0 : json["perPage"],
    "totalCount": json["totalCount"] == null ? void 0 : json["totalCount"]
  };
}
function LibraryElementSearchResultToJSON(json) {
  return LibraryElementSearchResultToJSONTyped(json, false);
}
function LibraryElementSearchResultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "elements": value["elements"] == null ? void 0 : value["elements"].map(LibraryElementDTOToJSON),
    "page": value["page"],
    "perPage": value["perPage"],
    "totalCount": value["totalCount"]
  };
}

// models/LibraryElementSearchResponse.ts
function instanceOfLibraryElementSearchResponse(value) {
  return true;
}
function LibraryElementSearchResponseFromJSON(json) {
  return LibraryElementSearchResponseFromJSONTyped(json);
}
function LibraryElementSearchResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "result": json["result"] == null ? void 0 : LibraryElementSearchResultFromJSON(json["result"])
  };
}
function LibraryElementSearchResponseToJSON(json) {
  return LibraryElementSearchResponseToJSONTyped(json, false);
}
function LibraryElementSearchResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "result": LibraryElementSearchResultToJSON(value["result"])
  };
}

// models/ListAllProvidersSettings200ResponseInner.ts
function instanceOfListAllProvidersSettings200ResponseInner(value) {
  return true;
}
function ListAllProvidersSettings200ResponseInnerFromJSON(json) {
  return ListAllProvidersSettings200ResponseInnerFromJSONTyped(json);
}
function ListAllProvidersSettings200ResponseInnerFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"] == null ? void 0 : json["id"],
    "provider": json["provider"] == null ? void 0 : json["provider"],
    "settings": json["settings"] == null ? void 0 : json["settings"],
    "source": json["source"] == null ? void 0 : json["source"]
  };
}
function ListAllProvidersSettings200ResponseInnerToJSON(json) {
  return ListAllProvidersSettings200ResponseInnerToJSONTyped(json, false);
}
function ListAllProvidersSettings200ResponseInnerToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "provider": value["provider"],
    "settings": value["settings"],
    "source": value["source"]
  };
}

// models/ListSortOptions200Response.ts
function instanceOfListSortOptions200Response(value) {
  return true;
}
function ListSortOptions200ResponseFromJSON(json) {
  return ListSortOptions200ResponseFromJSONTyped(json);
}
function ListSortOptions200ResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "description": json["description"] == null ? void 0 : json["description"],
    "displayName": json["displayName"] == null ? void 0 : json["displayName"],
    "meta": json["meta"] == null ? void 0 : json["meta"],
    "name": json["name"] == null ? void 0 : json["name"]
  };
}
function ListSortOptions200ResponseToJSON(json) {
  return ListSortOptions200ResponseToJSONTyped(json, false);
}
function ListSortOptions200ResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "description": value["description"],
    "displayName": value["displayName"],
    "meta": value["meta"],
    "name": value["name"]
  };
}

// models/MassDeleteAnnotationsCmd.ts
function instanceOfMassDeleteAnnotationsCmd(value) {
  return true;
}
function MassDeleteAnnotationsCmdFromJSON(json) {
  return MassDeleteAnnotationsCmdFromJSONTyped(json);
}
function MassDeleteAnnotationsCmdFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "annotationId": json["annotationId"] == null ? void 0 : json["annotationId"],
    "dashboardId": json["dashboardId"] == null ? void 0 : json["dashboardId"],
    "dashboardUID": json["dashboardUID"] == null ? void 0 : json["dashboardUID"],
    "panelId": json["panelId"] == null ? void 0 : json["panelId"]
  };
}
function MassDeleteAnnotationsCmdToJSON(json) {
  return MassDeleteAnnotationsCmdToJSONTyped(json, false);
}
function MassDeleteAnnotationsCmdToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "annotationId": value["annotationId"],
    "dashboardId": value["dashboardId"],
    "dashboardUID": value["dashboardUID"],
    "panelId": value["panelId"]
  };
}

// models/MetricRequest.ts
function instanceOfMetricRequest(value) {
  if (!("from" in value) || value["from"] === void 0) return false;
  if (!("queries" in value) || value["queries"] === void 0) return false;
  if (!("to" in value) || value["to"] === void 0) return false;
  return true;
}
function MetricRequestFromJSON(json) {
  return MetricRequestFromJSONTyped(json);
}
function MetricRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "debug": json["debug"] == null ? void 0 : json["debug"],
    "from": json["from"],
    "queries": json["queries"],
    "to": json["to"]
  };
}
function MetricRequestToJSON(json) {
  return MetricRequestToJSONTyped(json, false);
}
function MetricRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "debug": value["debug"],
    "from": value["from"],
    "queries": value["queries"],
    "to": value["to"]
  };
}

// models/MoveFolderCommand.ts
function instanceOfMoveFolderCommand(value) {
  return true;
}
function MoveFolderCommandFromJSON(json) {
  return MoveFolderCommandFromJSONTyped(json);
}
function MoveFolderCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "parentUid": json["parentUid"] == null ? void 0 : json["parentUid"]
  };
}
function MoveFolderCommandToJSON(json) {
  return MoveFolderCommandToJSONTyped(json, false);
}
function MoveFolderCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "parentUid": value["parentUid"]
  };
}

// models/NewApiKeyResult.ts
function instanceOfNewApiKeyResult(value) {
  return true;
}
function NewApiKeyResultFromJSON(json) {
  return NewApiKeyResultFromJSONTyped(json);
}
function NewApiKeyResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"] == null ? void 0 : json["id"],
    "key": json["key"] == null ? void 0 : json["key"],
    "name": json["name"] == null ? void 0 : json["name"]
  };
}
function NewApiKeyResultToJSON(json) {
  return NewApiKeyResultToJSONTyped(json, false);
}
function NewApiKeyResultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "key": value["key"],
    "name": value["name"]
  };
}

// models/NotificationTemplate.ts
function instanceOfNotificationTemplate(value) {
  return true;
}
function NotificationTemplateFromJSON(json) {
  return NotificationTemplateFromJSONTyped(json);
}
function NotificationTemplateFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "provenance": json["provenance"] == null ? void 0 : json["provenance"],
    "template": json["template"] == null ? void 0 : json["template"]
  };
}
function NotificationTemplateToJSON(json) {
  return NotificationTemplateToJSONTyped(json, false);
}
function NotificationTemplateToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "provenance": value["provenance"],
    "template": value["template"]
  };
}

// models/NotificationTemplateContent.ts
function instanceOfNotificationTemplateContent(value) {
  return true;
}
function NotificationTemplateContentFromJSON(json) {
  return NotificationTemplateContentFromJSONTyped(json);
}
function NotificationTemplateContentFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "template": json["template"] == null ? void 0 : json["template"]
  };
}
function NotificationTemplateContentToJSON(json) {
  return NotificationTemplateContentToJSONTyped(json, false);
}
function NotificationTemplateContentToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "template": value["template"]
  };
}

// models/NotifierConfig.ts
function instanceOfNotifierConfig(value) {
  return true;
}
function NotifierConfigFromJSON(json) {
  return NotifierConfigFromJSONTyped(json);
}
function NotifierConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "sendResolved": json["send_resolved"] == null ? void 0 : json["send_resolved"]
  };
}
function NotifierConfigToJSON(json) {
  return NotifierConfigToJSONTyped(json, false);
}
function NotifierConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "send_resolved": value["sendResolved"]
  };
}

// models/OrgDTO.ts
function instanceOfOrgDTO(value) {
  return true;
}
function OrgDTOFromJSON(json) {
  return OrgDTOFromJSONTyped(json);
}
function OrgDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"] == null ? void 0 : json["id"],
    "name": json["name"] == null ? void 0 : json["name"]
  };
}
function OrgDTOToJSON(json) {
  return OrgDTOToJSONTyped(json, false);
}
function OrgDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "name": value["name"]
  };
}

// models/OrgDetailsDTO.ts
function instanceOfOrgDetailsDTO(value) {
  return true;
}
function OrgDetailsDTOFromJSON(json) {
  return OrgDetailsDTOFromJSONTyped(json);
}
function OrgDetailsDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "address": json["address"] == null ? void 0 : AddressFromJSON(json["address"]),
    "id": json["id"] == null ? void 0 : json["id"],
    "name": json["name"] == null ? void 0 : json["name"]
  };
}
function OrgDetailsDTOToJSON(json) {
  return OrgDetailsDTOToJSONTyped(json, false);
}
function OrgDetailsDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "address": AddressToJSON(value["address"]),
    "id": value["id"],
    "name": value["name"]
  };
}

// models/OrgUserDTO.ts
function instanceOfOrgUserDTO(value) {
  return true;
}
function OrgUserDTOFromJSON(json) {
  return OrgUserDTOFromJSONTyped(json);
}
function OrgUserDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "accessControl": json["accessControl"] == null ? void 0 : json["accessControl"],
    "authLabels": json["authLabels"] == null ? void 0 : json["authLabels"],
    "avatarUrl": json["avatarUrl"] == null ? void 0 : json["avatarUrl"],
    "email": json["email"] == null ? void 0 : json["email"],
    "isDisabled": json["isDisabled"] == null ? void 0 : json["isDisabled"],
    "isExternallySynced": json["isExternallySynced"] == null ? void 0 : json["isExternallySynced"],
    "lastSeenAt": json["lastSeenAt"] == null ? void 0 : new Date(json["lastSeenAt"]),
    "lastSeenAtAge": json["lastSeenAtAge"] == null ? void 0 : json["lastSeenAtAge"],
    "login": json["login"] == null ? void 0 : json["login"],
    "name": json["name"] == null ? void 0 : json["name"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "role": json["role"] == null ? void 0 : json["role"],
    "userId": json["userId"] == null ? void 0 : json["userId"]
  };
}
function OrgUserDTOToJSON(json) {
  return OrgUserDTOToJSONTyped(json, false);
}
function OrgUserDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "accessControl": value["accessControl"],
    "authLabels": value["authLabels"],
    "avatarUrl": value["avatarUrl"],
    "email": value["email"],
    "isDisabled": value["isDisabled"],
    "isExternallySynced": value["isExternallySynced"],
    "lastSeenAt": value["lastSeenAt"] == null ? void 0 : value["lastSeenAt"].toISOString(),
    "lastSeenAtAge": value["lastSeenAtAge"],
    "login": value["login"],
    "name": value["name"],
    "orgId": value["orgId"],
    "role": value["role"],
    "userId": value["userId"]
  };
}

// models/PatchAnnotationsCmd.ts
function instanceOfPatchAnnotationsCmd(value) {
  return true;
}
function PatchAnnotationsCmdFromJSON(json) {
  return PatchAnnotationsCmdFromJSONTyped(json);
}
function PatchAnnotationsCmdFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "data": json["data"] == null ? void 0 : json["data"],
    "id": json["id"] == null ? void 0 : json["id"],
    "tags": json["tags"] == null ? void 0 : json["tags"],
    "text": json["text"] == null ? void 0 : json["text"],
    "time": json["time"] == null ? void 0 : json["time"],
    "timeEnd": json["timeEnd"] == null ? void 0 : json["timeEnd"]
  };
}
function PatchAnnotationsCmdToJSON(json) {
  return PatchAnnotationsCmdToJSONTyped(json, false);
}
function PatchAnnotationsCmdToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "data": value["data"],
    "id": value["id"],
    "tags": value["tags"],
    "text": value["text"],
    "time": value["time"],
    "timeEnd": value["timeEnd"]
  };
}

// models/PatchLibraryElementCommand.ts
var PatchLibraryElementCommandKindEnum = {
  NUMBER_1: 1,
  NUMBER_2: 2
};
function instanceOfPatchLibraryElementCommand(value) {
  return true;
}
function PatchLibraryElementCommandFromJSON(json) {
  return PatchLibraryElementCommandFromJSONTyped(json);
}
function PatchLibraryElementCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "folderId": json["folderId"] == null ? void 0 : json["folderId"],
    "folderUid": json["folderUid"] == null ? void 0 : json["folderUid"],
    "kind": json["kind"] == null ? void 0 : json["kind"],
    "model": json["model"] == null ? void 0 : json["model"],
    "name": json["name"] == null ? void 0 : json["name"],
    "uid": json["uid"] == null ? void 0 : json["uid"],
    "version": json["version"] == null ? void 0 : json["version"]
  };
}
function PatchLibraryElementCommandToJSON(json) {
  return PatchLibraryElementCommandToJSONTyped(json, false);
}
function PatchLibraryElementCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "folderId": value["folderId"],
    "folderUid": value["folderUid"],
    "kind": value["kind"],
    "model": value["model"],
    "name": value["name"],
    "uid": value["uid"],
    "version": value["version"]
  };
}

// models/QueryHistoryPreference.ts
function instanceOfQueryHistoryPreference(value) {
  return true;
}
function QueryHistoryPreferenceFromJSON(json) {
  return QueryHistoryPreferenceFromJSONTyped(json);
}
function QueryHistoryPreferenceFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "homeTab": json["homeTab"] == null ? void 0 : json["homeTab"]
  };
}
function QueryHistoryPreferenceToJSON(json) {
  return QueryHistoryPreferenceToJSONTyped(json, false);
}
function QueryHistoryPreferenceToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "homeTab": value["homeTab"]
  };
}

// models/PatchPrefsCmd.ts
var PatchPrefsCmdThemeEnum = {
  Light: "light",
  Dark: "dark"
};
var PatchPrefsCmdTimezoneEnum = {
  Utc: "utc",
  Browser: "browser"
};
function instanceOfPatchPrefsCmd(value) {
  return true;
}
function PatchPrefsCmdFromJSON(json) {
  return PatchPrefsCmdFromJSONTyped(json);
}
function PatchPrefsCmdFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "cookies": json["cookies"] == null ? void 0 : json["cookies"],
    "homeDashboardId": json["homeDashboardId"] == null ? void 0 : json["homeDashboardId"],
    "homeDashboardUID": json["homeDashboardUID"] == null ? void 0 : json["homeDashboardUID"],
    "language": json["language"] == null ? void 0 : json["language"],
    "queryHistory": json["queryHistory"] == null ? void 0 : QueryHistoryPreferenceFromJSON(json["queryHistory"]),
    "theme": json["theme"] == null ? void 0 : json["theme"],
    "timezone": json["timezone"] == null ? void 0 : json["timezone"],
    "weekStart": json["weekStart"] == null ? void 0 : json["weekStart"]
  };
}
function PatchPrefsCmdToJSON(json) {
  return PatchPrefsCmdToJSONTyped(json, false);
}
function PatchPrefsCmdToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "cookies": value["cookies"],
    "homeDashboardId": value["homeDashboardId"],
    "homeDashboardUID": value["homeDashboardUID"],
    "language": value["language"],
    "queryHistory": QueryHistoryPreferenceToJSON(value["queryHistory"]),
    "theme": value["theme"],
    "timezone": value["timezone"],
    "weekStart": value["weekStart"]
  };
}

// models/PatchQueryCommentInQueryHistoryCommand.ts
function instanceOfPatchQueryCommentInQueryHistoryCommand(value) {
  return true;
}
function PatchQueryCommentInQueryHistoryCommandFromJSON(json) {
  return PatchQueryCommentInQueryHistoryCommandFromJSONTyped(json);
}
function PatchQueryCommentInQueryHistoryCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "comment": json["comment"] == null ? void 0 : json["comment"]
  };
}
function PatchQueryCommentInQueryHistoryCommandToJSON(json) {
  return PatchQueryCommentInQueryHistoryCommandToJSONTyped(json, false);
}
function PatchQueryCommentInQueryHistoryCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "comment": value["comment"]
  };
}

// models/Playlist.ts
function instanceOfPlaylist(value) {
  return true;
}
function PlaylistFromJSON(json) {
  return PlaylistFromJSONTyped(json);
}
function PlaylistFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"] == null ? void 0 : json["id"],
    "interval": json["interval"] == null ? void 0 : json["interval"],
    "name": json["name"] == null ? void 0 : json["name"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function PlaylistToJSON(json) {
  return PlaylistToJSONTyped(json, false);
}
function PlaylistToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "interval": value["interval"],
    "name": value["name"],
    "uid": value["uid"]
  };
}

// models/PlaylistItemDTO.ts
function instanceOfPlaylistItemDTO(value) {
  return true;
}
function PlaylistItemDTOFromJSON(json) {
  return PlaylistItemDTOFromJSONTyped(json);
}
function PlaylistItemDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "title": json["title"] == null ? void 0 : json["title"],
    "type": json["type"] == null ? void 0 : json["type"],
    "value": json["value"] == null ? void 0 : json["value"]
  };
}
function PlaylistItemDTOToJSON(json) {
  return PlaylistItemDTOToJSONTyped(json, false);
}
function PlaylistItemDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "title": value["title"],
    "type": value["type"],
    "value": value["value"]
  };
}

// models/PlaylistDTO.ts
function instanceOfPlaylistDTO(value) {
  return true;
}
function PlaylistDTOFromJSON(json) {
  return PlaylistDTOFromJSONTyped(json);
}
function PlaylistDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "interval": json["interval"] == null ? void 0 : json["interval"],
    "items": json["items"] == null ? void 0 : json["items"].map(PlaylistItemDTOFromJSON),
    "name": json["name"] == null ? void 0 : json["name"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function PlaylistDTOToJSON(json) {
  return PlaylistDTOToJSONTyped(json, false);
}
function PlaylistDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "interval": value["interval"],
    "items": value["items"] == null ? void 0 : value["items"].map(PlaylistItemDTOToJSON),
    "name": value["name"],
    "uid": value["uid"]
  };
}

// models/PlaylistDashboard.ts
function instanceOfPlaylistDashboard(value) {
  return true;
}
function PlaylistDashboardFromJSON(json) {
  return PlaylistDashboardFromJSONTyped(json);
}
function PlaylistDashboardFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"] == null ? void 0 : json["id"],
    "order": json["order"] == null ? void 0 : json["order"],
    "slug": json["slug"] == null ? void 0 : json["slug"],
    "title": json["title"] == null ? void 0 : json["title"],
    "uri": json["uri"] == null ? void 0 : json["uri"],
    "url": json["url"] == null ? void 0 : json["url"]
  };
}
function PlaylistDashboardToJSON(json) {
  return PlaylistDashboardToJSONTyped(json, false);
}
function PlaylistDashboardToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "order": value["order"],
    "slug": value["slug"],
    "title": value["title"],
    "uri": value["uri"],
    "url": value["url"]
  };
}

// models/PostAnnotation200Response.ts
function instanceOfPostAnnotation200Response(value) {
  if (!("id" in value) || value["id"] === void 0) return false;
  if (!("message" in value) || value["message"] === void 0) return false;
  return true;
}
function PostAnnotation200ResponseFromJSON(json) {
  return PostAnnotation200ResponseFromJSONTyped(json);
}
function PostAnnotation200ResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "message": json["message"]
  };
}
function PostAnnotation200ResponseToJSON(json) {
  return PostAnnotation200ResponseToJSONTyped(json, false);
}
function PostAnnotation200ResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "message": value["message"]
  };
}

// models/PostAnnotationsCmd.ts
function instanceOfPostAnnotationsCmd(value) {
  if (!("text" in value) || value["text"] === void 0) return false;
  return true;
}
function PostAnnotationsCmdFromJSON(json) {
  return PostAnnotationsCmdFromJSONTyped(json);
}
function PostAnnotationsCmdFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "dashboardId": json["dashboardId"] == null ? void 0 : json["dashboardId"],
    "dashboardUID": json["dashboardUID"] == null ? void 0 : json["dashboardUID"],
    "data": json["data"] == null ? void 0 : json["data"],
    "panelId": json["panelId"] == null ? void 0 : json["panelId"],
    "tags": json["tags"] == null ? void 0 : json["tags"],
    "text": json["text"],
    "time": json["time"] == null ? void 0 : json["time"],
    "timeEnd": json["timeEnd"] == null ? void 0 : json["timeEnd"]
  };
}
function PostAnnotationsCmdToJSON(json) {
  return PostAnnotationsCmdToJSONTyped(json, false);
}
function PostAnnotationsCmdToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "dashboardId": value["dashboardId"],
    "dashboardUID": value["dashboardUID"],
    "data": value["data"],
    "panelId": value["panelId"],
    "tags": value["tags"],
    "text": value["text"],
    "time": value["time"],
    "timeEnd": value["timeEnd"]
  };
}

// models/PostDashboard200Response.ts
function instanceOfPostDashboard200Response(value) {
  if (!("id" in value) || value["id"] === void 0) return false;
  if (!("status" in value) || value["status"] === void 0) return false;
  if (!("title" in value) || value["title"] === void 0) return false;
  if (!("uid" in value) || value["uid"] === void 0) return false;
  if (!("url" in value) || value["url"] === void 0) return false;
  if (!("version" in value) || value["version"] === void 0) return false;
  return true;
}
function PostDashboard200ResponseFromJSON(json) {
  return PostDashboard200ResponseFromJSONTyped(json);
}
function PostDashboard200ResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "folderUid": json["folderUid"] == null ? void 0 : json["folderUid"],
    "id": json["id"],
    "status": json["status"],
    "title": json["title"],
    "uid": json["uid"],
    "url": json["url"],
    "version": json["version"]
  };
}
function PostDashboard200ResponseToJSON(json) {
  return PostDashboard200ResponseToJSONTyped(json, false);
}
function PostDashboard200ResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "folderUid": value["folderUid"],
    "id": value["id"],
    "status": value["status"],
    "title": value["title"],
    "uid": value["uid"],
    "url": value["url"],
    "version": value["version"]
  };
}

// models/PostGraphiteAnnotationsCmd.ts
function instanceOfPostGraphiteAnnotationsCmd(value) {
  return true;
}
function PostGraphiteAnnotationsCmdFromJSON(json) {
  return PostGraphiteAnnotationsCmdFromJSONTyped(json);
}
function PostGraphiteAnnotationsCmdFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "data": json["data"] == null ? void 0 : json["data"],
    "tags": json["tags"] == null ? void 0 : json["tags"],
    "what": json["what"] == null ? void 0 : json["what"],
    "when": json["when"] == null ? void 0 : json["when"]
  };
}
function PostGraphiteAnnotationsCmdToJSON(json) {
  return PostGraphiteAnnotationsCmdToJSONTyped(json, false);
}
function PostGraphiteAnnotationsCmdToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "data": value["data"],
    "tags": value["tags"],
    "what": value["what"],
    "when": value["when"]
  };
}

// models/PostSilencesOKBody.ts
function instanceOfPostSilencesOKBody(value) {
  return true;
}
function PostSilencesOKBodyFromJSON(json) {
  return PostSilencesOKBodyFromJSONTyped(json);
}
function PostSilencesOKBodyFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "silenceID": json["silenceID"] == null ? void 0 : json["silenceID"]
  };
}
function PostSilencesOKBodyToJSON(json) {
  return PostSilencesOKBodyToJSONTyped(json, false);
}
function PostSilencesOKBodyToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "silenceID": value["silenceID"]
  };
}

// models/PostableAlert.ts
function instanceOfPostableAlert(value) {
  if (!("labels" in value) || value["labels"] === void 0) return false;
  return true;
}
function PostableAlertFromJSON(json) {
  return PostableAlertFromJSONTyped(json);
}
function PostableAlertFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "annotations": json["annotations"] == null ? void 0 : json["annotations"],
    "endsAt": json["endsAt"] == null ? void 0 : new Date(json["endsAt"]),
    "generatorURL": json["generatorURL"] == null ? void 0 : json["generatorURL"],
    "labels": json["labels"],
    "startsAt": json["startsAt"] == null ? void 0 : new Date(json["startsAt"])
  };
}
function PostableAlertToJSON(json) {
  return PostableAlertToJSONTyped(json, false);
}
function PostableAlertToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "annotations": value["annotations"],
    "endsAt": value["endsAt"] == null ? void 0 : value["endsAt"].toISOString(),
    "generatorURL": value["generatorURL"],
    "labels": value["labels"],
    "startsAt": value["startsAt"] == null ? void 0 : value["startsAt"].toISOString()
  };
}

// models/PostableGrafanaRule.ts
var PostableGrafanaRuleExecErrStateEnum = {
  Ok: "OK",
  Alerting: "Alerting",
  Error: "Error"
};
var PostableGrafanaRuleNoDataStateEnum = {
  Alerting: "Alerting",
  NoData: "NoData",
  Ok: "OK"
};
function instanceOfPostableGrafanaRule(value) {
  return true;
}
function PostableGrafanaRuleFromJSON(json) {
  return PostableGrafanaRuleFromJSONTyped(json);
}
function PostableGrafanaRuleFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "condition": json["condition"] == null ? void 0 : json["condition"],
    "data": json["data"] == null ? void 0 : json["data"].map(AlertQueryFromJSON),
    "execErrState": json["exec_err_state"] == null ? void 0 : json["exec_err_state"],
    "isPaused": json["is_paused"] == null ? void 0 : json["is_paused"],
    "noDataState": json["no_data_state"] == null ? void 0 : json["no_data_state"],
    "notificationSettings": json["notification_settings"] == null ? void 0 : AlertRuleNotificationSettingsFromJSON(json["notification_settings"]),
    "title": json["title"] == null ? void 0 : json["title"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function PostableGrafanaRuleToJSON(json) {
  return PostableGrafanaRuleToJSONTyped(json, false);
}
function PostableGrafanaRuleToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "condition": value["condition"],
    "data": value["data"] == null ? void 0 : value["data"].map(AlertQueryToJSON),
    "exec_err_state": value["execErrState"],
    "is_paused": value["isPaused"],
    "no_data_state": value["noDataState"],
    "notification_settings": AlertRuleNotificationSettingsToJSON(value["notificationSettings"]),
    "title": value["title"],
    "uid": value["uid"]
  };
}

// models/PostableExtendedRuleNode.ts
function instanceOfPostableExtendedRuleNode(value) {
  return true;
}
function PostableExtendedRuleNodeFromJSON(json) {
  return PostableExtendedRuleNodeFromJSONTyped(json);
}
function PostableExtendedRuleNodeFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "alert": json["alert"] == null ? void 0 : json["alert"],
    "annotations": json["annotations"] == null ? void 0 : json["annotations"],
    "expr": json["expr"] == null ? void 0 : json["expr"],
    "_for": json["for"] == null ? void 0 : json["for"],
    "grafanaAlert": json["grafana_alert"] == null ? void 0 : PostableGrafanaRuleFromJSON(json["grafana_alert"]),
    "keepFiringFor": json["keep_firing_for"] == null ? void 0 : json["keep_firing_for"],
    "labels": json["labels"] == null ? void 0 : json["labels"],
    "record": json["record"] == null ? void 0 : json["record"]
  };
}
function PostableExtendedRuleNodeToJSON(json) {
  return PostableExtendedRuleNodeToJSONTyped(json, false);
}
function PostableExtendedRuleNodeToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "alert": value["alert"],
    "annotations": value["annotations"],
    "expr": value["expr"],
    "for": value["_for"],
    "grafana_alert": PostableGrafanaRuleToJSON(value["grafanaAlert"]),
    "keep_firing_for": value["keepFiringFor"],
    "labels": value["labels"],
    "record": value["record"]
  };
}

// models/PostableExtendedRuleNodeExtended.ts
function instanceOfPostableExtendedRuleNodeExtended(value) {
  if (!("rule" in value) || value["rule"] === void 0) return false;
  return true;
}
function PostableExtendedRuleNodeExtendedFromJSON(json) {
  return PostableExtendedRuleNodeExtendedFromJSONTyped(json);
}
function PostableExtendedRuleNodeExtendedFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "folderTitle": json["folderTitle"] == null ? void 0 : json["folderTitle"],
    "folderUid": json["folderUid"] == null ? void 0 : json["folderUid"],
    "rule": PostableExtendedRuleNodeFromJSON(json["rule"]),
    "ruleGroup": json["ruleGroup"] == null ? void 0 : json["ruleGroup"]
  };
}
function PostableExtendedRuleNodeExtendedToJSON(json) {
  return PostableExtendedRuleNodeExtendedToJSONTyped(json, false);
}
function PostableExtendedRuleNodeExtendedToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "folderTitle": value["folderTitle"],
    "folderUid": value["folderUid"],
    "rule": PostableExtendedRuleNodeToJSON(value["rule"]),
    "ruleGroup": value["ruleGroup"]
  };
}

// models/PostableGrafanaReceivers.ts
function instanceOfPostableGrafanaReceivers(value) {
  return true;
}
function PostableGrafanaReceiversFromJSON(json) {
  return PostableGrafanaReceiversFromJSONTyped(json);
}
function PostableGrafanaReceiversFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "grafanaManagedReceiverConfigs": json["grafana_managed_receiver_configs"] == null ? void 0 : json["grafana_managed_receiver_configs"].map(PostableGrafanaReceiverFromJSON)
  };
}
function PostableGrafanaReceiversToJSON(json) {
  return PostableGrafanaReceiversToJSONTyped(json, false);
}
function PostableGrafanaReceiversToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "grafana_managed_receiver_configs": value["grafanaManagedReceiverConfigs"] == null ? void 0 : value["grafanaManagedReceiverConfigs"].map(PostableGrafanaReceiverToJSON)
  };
}

// models/PostableNGalertConfig.ts
var PostableNGalertConfigAlertmanagersChoiceEnum = {
  All: "all",
  Internal: "internal",
  External: "external"
};
function instanceOfPostableNGalertConfig(value) {
  return true;
}
function PostableNGalertConfigFromJSON(json) {
  return PostableNGalertConfigFromJSONTyped(json);
}
function PostableNGalertConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "alertmanagersChoice": json["alertmanagersChoice"] == null ? void 0 : json["alertmanagersChoice"]
  };
}
function PostableNGalertConfigToJSON(json) {
  return PostableNGalertConfigToJSONTyped(json, false);
}
function PostableNGalertConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "alertmanagersChoice": value["alertmanagersChoice"]
  };
}

// models/PostableRuleGroupConfig.ts
function instanceOfPostableRuleGroupConfig(value) {
  return true;
}
function PostableRuleGroupConfigFromJSON(json) {
  return PostableRuleGroupConfigFromJSONTyped(json);
}
function PostableRuleGroupConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "interval": json["interval"] == null ? void 0 : json["interval"],
    "name": json["name"] == null ? void 0 : json["name"],
    "rules": json["rules"] == null ? void 0 : json["rules"].map(PostableExtendedRuleNodeFromJSON)
  };
}
function PostableRuleGroupConfigToJSON(json) {
  return PostableRuleGroupConfigToJSONTyped(json, false);
}
function PostableRuleGroupConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "interval": value["interval"],
    "name": value["name"],
    "rules": value["rules"] == null ? void 0 : value["rules"].map(PostableExtendedRuleNodeToJSON)
  };
}

// models/PostableSilence.ts
function instanceOfPostableSilence(value) {
  if (!("comment" in value) || value["comment"] === void 0) return false;
  if (!("createdBy" in value) || value["createdBy"] === void 0) return false;
  if (!("endsAt" in value) || value["endsAt"] === void 0) return false;
  if (!("matchers" in value) || value["matchers"] === void 0) return false;
  if (!("startsAt" in value) || value["startsAt"] === void 0) return false;
  return true;
}
function PostableSilenceFromJSON(json) {
  return PostableSilenceFromJSONTyped(json);
}
function PostableSilenceFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "comment": json["comment"],
    "createdBy": json["createdBy"],
    "endsAt": new Date(json["endsAt"]),
    "id": json["id"] == null ? void 0 : json["id"],
    "matchers": json["matchers"].map(MatcherFromJSON),
    "startsAt": new Date(json["startsAt"])
  };
}
function PostableSilenceToJSON(json) {
  return PostableSilenceToJSONTyped(json, false);
}
function PostableSilenceToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "comment": value["comment"],
    "createdBy": value["createdBy"],
    "endsAt": value["endsAt"].toISOString(),
    "id": value["id"],
    "matchers": value["matchers"].map(MatcherToJSON),
    "startsAt": value["startsAt"].toISOString()
  };
}

// models/PostableTimeIntervals.ts
function instanceOfPostableTimeIntervals(value) {
  return true;
}
function PostableTimeIntervalsFromJSON(json) {
  return PostableTimeIntervalsFromJSONTyped(json);
}
function PostableTimeIntervalsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "timeIntervals": json["time_intervals"] == null ? void 0 : json["time_intervals"].map(TimeIntervalItemFromJSON)
  };
}
function PostableTimeIntervalsToJSON(json) {
  return PostableTimeIntervalsToJSONTyped(json, false);
}
function PostableTimeIntervalsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "time_intervals": value["timeIntervals"] == null ? void 0 : value["timeIntervals"].map(TimeIntervalItemToJSON)
  };
}

// models/PostableUserConfig.ts
function instanceOfPostableUserConfig(value) {
  return true;
}
function PostableUserConfigFromJSON(json) {
  return PostableUserConfigFromJSONTyped(json);
}
function PostableUserConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "alertmanagerConfig": json["alertmanager_config"] == null ? void 0 : PostableApiAlertingConfigFromJSON(json["alertmanager_config"]),
    "templateFiles": json["template_files"] == null ? void 0 : json["template_files"]
  };
}
function PostableUserConfigToJSON(json) {
  return PostableUserConfigToJSONTyped(json, false);
}
function PostableUserConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "alertmanager_config": PostableApiAlertingConfigToJSON(value["alertmanagerConfig"]),
    "template_files": value["templateFiles"]
  };
}

// models/Preferences.ts
function instanceOfPreferences(value) {
  return true;
}
function PreferencesFromJSON(json) {
  return PreferencesFromJSONTyped(json);
}
function PreferencesFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "cookiePreferences": json["cookiePreferences"] == null ? void 0 : CookiePreferencesFromJSON(json["cookiePreferences"]),
    "homeDashboardUID": json["homeDashboardUID"] == null ? void 0 : json["homeDashboardUID"],
    "language": json["language"] == null ? void 0 : json["language"],
    "queryHistory": json["queryHistory"] == null ? void 0 : QueryHistoryPreferenceFromJSON(json["queryHistory"]),
    "theme": json["theme"] == null ? void 0 : json["theme"],
    "timezone": json["timezone"] == null ? void 0 : json["timezone"],
    "weekStart": json["weekStart"] == null ? void 0 : json["weekStart"]
  };
}
function PreferencesToJSON(json) {
  return PreferencesToJSONTyped(json, false);
}
function PreferencesToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "cookiePreferences": CookiePreferencesToJSON(value["cookiePreferences"]),
    "homeDashboardUID": value["homeDashboardUID"],
    "language": value["language"],
    "queryHistory": QueryHistoryPreferenceToJSON(value["queryHistory"]),
    "theme": value["theme"],
    "timezone": value["timezone"],
    "weekStart": value["weekStart"]
  };
}

// models/PrometheusRemoteWriteTargetJSON.ts
function instanceOfPrometheusRemoteWriteTargetJSON(value) {
  return true;
}
function PrometheusRemoteWriteTargetJSONFromJSON(json) {
  return PrometheusRemoteWriteTargetJSONFromJSONTyped(json);
}
function PrometheusRemoteWriteTargetJSONFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "dataSourceUid": json["data_source_uid"] == null ? void 0 : json["data_source_uid"],
    "id": json["id"] == null ? void 0 : json["id"],
    "remoteWritePath": json["remote_write_path"] == null ? void 0 : json["remote_write_path"]
  };
}
function PrometheusRemoteWriteTargetJSONToJSON(json) {
  return PrometheusRemoteWriteTargetJSONToJSONTyped(json, false);
}
function PrometheusRemoteWriteTargetJSONToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "data_source_uid": value["dataSourceUid"],
    "id": value["id"],
    "remote_write_path": value["remoteWritePath"]
  };
}

// models/ProxyConfig.ts
function instanceOfProxyConfig(value) {
  return true;
}
function ProxyConfigFromJSON(json) {
  return ProxyConfigFromJSONTyped(json);
}
function ProxyConfigFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "noProxy": json["no_proxy"] == null ? void 0 : json["no_proxy"],
    "proxyConnectHeader": json["proxy_connect_header"] == null ? void 0 : json["proxy_connect_header"],
    "proxyFromEnvironment": json["proxy_from_environment"] == null ? void 0 : json["proxy_from_environment"],
    "proxyUrl": json["proxy_url"] == null ? void 0 : URLFromJSON(json["proxy_url"])
  };
}
function ProxyConfigToJSON(json) {
  return ProxyConfigToJSONTyped(json, false);
}
function ProxyConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "no_proxy": value["noProxy"],
    "proxy_connect_header": value["proxyConnectHeader"],
    "proxy_from_environment": value["proxyFromEnvironment"],
    "proxy_url": URLToJSON(value["proxyUrl"])
  };
}

// models/PublicDashboard.ts
function instanceOfPublicDashboard(value) {
  return true;
}
function PublicDashboardFromJSON(json) {
  return PublicDashboardFromJSONTyped(json);
}
function PublicDashboardFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "accessToken": json["accessToken"] == null ? void 0 : json["accessToken"],
    "annotationsEnabled": json["annotationsEnabled"] == null ? void 0 : json["annotationsEnabled"],
    "createdAt": json["createdAt"] == null ? void 0 : new Date(json["createdAt"]),
    "createdBy": json["createdBy"] == null ? void 0 : json["createdBy"],
    "dashboardUid": json["dashboardUid"] == null ? void 0 : json["dashboardUid"],
    "isEnabled": json["isEnabled"] == null ? void 0 : json["isEnabled"],
    "recipients": json["recipients"] == null ? void 0 : json["recipients"].map(EmailDTOFromJSON),
    "share": json["share"] == null ? void 0 : json["share"],
    "timeSelectionEnabled": json["timeSelectionEnabled"] == null ? void 0 : json["timeSelectionEnabled"],
    "uid": json["uid"] == null ? void 0 : json["uid"],
    "updatedAt": json["updatedAt"] == null ? void 0 : new Date(json["updatedAt"]),
    "updatedBy": json["updatedBy"] == null ? void 0 : json["updatedBy"]
  };
}
function PublicDashboardToJSON(json) {
  return PublicDashboardToJSONTyped(json, false);
}
function PublicDashboardToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "accessToken": value["accessToken"],
    "annotationsEnabled": value["annotationsEnabled"],
    "createdAt": value["createdAt"] == null ? void 0 : value["createdAt"].toISOString(),
    "createdBy": value["createdBy"],
    "dashboardUid": value["dashboardUid"],
    "isEnabled": value["isEnabled"],
    "recipients": value["recipients"] == null ? void 0 : value["recipients"].map(EmailDTOToJSON),
    "share": value["share"],
    "timeSelectionEnabled": value["timeSelectionEnabled"],
    "uid": value["uid"],
    "updatedAt": value["updatedAt"] == null ? void 0 : value["updatedAt"].toISOString(),
    "updatedBy": value["updatedBy"]
  };
}

// models/PublicDashboardDTO.ts
function instanceOfPublicDashboardDTO(value) {
  return true;
}
function PublicDashboardDTOFromJSON(json) {
  return PublicDashboardDTOFromJSONTyped(json);
}
function PublicDashboardDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "accessToken": json["accessToken"] == null ? void 0 : json["accessToken"],
    "annotationsEnabled": json["annotationsEnabled"] == null ? void 0 : json["annotationsEnabled"],
    "isEnabled": json["isEnabled"] == null ? void 0 : json["isEnabled"],
    "share": json["share"] == null ? void 0 : json["share"],
    "timeSelectionEnabled": json["timeSelectionEnabled"] == null ? void 0 : json["timeSelectionEnabled"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function PublicDashboardDTOToJSON(json) {
  return PublicDashboardDTOToJSONTyped(json, false);
}
function PublicDashboardDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "accessToken": value["accessToken"],
    "annotationsEnabled": value["annotationsEnabled"],
    "isEnabled": value["isEnabled"],
    "share": value["share"],
    "timeSelectionEnabled": value["timeSelectionEnabled"],
    "uid": value["uid"]
  };
}

// models/PublicDashboardListResponse.ts
function instanceOfPublicDashboardListResponse(value) {
  return true;
}
function PublicDashboardListResponseFromJSON(json) {
  return PublicDashboardListResponseFromJSONTyped(json);
}
function PublicDashboardListResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "accessToken": json["accessToken"] == null ? void 0 : json["accessToken"],
    "dashboardUid": json["dashboardUid"] == null ? void 0 : json["dashboardUid"],
    "isEnabled": json["isEnabled"] == null ? void 0 : json["isEnabled"],
    "slug": json["slug"] == null ? void 0 : json["slug"],
    "title": json["title"] == null ? void 0 : json["title"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function PublicDashboardListResponseToJSON(json) {
  return PublicDashboardListResponseToJSONTyped(json, false);
}
function PublicDashboardListResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "accessToken": value["accessToken"],
    "dashboardUid": value["dashboardUid"],
    "isEnabled": value["isEnabled"],
    "slug": value["slug"],
    "title": value["title"],
    "uid": value["uid"]
  };
}

// models/PublicDashboardListResponseWithPagination.ts
function instanceOfPublicDashboardListResponseWithPagination(value) {
  return true;
}
function PublicDashboardListResponseWithPaginationFromJSON(json) {
  return PublicDashboardListResponseWithPaginationFromJSONTyped(json);
}
function PublicDashboardListResponseWithPaginationFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "page": json["page"] == null ? void 0 : json["page"],
    "perPage": json["perPage"] == null ? void 0 : json["perPage"],
    "publicDashboards": json["publicDashboards"] == null ? void 0 : json["publicDashboards"].map(PublicDashboardListResponseFromJSON),
    "totalCount": json["totalCount"] == null ? void 0 : json["totalCount"]
  };
}
function PublicDashboardListResponseWithPaginationToJSON(json) {
  return PublicDashboardListResponseWithPaginationToJSONTyped(json, false);
}
function PublicDashboardListResponseWithPaginationToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "page": value["page"],
    "perPage": value["perPage"],
    "publicDashboards": value["publicDashboards"] == null ? void 0 : value["publicDashboards"].map(PublicDashboardListResponseToJSON),
    "totalCount": value["totalCount"]
  };
}

// models/QueryDataResponse.ts
function instanceOfQueryDataResponse(value) {
  return true;
}
function QueryDataResponseFromJSON(json) {
  return QueryDataResponseFromJSONTyped(json);
}
function QueryDataResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "results": json["results"] == null ? void 0 : mapValues(json["results"], DataResponseFromJSON)
  };
}
function QueryDataResponseToJSON(json) {
  return QueryDataResponseToJSONTyped(json, false);
}
function QueryDataResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "results": value["results"] == null ? void 0 : mapValues(value["results"], DataResponseToJSON)
  };
}

// models/QueryHistoryDTO.ts
function instanceOfQueryHistoryDTO(value) {
  return true;
}
function QueryHistoryDTOFromJSON(json) {
  return QueryHistoryDTOFromJSONTyped(json);
}
function QueryHistoryDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "comment": json["comment"] == null ? void 0 : json["comment"],
    "createdAt": json["createdAt"] == null ? void 0 : json["createdAt"],
    "createdBy": json["createdBy"] == null ? void 0 : json["createdBy"],
    "datasourceUid": json["datasourceUid"] == null ? void 0 : json["datasourceUid"],
    "queries": json["queries"] == null ? void 0 : json["queries"],
    "starred": json["starred"] == null ? void 0 : json["starred"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function QueryHistoryDTOToJSON(json) {
  return QueryHistoryDTOToJSONTyped(json, false);
}
function QueryHistoryDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "comment": value["comment"],
    "createdAt": value["createdAt"],
    "createdBy": value["createdBy"],
    "datasourceUid": value["datasourceUid"],
    "queries": value["queries"],
    "starred": value["starred"],
    "uid": value["uid"]
  };
}

// models/QueryHistoryDeleteQueryResponse.ts
function instanceOfQueryHistoryDeleteQueryResponse(value) {
  return true;
}
function QueryHistoryDeleteQueryResponseFromJSON(json) {
  return QueryHistoryDeleteQueryResponseFromJSONTyped(json);
}
function QueryHistoryDeleteQueryResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"] == null ? void 0 : json["id"],
    "message": json["message"] == null ? void 0 : json["message"]
  };
}
function QueryHistoryDeleteQueryResponseToJSON(json) {
  return QueryHistoryDeleteQueryResponseToJSONTyped(json, false);
}
function QueryHistoryDeleteQueryResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "message": value["message"]
  };
}

// models/QueryHistoryResponse.ts
function instanceOfQueryHistoryResponse(value) {
  return true;
}
function QueryHistoryResponseFromJSON(json) {
  return QueryHistoryResponseFromJSONTyped(json);
}
function QueryHistoryResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "result": json["result"] == null ? void 0 : QueryHistoryDTOFromJSON(json["result"])
  };
}
function QueryHistoryResponseToJSON(json) {
  return QueryHistoryResponseToJSONTyped(json, false);
}
function QueryHistoryResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "result": QueryHistoryDTOToJSON(value["result"])
  };
}

// models/QueryHistorySearchResult.ts
function instanceOfQueryHistorySearchResult(value) {
  return true;
}
function QueryHistorySearchResultFromJSON(json) {
  return QueryHistorySearchResultFromJSONTyped(json);
}
function QueryHistorySearchResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "page": json["page"] == null ? void 0 : json["page"],
    "perPage": json["perPage"] == null ? void 0 : json["perPage"],
    "queryHistory": json["queryHistory"] == null ? void 0 : json["queryHistory"].map(QueryHistoryDTOFromJSON),
    "totalCount": json["totalCount"] == null ? void 0 : json["totalCount"]
  };
}
function QueryHistorySearchResultToJSON(json) {
  return QueryHistorySearchResultToJSONTyped(json, false);
}
function QueryHistorySearchResultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "page": value["page"],
    "perPage": value["perPage"],
    "queryHistory": value["queryHistory"] == null ? void 0 : value["queryHistory"].map(QueryHistoryDTOToJSON),
    "totalCount": value["totalCount"]
  };
}

// models/QueryHistorySearchResponse.ts
function instanceOfQueryHistorySearchResponse(value) {
  return true;
}
function QueryHistorySearchResponseFromJSON(json) {
  return QueryHistorySearchResponseFromJSONTyped(json);
}
function QueryHistorySearchResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "result": json["result"] == null ? void 0 : QueryHistorySearchResultFromJSON(json["result"])
  };
}
function QueryHistorySearchResponseToJSON(json) {
  return QueryHistorySearchResponseToJSONTyped(json, false);
}
function QueryHistorySearchResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "result": QueryHistorySearchResultToJSON(value["result"])
  };
}

// models/QuotaDTO.ts
function instanceOfQuotaDTO(value) {
  return true;
}
function QuotaDTOFromJSON(json) {
  return QuotaDTOFromJSONTyped(json);
}
function QuotaDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "limit": json["limit"] == null ? void 0 : json["limit"],
    "orgId": json["org_id"] == null ? void 0 : json["org_id"],
    "target": json["target"] == null ? void 0 : json["target"],
    "used": json["used"] == null ? void 0 : json["used"],
    "userId": json["user_id"] == null ? void 0 : json["user_id"]
  };
}
function QuotaDTOToJSON(json) {
  return QuotaDTOToJSONTyped(json, false);
}
function QuotaDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "limit": value["limit"],
    "org_id": value["orgId"],
    "target": value["target"],
    "used": value["used"],
    "user_id": value["userId"]
  };
}

// models/RecordingRuleJSON.ts
function instanceOfRecordingRuleJSON(value) {
  return true;
}
function RecordingRuleJSONFromJSON(json) {
  return RecordingRuleJSONFromJSONTyped(json);
}
function RecordingRuleJSONFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "active": json["active"] == null ? void 0 : json["active"],
    "count": json["count"] == null ? void 0 : json["count"],
    "description": json["description"] == null ? void 0 : json["description"],
    "destDataSourceUid": json["dest_data_source_uid"] == null ? void 0 : json["dest_data_source_uid"],
    "id": json["id"] == null ? void 0 : json["id"],
    "interval": json["interval"] == null ? void 0 : json["interval"],
    "name": json["name"] == null ? void 0 : json["name"],
    "promName": json["prom_name"] == null ? void 0 : json["prom_name"],
    "queries": json["queries"] == null ? void 0 : json["queries"],
    "range": json["range"] == null ? void 0 : json["range"],
    "targetRefId": json["target_ref_id"] == null ? void 0 : json["target_ref_id"]
  };
}
function RecordingRuleJSONToJSON(json) {
  return RecordingRuleJSONToJSONTyped(json, false);
}
function RecordingRuleJSONToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "active": value["active"],
    "count": value["count"],
    "description": value["description"],
    "dest_data_source_uid": value["destDataSourceUid"],
    "id": value["id"],
    "interval": value["interval"],
    "name": value["name"],
    "prom_name": value["promName"],
    "queries": value["queries"],
    "range": value["range"],
    "target_ref_id": value["targetRefId"]
  };
}

// models/Report.ts
function instanceOfReport(value) {
  return true;
}
function ReportFromJSON(json) {
  return ReportFromJSONTyped(json);
}
function ReportFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "created": json["created"] == null ? void 0 : new Date(json["created"]),
    "dashboards": json["dashboards"] == null ? void 0 : json["dashboards"].map(ReportDashboardFromJSON),
    "enableCsv": json["enableCsv"] == null ? void 0 : json["enableCsv"],
    "enableDashboardUrl": json["enableDashboardUrl"] == null ? void 0 : json["enableDashboardUrl"],
    "formats": json["formats"] == null ? void 0 : json["formats"],
    "id": json["id"] == null ? void 0 : json["id"],
    "message": json["message"] == null ? void 0 : json["message"],
    "name": json["name"] == null ? void 0 : json["name"],
    "options": json["options"] == null ? void 0 : ReportOptionsFromJSON(json["options"]),
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "recipients": json["recipients"] == null ? void 0 : json["recipients"],
    "replyTo": json["replyTo"] == null ? void 0 : json["replyTo"],
    "scaleFactor": json["scaleFactor"] == null ? void 0 : json["scaleFactor"],
    "schedule": json["schedule"] == null ? void 0 : ReportScheduleFromJSON(json["schedule"]),
    "state": json["state"] == null ? void 0 : json["state"],
    "uid": json["uid"] == null ? void 0 : json["uid"],
    "updated": json["updated"] == null ? void 0 : new Date(json["updated"]),
    "userId": json["userId"] == null ? void 0 : json["userId"]
  };
}
function ReportToJSON(json) {
  return ReportToJSONTyped(json, false);
}
function ReportToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "created": value["created"] == null ? void 0 : value["created"].toISOString(),
    "dashboards": value["dashboards"] == null ? void 0 : value["dashboards"].map(ReportDashboardToJSON),
    "enableCsv": value["enableCsv"],
    "enableDashboardUrl": value["enableDashboardUrl"],
    "formats": value["formats"],
    "id": value["id"],
    "message": value["message"],
    "name": value["name"],
    "options": ReportOptionsToJSON(value["options"]),
    "orgId": value["orgId"],
    "recipients": value["recipients"],
    "replyTo": value["replyTo"],
    "scaleFactor": value["scaleFactor"],
    "schedule": ReportScheduleToJSON(value["schedule"]),
    "state": value["state"],
    "uid": value["uid"],
    "updated": value["updated"] == null ? void 0 : value["updated"].toISOString(),
    "userId": value["userId"]
  };
}

// models/ReportBrandingOptions.ts
function instanceOfReportBrandingOptions(value) {
  return true;
}
function ReportBrandingOptionsFromJSON(json) {
  return ReportBrandingOptionsFromJSONTyped(json);
}
function ReportBrandingOptionsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "emailFooterLink": json["emailFooterLink"] == null ? void 0 : json["emailFooterLink"],
    "emailFooterMode": json["emailFooterMode"] == null ? void 0 : json["emailFooterMode"],
    "emailFooterText": json["emailFooterText"] == null ? void 0 : json["emailFooterText"],
    "emailLogoUrl": json["emailLogoUrl"] == null ? void 0 : json["emailLogoUrl"],
    "reportLogoUrl": json["reportLogoUrl"] == null ? void 0 : json["reportLogoUrl"]
  };
}
function ReportBrandingOptionsToJSON(json) {
  return ReportBrandingOptionsToJSONTyped(json, false);
}
function ReportBrandingOptionsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "emailFooterLink": value["emailFooterLink"],
    "emailFooterMode": value["emailFooterMode"],
    "emailFooterText": value["emailFooterText"],
    "emailLogoUrl": value["emailLogoUrl"],
    "reportLogoUrl": value["reportLogoUrl"]
  };
}

// models/ReportEmail.ts
function instanceOfReportEmail(value) {
  return true;
}
function ReportEmailFromJSON(json) {
  return ReportEmailFromJSONTyped(json);
}
function ReportEmailFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "emails": json["emails"] == null ? void 0 : json["emails"],
    "id": json["id"] == null ? void 0 : json["id"],
    "useEmailsFromReport": json["useEmailsFromReport"] == null ? void 0 : json["useEmailsFromReport"]
  };
}
function ReportEmailToJSON(json) {
  return ReportEmailToJSONTyped(json, false);
}
function ReportEmailToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "emails": value["emails"],
    "id": value["id"],
    "useEmailsFromReport": value["useEmailsFromReport"]
  };
}

// models/ReportSettings.ts
function instanceOfReportSettings(value) {
  return true;
}
function ReportSettingsFromJSON(json) {
  return ReportSettingsFromJSONTyped(json);
}
function ReportSettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "branding": json["branding"] == null ? void 0 : ReportBrandingOptionsFromJSON(json["branding"]),
    "id": json["id"] == null ? void 0 : json["id"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "userId": json["userId"] == null ? void 0 : json["userId"]
  };
}
function ReportSettingsToJSON(json) {
  return ReportSettingsToJSONTyped(json, false);
}
function ReportSettingsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "branding": ReportBrandingOptionsToJSON(value["branding"]),
    "id": value["id"],
    "orgId": value["orgId"],
    "userId": value["userId"]
  };
}

// models/ResourcePermissionDTO.ts
function instanceOfResourcePermissionDTO(value) {
  return true;
}
function ResourcePermissionDTOFromJSON(json) {
  return ResourcePermissionDTOFromJSONTyped(json);
}
function ResourcePermissionDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "actions": json["actions"] == null ? void 0 : json["actions"],
    "builtInRole": json["builtInRole"] == null ? void 0 : json["builtInRole"],
    "id": json["id"] == null ? void 0 : json["id"],
    "isInherited": json["isInherited"] == null ? void 0 : json["isInherited"],
    "isManaged": json["isManaged"] == null ? void 0 : json["isManaged"],
    "isServiceAccount": json["isServiceAccount"] == null ? void 0 : json["isServiceAccount"],
    "permission": json["permission"] == null ? void 0 : json["permission"],
    "roleName": json["roleName"] == null ? void 0 : json["roleName"],
    "team": json["team"] == null ? void 0 : json["team"],
    "teamAvatarUrl": json["teamAvatarUrl"] == null ? void 0 : json["teamAvatarUrl"],
    "teamId": json["teamId"] == null ? void 0 : json["teamId"],
    "userAvatarUrl": json["userAvatarUrl"] == null ? void 0 : json["userAvatarUrl"],
    "userId": json["userId"] == null ? void 0 : json["userId"],
    "userLogin": json["userLogin"] == null ? void 0 : json["userLogin"]
  };
}
function ResourcePermissionDTOToJSON(json) {
  return ResourcePermissionDTOToJSONTyped(json, false);
}
function ResourcePermissionDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "actions": value["actions"],
    "builtInRole": value["builtInRole"],
    "id": value["id"],
    "isInherited": value["isInherited"],
    "isManaged": value["isManaged"],
    "isServiceAccount": value["isServiceAccount"],
    "permission": value["permission"],
    "roleName": value["roleName"],
    "team": value["team"],
    "teamAvatarUrl": value["teamAvatarUrl"],
    "teamId": value["teamId"],
    "userAvatarUrl": value["userAvatarUrl"],
    "userId": value["userId"],
    "userLogin": value["userLogin"]
  };
}

// models/ResponseDetails.ts
function instanceOfResponseDetails(value) {
  return true;
}
function ResponseDetailsFromJSON(json) {
  return ResponseDetailsFromJSONTyped(json);
}
function ResponseDetailsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "msg": json["msg"] == null ? void 0 : json["msg"]
  };
}
function ResponseDetailsToJSON(json) {
  return ResponseDetailsToJSONTyped(json, false);
}
function ResponseDetailsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "msg": value["msg"]
  };
}

// models/RestoreDashboardVersionCommand.ts
function instanceOfRestoreDashboardVersionCommand(value) {
  return true;
}
function RestoreDashboardVersionCommandFromJSON(json) {
  return RestoreDashboardVersionCommandFromJSONTyped(json);
}
function RestoreDashboardVersionCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "version": json["version"] == null ? void 0 : json["version"]
  };
}
function RestoreDashboardVersionCommandToJSON(json) {
  return RestoreDashboardVersionCommandToJSONTyped(json, false);
}
function RestoreDashboardVersionCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "version": value["version"]
  };
}

// models/RetrieveJWKS200Response.ts
function instanceOfRetrieveJWKS200Response(value) {
  return true;
}
function RetrieveJWKS200ResponseFromJSON(json) {
  return RetrieveJWKS200ResponseFromJSONTyped(json);
}
function RetrieveJWKS200ResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "keys": json["keys"] == null ? void 0 : json["keys"].map(JSONWebKeyFromJSON)
  };
}
function RetrieveJWKS200ResponseToJSON(json) {
  return RetrieveJWKS200ResponseToJSONTyped(json, false);
}
function RetrieveJWKS200ResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "keys": value["keys"] == null ? void 0 : value["keys"].map(JSONWebKeyToJSON)
  };
}

// models/RevokeAuthTokenCmd.ts
function instanceOfRevokeAuthTokenCmd(value) {
  return true;
}
function RevokeAuthTokenCmdFromJSON(json) {
  return RevokeAuthTokenCmdFromJSONTyped(json);
}
function RevokeAuthTokenCmdFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "authTokenId": json["authTokenId"] == null ? void 0 : json["authTokenId"]
  };
}
function RevokeAuthTokenCmdToJSON(json) {
  return RevokeAuthTokenCmdToJSONTyped(json, false);
}
function RevokeAuthTokenCmdToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "authTokenId": value["authTokenId"]
  };
}

// models/RoleAssignmentsDTO.ts
function instanceOfRoleAssignmentsDTO(value) {
  return true;
}
function RoleAssignmentsDTOFromJSON(json) {
  return RoleAssignmentsDTOFromJSONTyped(json);
}
function RoleAssignmentsDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "roleUid": json["role_uid"] == null ? void 0 : json["role_uid"],
    "serviceAccounts": json["service_accounts"] == null ? void 0 : json["service_accounts"],
    "teams": json["teams"] == null ? void 0 : json["teams"],
    "users": json["users"] == null ? void 0 : json["users"]
  };
}
function RoleAssignmentsDTOToJSON(json) {
  return RoleAssignmentsDTOToJSONTyped(json, false);
}
function RoleAssignmentsDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "role_uid": value["roleUid"],
    "service_accounts": value["serviceAccounts"],
    "teams": value["teams"],
    "users": value["users"]
  };
}

// models/RoleDTO.ts
function instanceOfRoleDTO(value) {
  return true;
}
function RoleDTOFromJSON(json) {
  return RoleDTOFromJSONTyped(json);
}
function RoleDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "created": json["created"] == null ? void 0 : new Date(json["created"]),
    "delegatable": json["delegatable"] == null ? void 0 : json["delegatable"],
    "description": json["description"] == null ? void 0 : json["description"],
    "displayName": json["displayName"] == null ? void 0 : json["displayName"],
    "global": json["global"] == null ? void 0 : json["global"],
    "group": json["group"] == null ? void 0 : json["group"],
    "hidden": json["hidden"] == null ? void 0 : json["hidden"],
    "name": json["name"] == null ? void 0 : json["name"],
    "permissions": json["permissions"] == null ? void 0 : json["permissions"].map(PermissionFromJSON),
    "uid": json["uid"] == null ? void 0 : json["uid"],
    "updated": json["updated"] == null ? void 0 : new Date(json["updated"]),
    "version": json["version"] == null ? void 0 : json["version"]
  };
}
function RoleDTOToJSON(json) {
  return RoleDTOToJSONTyped(json, false);
}
function RoleDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "created": value["created"] == null ? void 0 : value["created"].toISOString(),
    "delegatable": value["delegatable"],
    "description": value["description"],
    "displayName": value["displayName"],
    "global": value["global"],
    "group": value["group"],
    "hidden": value["hidden"],
    "name": value["name"],
    "permissions": value["permissions"] == null ? void 0 : value["permissions"].map(PermissionToJSON),
    "uid": value["uid"],
    "updated": value["updated"] == null ? void 0 : value["updated"].toISOString(),
    "version": value["version"]
  };
}

// models/RolesSearchQuery.ts
function instanceOfRolesSearchQuery(value) {
  return true;
}
function RolesSearchQueryFromJSON(json) {
  return RolesSearchQueryFromJSONTyped(json);
}
function RolesSearchQueryFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "includeHidden": json["includeHidden"] == null ? void 0 : json["includeHidden"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "teamIds": json["teamIds"] == null ? void 0 : json["teamIds"],
    "userIds": json["userIds"] == null ? void 0 : json["userIds"]
  };
}
function RolesSearchQueryToJSON(json) {
  return RolesSearchQueryToJSONTyped(json, false);
}
function RolesSearchQueryToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "includeHidden": value["includeHidden"],
    "orgId": value["orgId"],
    "teamIds": value["teamIds"],
    "userIds": value["userIds"]
  };
}

// models/Rule.ts
function instanceOfRule(value) {
  if (!("health" in value) || value["health"] === void 0) return false;
  if (!("name" in value) || value["name"] === void 0) return false;
  if (!("query" in value) || value["query"] === void 0) return false;
  if (!("type" in value) || value["type"] === void 0) return false;
  return true;
}
function RuleFromJSON(json) {
  return RuleFromJSONTyped(json);
}
function RuleFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "evaluationTime": json["evaluationTime"] == null ? void 0 : json["evaluationTime"],
    "health": json["health"],
    "labels": json["labels"] == null ? void 0 : json["labels"],
    "lastError": json["lastError"] == null ? void 0 : json["lastError"],
    "lastEvaluation": json["lastEvaluation"] == null ? void 0 : new Date(json["lastEvaluation"]),
    "name": json["name"],
    "query": json["query"],
    "type": json["type"]
  };
}
function RuleToJSON(json) {
  return RuleToJSONTyped(json, false);
}
function RuleToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "evaluationTime": value["evaluationTime"],
    "health": value["health"],
    "labels": value["labels"],
    "lastError": value["lastError"],
    "lastEvaluation": value["lastEvaluation"] == null ? void 0 : value["lastEvaluation"].toISOString(),
    "name": value["name"],
    "query": value["query"],
    "type": value["type"]
  };
}

// models/RuleGroup.ts
function instanceOfRuleGroup(value) {
  if (!("file" in value) || value["file"] === void 0) return false;
  if (!("interval" in value) || value["interval"] === void 0) return false;
  if (!("name" in value) || value["name"] === void 0) return false;
  if (!("rules" in value) || value["rules"] === void 0) return false;
  return true;
}
function RuleGroupFromJSON(json) {
  return RuleGroupFromJSONTyped(json);
}
function RuleGroupFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "evaluationTime": json["evaluationTime"] == null ? void 0 : json["evaluationTime"],
    "file": json["file"],
    "interval": json["interval"],
    "lastEvaluation": json["lastEvaluation"] == null ? void 0 : new Date(json["lastEvaluation"]),
    "name": json["name"],
    "rules": json["rules"].map(AlertingRuleFromJSON),
    "totals": json["totals"] == null ? void 0 : json["totals"]
  };
}
function RuleGroupToJSON(json) {
  return RuleGroupToJSONTyped(json, false);
}
function RuleGroupToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "evaluationTime": value["evaluationTime"],
    "file": value["file"],
    "interval": value["interval"],
    "lastEvaluation": value["lastEvaluation"] == null ? void 0 : value["lastEvaluation"].toISOString(),
    "name": value["name"],
    "rules": value["rules"].map(AlertingRuleToJSON),
    "totals": value["totals"]
  };
}

// models/RuleDiscovery.ts
function instanceOfRuleDiscovery(value) {
  if (!("groups" in value) || value["groups"] === void 0) return false;
  return true;
}
function RuleDiscoveryFromJSON(json) {
  return RuleDiscoveryFromJSONTyped(json);
}
function RuleDiscoveryFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "groups": json["groups"].map(RuleGroupFromJSON),
    "totals": json["totals"] == null ? void 0 : json["totals"]
  };
}
function RuleDiscoveryToJSON(json) {
  return RuleDiscoveryToJSONTyped(json, false);
}
function RuleDiscoveryToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "groups": value["groups"].map(RuleGroupToJSON),
    "totals": value["totals"]
  };
}

// models/RuleGroupConfigResponse.ts
function instanceOfRuleGroupConfigResponse(value) {
  return true;
}
function RuleGroupConfigResponseFromJSON(json) {
  return RuleGroupConfigResponseFromJSONTyped(json);
}
function RuleGroupConfigResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "interval": json["interval"] == null ? void 0 : json["interval"],
    "name": json["name"] == null ? void 0 : json["name"],
    "rules": json["rules"] == null ? void 0 : json["rules"].map(GettableExtendedRuleNodeFromJSON),
    "sourceTenants": json["source_tenants"] == null ? void 0 : json["source_tenants"]
  };
}
function RuleGroupConfigResponseToJSON(json) {
  return RuleGroupConfigResponseToJSONTyped(json, false);
}
function RuleGroupConfigResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "interval": value["interval"],
    "name": value["name"],
    "rules": value["rules"] == null ? void 0 : value["rules"].map(GettableExtendedRuleNodeToJSON),
    "source_tenants": value["sourceTenants"]
  };
}

// models/RuleResponse.ts
function instanceOfRuleResponse(value) {
  if (!("status" in value) || value["status"] === void 0) return false;
  return true;
}
function RuleResponseFromJSON(json) {
  return RuleResponseFromJSONTyped(json);
}
function RuleResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "data": json["data"] == null ? void 0 : RuleDiscoveryFromJSON(json["data"]),
    "error": json["error"] == null ? void 0 : json["error"],
    "errorType": json["errorType"] == null ? void 0 : json["errorType"],
    "status": json["status"]
  };
}
function RuleResponseToJSON(json) {
  return RuleResponseToJSONTyped(json, false);
}
function RuleResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "data": RuleDiscoveryToJSON(value["data"]),
    "error": value["error"],
    "errorType": value["errorType"],
    "status": value["status"]
  };
}

// models/Sample.ts
function instanceOfSample(value) {
  return true;
}
function SampleFromJSON(json) {
  return SampleFromJSONTyped(json);
}
function SampleFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "f": json["F"] == null ? void 0 : json["F"],
    "h": json["H"] == null ? void 0 : FloatHistogramFromJSON(json["H"]),
    "metric": json["Metric"] == null ? void 0 : json["Metric"].map(LabelFromJSON),
    "t": json["T"] == null ? void 0 : json["T"]
  };
}
function SampleToJSON(json) {
  return SampleToJSONTyped(json, false);
}
function SampleToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "F": value["f"],
    "H": FloatHistogramToJSON(value["h"]),
    "Metric": value["metric"] == null ? void 0 : value["metric"].map(LabelToJSON),
    "T": value["t"]
  };
}

// models/SaveDashboardCommand.ts
function instanceOfSaveDashboardCommand(value) {
  return true;
}
function SaveDashboardCommandFromJSON(json) {
  return SaveDashboardCommandFromJSONTyped(json);
}
function SaveDashboardCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "updatedAt": json["UpdatedAt"] == null ? void 0 : new Date(json["UpdatedAt"]),
    "dashboard": json["dashboard"] == null ? void 0 : json["dashboard"],
    "folderId": json["folderId"] == null ? void 0 : json["folderId"],
    "folderUid": json["folderUid"] == null ? void 0 : json["folderUid"],
    "isFolder": json["isFolder"] == null ? void 0 : json["isFolder"],
    "message": json["message"] == null ? void 0 : json["message"],
    "overwrite": json["overwrite"] == null ? void 0 : json["overwrite"],
    "userId": json["userId"] == null ? void 0 : json["userId"]
  };
}
function SaveDashboardCommandToJSON(json) {
  return SaveDashboardCommandToJSONTyped(json, false);
}
function SaveDashboardCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "UpdatedAt": value["updatedAt"] == null ? void 0 : value["updatedAt"].toISOString(),
    "dashboard": value["dashboard"],
    "folderId": value["folderId"],
    "folderUid": value["folderUid"],
    "isFolder": value["isFolder"],
    "message": value["message"],
    "overwrite": value["overwrite"],
    "userId": value["userId"]
  };
}

// models/SearchDeviceQueryResult.ts
function instanceOfSearchDeviceQueryResult(value) {
  return true;
}
function SearchDeviceQueryResultFromJSON(json) {
  return SearchDeviceQueryResultFromJSONTyped(json);
}
function SearchDeviceQueryResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "devices": json["devices"] == null ? void 0 : json["devices"].map(DeviceSearchHitDTOFromJSON),
    "page": json["page"] == null ? void 0 : json["page"],
    "perPage": json["perPage"] == null ? void 0 : json["perPage"],
    "totalCount": json["totalCount"] == null ? void 0 : json["totalCount"]
  };
}
function SearchDeviceQueryResultToJSON(json) {
  return SearchDeviceQueryResultToJSONTyped(json, false);
}
function SearchDeviceQueryResultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "devices": value["devices"] == null ? void 0 : value["devices"].map(DeviceSearchHitDTOToJSON),
    "page": value["page"],
    "perPage": value["perPage"],
    "totalCount": value["totalCount"]
  };
}

// models/ServiceAccountDTO.ts
function instanceOfServiceAccountDTO(value) {
  return true;
}
function ServiceAccountDTOFromJSON(json) {
  return ServiceAccountDTOFromJSONTyped(json);
}
function ServiceAccountDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "accessControl": json["accessControl"] == null ? void 0 : json["accessControl"],
    "avatarUrl": json["avatarUrl"] == null ? void 0 : json["avatarUrl"],
    "id": json["id"] == null ? void 0 : json["id"],
    "isDisabled": json["isDisabled"] == null ? void 0 : json["isDisabled"],
    "isExternal": json["isExternal"] == null ? void 0 : json["isExternal"],
    "login": json["login"] == null ? void 0 : json["login"],
    "name": json["name"] == null ? void 0 : json["name"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "role": json["role"] == null ? void 0 : json["role"],
    "tokens": json["tokens"] == null ? void 0 : json["tokens"]
  };
}
function ServiceAccountDTOToJSON(json) {
  return ServiceAccountDTOToJSONTyped(json, false);
}
function ServiceAccountDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "accessControl": value["accessControl"],
    "avatarUrl": value["avatarUrl"],
    "id": value["id"],
    "isDisabled": value["isDisabled"],
    "isExternal": value["isExternal"],
    "login": value["login"],
    "name": value["name"],
    "orgId": value["orgId"],
    "role": value["role"],
    "tokens": value["tokens"]
  };
}

// models/SearchOrgServiceAccountsResult.ts
function instanceOfSearchOrgServiceAccountsResult(value) {
  return true;
}
function SearchOrgServiceAccountsResultFromJSON(json) {
  return SearchOrgServiceAccountsResultFromJSONTyped(json);
}
function SearchOrgServiceAccountsResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "page": json["page"] == null ? void 0 : json["page"],
    "perPage": json["perPage"] == null ? void 0 : json["perPage"],
    "serviceAccounts": json["serviceAccounts"] == null ? void 0 : json["serviceAccounts"].map(ServiceAccountDTOFromJSON),
    "totalCount": json["totalCount"] == null ? void 0 : json["totalCount"]
  };
}
function SearchOrgServiceAccountsResultToJSON(json) {
  return SearchOrgServiceAccountsResultToJSONTyped(json, false);
}
function SearchOrgServiceAccountsResultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "page": value["page"],
    "perPage": value["perPage"],
    "serviceAccounts": value["serviceAccounts"] == null ? void 0 : value["serviceAccounts"].map(ServiceAccountDTOToJSON),
    "totalCount": value["totalCount"]
  };
}

// models/SearchOrgUsersQueryResult.ts
function instanceOfSearchOrgUsersQueryResult(value) {
  return true;
}
function SearchOrgUsersQueryResultFromJSON(json) {
  return SearchOrgUsersQueryResultFromJSONTyped(json);
}
function SearchOrgUsersQueryResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "orgUsers": json["orgUsers"] == null ? void 0 : json["orgUsers"].map(OrgUserDTOFromJSON),
    "page": json["page"] == null ? void 0 : json["page"],
    "perPage": json["perPage"] == null ? void 0 : json["perPage"],
    "totalCount": json["totalCount"] == null ? void 0 : json["totalCount"]
  };
}
function SearchOrgUsersQueryResultToJSON(json) {
  return SearchOrgUsersQueryResultToJSONTyped(json, false);
}
function SearchOrgUsersQueryResultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "orgUsers": value["orgUsers"] == null ? void 0 : value["orgUsers"].map(OrgUserDTOToJSON),
    "page": value["page"],
    "perPage": value["perPage"],
    "totalCount": value["totalCount"]
  };
}

// models/SearchResultItem.ts
function instanceOfSearchResultItem(value) {
  return true;
}
function SearchResultItemFromJSON(json) {
  return SearchResultItemFromJSONTyped(json);
}
function SearchResultItemFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "action": json["action"] == null ? void 0 : json["action"],
    "basicRole": json["basicRole"] == null ? void 0 : json["basicRole"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "roleName": json["roleName"] == null ? void 0 : json["roleName"],
    "scope": json["scope"] == null ? void 0 : json["scope"],
    "teamId": json["teamId"] == null ? void 0 : json["teamId"],
    "userId": json["userId"] == null ? void 0 : json["userId"],
    "version": json["version"] == null ? void 0 : json["version"]
  };
}
function SearchResultItemToJSON(json) {
  return SearchResultItemToJSONTyped(json, false);
}
function SearchResultItemToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "action": value["action"],
    "basicRole": value["basicRole"],
    "orgId": value["orgId"],
    "roleName": value["roleName"],
    "scope": value["scope"],
    "teamId": value["teamId"],
    "userId": value["userId"],
    "version": value["version"]
  };
}

// models/SearchResult.ts
function instanceOfSearchResult(value) {
  return true;
}
function SearchResultFromJSON(json) {
  return SearchResultFromJSONTyped(json);
}
function SearchResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "result": json["result"] == null ? void 0 : json["result"].map(SearchResultItemFromJSON)
  };
}
function SearchResultToJSON(json) {
  return SearchResultToJSONTyped(json, false);
}
function SearchResultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "result": value["result"] == null ? void 0 : value["result"].map(SearchResultItemToJSON)
  };
}

// models/TeamDTO.ts
function instanceOfTeamDTO(value) {
  return true;
}
function TeamDTOFromJSON(json) {
  return TeamDTOFromJSONTyped(json);
}
function TeamDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "accessControl": json["accessControl"] == null ? void 0 : json["accessControl"],
    "avatarUrl": json["avatarUrl"] == null ? void 0 : json["avatarUrl"],
    "email": json["email"] == null ? void 0 : json["email"],
    "id": json["id"] == null ? void 0 : json["id"],
    "memberCount": json["memberCount"] == null ? void 0 : json["memberCount"],
    "name": json["name"] == null ? void 0 : json["name"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "permission": json["permission"] == null ? void 0 : json["permission"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function TeamDTOToJSON(json) {
  return TeamDTOToJSONTyped(json, false);
}
function TeamDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "accessControl": value["accessControl"],
    "avatarUrl": value["avatarUrl"],
    "email": value["email"],
    "id": value["id"],
    "memberCount": value["memberCount"],
    "name": value["name"],
    "orgId": value["orgId"],
    "permission": value["permission"],
    "uid": value["uid"]
  };
}

// models/SearchTeamQueryResult.ts
function instanceOfSearchTeamQueryResult(value) {
  return true;
}
function SearchTeamQueryResultFromJSON(json) {
  return SearchTeamQueryResultFromJSONTyped(json);
}
function SearchTeamQueryResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "page": json["page"] == null ? void 0 : json["page"],
    "perPage": json["perPage"] == null ? void 0 : json["perPage"],
    "teams": json["teams"] == null ? void 0 : json["teams"].map(TeamDTOFromJSON),
    "totalCount": json["totalCount"] == null ? void 0 : json["totalCount"]
  };
}
function SearchTeamQueryResultToJSON(json) {
  return SearchTeamQueryResultToJSONTyped(json, false);
}
function SearchTeamQueryResultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "page": value["page"],
    "perPage": value["perPage"],
    "teams": value["teams"] == null ? void 0 : value["teams"].map(TeamDTOToJSON),
    "totalCount": value["totalCount"]
  };
}

// models/UserSearchHitDTO.ts
function instanceOfUserSearchHitDTO(value) {
  return true;
}
function UserSearchHitDTOFromJSON(json) {
  return UserSearchHitDTOFromJSONTyped(json);
}
function UserSearchHitDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "authLabels": json["authLabels"] == null ? void 0 : json["authLabels"],
    "avatarUrl": json["avatarUrl"] == null ? void 0 : json["avatarUrl"],
    "email": json["email"] == null ? void 0 : json["email"],
    "id": json["id"] == null ? void 0 : json["id"],
    "isAdmin": json["isAdmin"] == null ? void 0 : json["isAdmin"],
    "isDisabled": json["isDisabled"] == null ? void 0 : json["isDisabled"],
    "lastSeenAt": json["lastSeenAt"] == null ? void 0 : new Date(json["lastSeenAt"]),
    "lastSeenAtAge": json["lastSeenAtAge"] == null ? void 0 : json["lastSeenAtAge"],
    "login": json["login"] == null ? void 0 : json["login"],
    "name": json["name"] == null ? void 0 : json["name"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function UserSearchHitDTOToJSON(json) {
  return UserSearchHitDTOToJSONTyped(json, false);
}
function UserSearchHitDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "authLabels": value["authLabels"],
    "avatarUrl": value["avatarUrl"],
    "email": value["email"],
    "id": value["id"],
    "isAdmin": value["isAdmin"],
    "isDisabled": value["isDisabled"],
    "lastSeenAt": value["lastSeenAt"] == null ? void 0 : value["lastSeenAt"].toISOString(),
    "lastSeenAtAge": value["lastSeenAtAge"],
    "login": value["login"],
    "name": value["name"],
    "uid": value["uid"]
  };
}

// models/SearchUserQueryResult.ts
function instanceOfSearchUserQueryResult(value) {
  return true;
}
function SearchUserQueryResultFromJSON(json) {
  return SearchUserQueryResultFromJSONTyped(json);
}
function SearchUserQueryResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "page": json["page"] == null ? void 0 : json["page"],
    "perPage": json["perPage"] == null ? void 0 : json["perPage"],
    "totalCount": json["totalCount"] == null ? void 0 : json["totalCount"],
    "users": json["users"] == null ? void 0 : json["users"].map(UserSearchHitDTOFromJSON)
  };
}
function SearchUserQueryResultToJSON(json) {
  return SearchUserQueryResultToJSONTyped(json, false);
}
function SearchUserQueryResultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "page": value["page"],
    "perPage": value["perPage"],
    "totalCount": value["totalCount"],
    "users": value["users"] == null ? void 0 : value["users"].map(UserSearchHitDTOToJSON)
  };
}

// models/ServiceAccountProfileDTO.ts
function instanceOfServiceAccountProfileDTO(value) {
  return true;
}
function ServiceAccountProfileDTOFromJSON(json) {
  return ServiceAccountProfileDTOFromJSONTyped(json);
}
function ServiceAccountProfileDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "accessControl": json["accessControl"] == null ? void 0 : json["accessControl"],
    "avatarUrl": json["avatarUrl"] == null ? void 0 : json["avatarUrl"],
    "createdAt": json["createdAt"] == null ? void 0 : new Date(json["createdAt"]),
    "id": json["id"] == null ? void 0 : json["id"],
    "isDisabled": json["isDisabled"] == null ? void 0 : json["isDisabled"],
    "isExternal": json["isExternal"] == null ? void 0 : json["isExternal"],
    "login": json["login"] == null ? void 0 : json["login"],
    "name": json["name"] == null ? void 0 : json["name"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "requiredBy": json["requiredBy"] == null ? void 0 : json["requiredBy"],
    "role": json["role"] == null ? void 0 : json["role"],
    "teams": json["teams"] == null ? void 0 : json["teams"],
    "tokens": json["tokens"] == null ? void 0 : json["tokens"],
    "updatedAt": json["updatedAt"] == null ? void 0 : new Date(json["updatedAt"])
  };
}
function ServiceAccountProfileDTOToJSON(json) {
  return ServiceAccountProfileDTOToJSONTyped(json, false);
}
function ServiceAccountProfileDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "accessControl": value["accessControl"],
    "avatarUrl": value["avatarUrl"],
    "createdAt": value["createdAt"] == null ? void 0 : value["createdAt"].toISOString(),
    "id": value["id"],
    "isDisabled": value["isDisabled"],
    "isExternal": value["isExternal"],
    "login": value["login"],
    "name": value["name"],
    "orgId": value["orgId"],
    "requiredBy": value["requiredBy"],
    "role": value["role"],
    "teams": value["teams"],
    "tokens": value["tokens"],
    "updatedAt": value["updatedAt"] == null ? void 0 : value["updatedAt"].toISOString()
  };
}

// models/SetPermissionCommand.ts
function instanceOfSetPermissionCommand(value) {
  return true;
}
function SetPermissionCommandFromJSON(json) {
  return SetPermissionCommandFromJSONTyped(json);
}
function SetPermissionCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "permission": json["permission"] == null ? void 0 : json["permission"]
  };
}
function SetPermissionCommandToJSON(json) {
  return SetPermissionCommandToJSONTyped(json, false);
}
function SetPermissionCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "permission": value["permission"]
  };
}

// models/SetResourcePermissionCommand.ts
function instanceOfSetResourcePermissionCommand(value) {
  return true;
}
function SetResourcePermissionCommandFromJSON(json) {
  return SetResourcePermissionCommandFromJSONTyped(json);
}
function SetResourcePermissionCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "builtInRole": json["builtInRole"] == null ? void 0 : json["builtInRole"],
    "permission": json["permission"] == null ? void 0 : json["permission"],
    "teamId": json["teamId"] == null ? void 0 : json["teamId"],
    "userId": json["userId"] == null ? void 0 : json["userId"]
  };
}
function SetResourcePermissionCommandToJSON(json) {
  return SetResourcePermissionCommandToJSONTyped(json, false);
}
function SetResourcePermissionCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "builtInRole": value["builtInRole"],
    "permission": value["permission"],
    "teamId": value["teamId"],
    "userId": value["userId"]
  };
}

// models/SetPermissionsCommand.ts
function instanceOfSetPermissionsCommand(value) {
  return true;
}
function SetPermissionsCommandFromJSON(json) {
  return SetPermissionsCommandFromJSONTyped(json);
}
function SetPermissionsCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "permissions": json["permissions"] == null ? void 0 : json["permissions"].map(SetResourcePermissionCommandFromJSON)
  };
}
function SetPermissionsCommandToJSON(json) {
  return SetPermissionsCommandToJSONTyped(json, false);
}
function SetPermissionsCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "permissions": value["permissions"] == null ? void 0 : value["permissions"].map(SetResourcePermissionCommandToJSON)
  };
}

// models/SetRoleAssignmentsCommand.ts
function instanceOfSetRoleAssignmentsCommand(value) {
  return true;
}
function SetRoleAssignmentsCommandFromJSON(json) {
  return SetRoleAssignmentsCommandFromJSONTyped(json);
}
function SetRoleAssignmentsCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "serviceAccounts": json["service_accounts"] == null ? void 0 : json["service_accounts"],
    "teams": json["teams"] == null ? void 0 : json["teams"],
    "users": json["users"] == null ? void 0 : json["users"]
  };
}
function SetRoleAssignmentsCommandToJSON(json) {
  return SetRoleAssignmentsCommandToJSONTyped(json, false);
}
function SetRoleAssignmentsCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "service_accounts": value["serviceAccounts"],
    "teams": value["teams"],
    "users": value["users"]
  };
}

// models/SetUserRolesCommand.ts
function instanceOfSetUserRolesCommand(value) {
  return true;
}
function SetUserRolesCommandFromJSON(json) {
  return SetUserRolesCommandFromJSONTyped(json);
}
function SetUserRolesCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "global": json["global"] == null ? void 0 : json["global"],
    "includeHidden": json["includeHidden"] == null ? void 0 : json["includeHidden"],
    "roleUids": json["roleUids"] == null ? void 0 : json["roleUids"]
  };
}
function SetUserRolesCommandToJSON(json) {
  return SetUserRolesCommandToJSONTyped(json, false);
}
function SetUserRolesCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "global": value["global"],
    "includeHidden": value["includeHidden"],
    "roleUids": value["roleUids"]
  };
}

// models/Silence.ts
function instanceOfSilence(value) {
  if (!("comment" in value) || value["comment"] === void 0) return false;
  if (!("createdBy" in value) || value["createdBy"] === void 0) return false;
  if (!("endsAt" in value) || value["endsAt"] === void 0) return false;
  if (!("matchers" in value) || value["matchers"] === void 0) return false;
  if (!("startsAt" in value) || value["startsAt"] === void 0) return false;
  return true;
}
function SilenceFromJSON(json) {
  return SilenceFromJSONTyped(json);
}
function SilenceFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "comment": json["comment"],
    "createdBy": json["createdBy"],
    "endsAt": new Date(json["endsAt"]),
    "matchers": json["matchers"].map(MatcherFromJSON),
    "startsAt": new Date(json["startsAt"])
  };
}
function SilenceToJSON(json) {
  return SilenceToJSONTyped(json, false);
}
function SilenceToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "comment": value["comment"],
    "createdBy": value["createdBy"],
    "endsAt": value["endsAt"].toISOString(),
    "matchers": value["matchers"].map(MatcherToJSON),
    "startsAt": value["startsAt"].toISOString()
  };
}

// models/SuccessResponseBody.ts
function instanceOfSuccessResponseBody(value) {
  return true;
}
function SuccessResponseBodyFromJSON(json) {
  return SuccessResponseBodyFromJSONTyped(json);
}
function SuccessResponseBodyFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "message": json["message"] == null ? void 0 : json["message"]
  };
}
function SuccessResponseBodyToJSON(json) {
  return SuccessResponseBodyToJSONTyped(json, false);
}
function SuccessResponseBodyToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "message": value["message"]
  };
}

// models/TeamGroupDTO.ts
function instanceOfTeamGroupDTO(value) {
  return true;
}
function TeamGroupDTOFromJSON(json) {
  return TeamGroupDTOFromJSONTyped(json);
}
function TeamGroupDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "groupId": json["groupId"] == null ? void 0 : json["groupId"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "teamId": json["teamId"] == null ? void 0 : json["teamId"]
  };
}
function TeamGroupDTOToJSON(json) {
  return TeamGroupDTOToJSONTyped(json, false);
}
function TeamGroupDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "groupId": value["groupId"],
    "orgId": value["orgId"],
    "teamId": value["teamId"]
  };
}

// models/TeamGroupMapping.ts
function instanceOfTeamGroupMapping(value) {
  return true;
}
function TeamGroupMappingFromJSON(json) {
  return TeamGroupMappingFromJSONTyped(json);
}
function TeamGroupMappingFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "groupId": json["groupId"] == null ? void 0 : json["groupId"]
  };
}
function TeamGroupMappingToJSON(json) {
  return TeamGroupMappingToJSONTyped(json, false);
}
function TeamGroupMappingToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "groupId": value["groupId"]
  };
}

// models/TeamMemberDTO.ts
function instanceOfTeamMemberDTO(value) {
  return true;
}
function TeamMemberDTOFromJSON(json) {
  return TeamMemberDTOFromJSONTyped(json);
}
function TeamMemberDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "authModule": json["auth_module"] == null ? void 0 : json["auth_module"],
    "avatarUrl": json["avatarUrl"] == null ? void 0 : json["avatarUrl"],
    "email": json["email"] == null ? void 0 : json["email"],
    "labels": json["labels"] == null ? void 0 : json["labels"],
    "login": json["login"] == null ? void 0 : json["login"],
    "name": json["name"] == null ? void 0 : json["name"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "permission": json["permission"] == null ? void 0 : json["permission"],
    "teamId": json["teamId"] == null ? void 0 : json["teamId"],
    "teamUID": json["teamUID"] == null ? void 0 : json["teamUID"],
    "userId": json["userId"] == null ? void 0 : json["userId"]
  };
}
function TeamMemberDTOToJSON(json) {
  return TeamMemberDTOToJSONTyped(json, false);
}
function TeamMemberDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "auth_module": value["authModule"],
    "avatarUrl": value["avatarUrl"],
    "email": value["email"],
    "labels": value["labels"],
    "login": value["login"],
    "name": value["name"],
    "orgId": value["orgId"],
    "permission": value["permission"],
    "teamId": value["teamId"],
    "teamUID": value["teamUID"],
    "userId": value["userId"]
  };
}

// models/TempUserDTO.ts
var TempUserDTORoleEnum = {
  None: "None",
  Viewer: "Viewer",
  Editor: "Editor",
  Admin: "Admin"
};
function instanceOfTempUserDTO(value) {
  return true;
}
function TempUserDTOFromJSON(json) {
  return TempUserDTOFromJSONTyped(json);
}
function TempUserDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "code": json["code"] == null ? void 0 : json["code"],
    "createdOn": json["createdOn"] == null ? void 0 : new Date(json["createdOn"]),
    "email": json["email"] == null ? void 0 : json["email"],
    "emailSent": json["emailSent"] == null ? void 0 : json["emailSent"],
    "emailSentOn": json["emailSentOn"] == null ? void 0 : new Date(json["emailSentOn"]),
    "id": json["id"] == null ? void 0 : json["id"],
    "invitedByEmail": json["invitedByEmail"] == null ? void 0 : json["invitedByEmail"],
    "invitedByLogin": json["invitedByLogin"] == null ? void 0 : json["invitedByLogin"],
    "invitedByName": json["invitedByName"] == null ? void 0 : json["invitedByName"],
    "name": json["name"] == null ? void 0 : json["name"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "role": json["role"] == null ? void 0 : json["role"],
    "status": json["status"] == null ? void 0 : json["status"],
    "url": json["url"] == null ? void 0 : json["url"]
  };
}
function TempUserDTOToJSON(json) {
  return TempUserDTOToJSONTyped(json, false);
}
function TempUserDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "code": value["code"],
    "createdOn": value["createdOn"] == null ? void 0 : value["createdOn"].toISOString(),
    "email": value["email"],
    "emailSent": value["emailSent"],
    "emailSentOn": value["emailSentOn"] == null ? void 0 : value["emailSentOn"].toISOString(),
    "id": value["id"],
    "invitedByEmail": value["invitedByEmail"],
    "invitedByLogin": value["invitedByLogin"],
    "invitedByName": value["invitedByName"],
    "name": value["name"],
    "orgId": value["orgId"],
    "role": value["role"],
    "status": value["status"],
    "url": value["url"]
  };
}

// models/TestReceiverConfigResult.ts
function instanceOfTestReceiverConfigResult(value) {
  return true;
}
function TestReceiverConfigResultFromJSON(json) {
  return TestReceiverConfigResultFromJSONTyped(json);
}
function TestReceiverConfigResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "error": json["error"] == null ? void 0 : json["error"],
    "name": json["name"] == null ? void 0 : json["name"],
    "status": json["status"] == null ? void 0 : json["status"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function TestReceiverConfigResultToJSON(json) {
  return TestReceiverConfigResultToJSONTyped(json, false);
}
function TestReceiverConfigResultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "error": value["error"],
    "name": value["name"],
    "status": value["status"],
    "uid": value["uid"]
  };
}

// models/TestReceiverResult.ts
function instanceOfTestReceiverResult(value) {
  return true;
}
function TestReceiverResultFromJSON(json) {
  return TestReceiverResultFromJSONTyped(json);
}
function TestReceiverResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "grafanaManagedReceiverConfigs": json["grafana_managed_receiver_configs"] == null ? void 0 : json["grafana_managed_receiver_configs"].map(TestReceiverConfigResultFromJSON),
    "name": json["name"] == null ? void 0 : json["name"]
  };
}
function TestReceiverResultToJSON(json) {
  return TestReceiverResultToJSONTyped(json, false);
}
function TestReceiverResultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "grafana_managed_receiver_configs": value["grafanaManagedReceiverConfigs"] == null ? void 0 : value["grafanaManagedReceiverConfigs"].map(TestReceiverConfigResultToJSON),
    "name": value["name"]
  };
}

// models/TestReceiversConfigAlertParams.ts
function instanceOfTestReceiversConfigAlertParams(value) {
  return true;
}
function TestReceiversConfigAlertParamsFromJSON(json) {
  return TestReceiversConfigAlertParamsFromJSONTyped(json);
}
function TestReceiversConfigAlertParamsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "annotations": json["annotations"] == null ? void 0 : json["annotations"],
    "labels": json["labels"] == null ? void 0 : json["labels"]
  };
}
function TestReceiversConfigAlertParamsToJSON(json) {
  return TestReceiversConfigAlertParamsToJSONTyped(json, false);
}
function TestReceiversConfigAlertParamsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "annotations": value["annotations"],
    "labels": value["labels"]
  };
}

// models/TestReceiversConfigBodyParams.ts
function instanceOfTestReceiversConfigBodyParams(value) {
  return true;
}
function TestReceiversConfigBodyParamsFromJSON(json) {
  return TestReceiversConfigBodyParamsFromJSONTyped(json);
}
function TestReceiversConfigBodyParamsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "alert": json["alert"] == null ? void 0 : TestReceiversConfigAlertParamsFromJSON(json["alert"]),
    "receivers": json["receivers"] == null ? void 0 : json["receivers"].map(PostableApiReceiverFromJSON)
  };
}
function TestReceiversConfigBodyParamsToJSON(json) {
  return TestReceiversConfigBodyParamsToJSONTyped(json, false);
}
function TestReceiversConfigBodyParamsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "alert": TestReceiversConfigAlertParamsToJSON(value["alert"]),
    "receivers": value["receivers"] == null ? void 0 : value["receivers"].map(PostableApiReceiverToJSON)
  };
}

// models/TestReceiversResult.ts
function instanceOfTestReceiversResult(value) {
  return true;
}
function TestReceiversResultFromJSON(json) {
  return TestReceiversResultFromJSONTyped(json);
}
function TestReceiversResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "alert": json["alert"] == null ? void 0 : TestReceiversConfigAlertParamsFromJSON(json["alert"]),
    "notifiedAt": json["notified_at"] == null ? void 0 : new Date(json["notified_at"]),
    "receivers": json["receivers"] == null ? void 0 : json["receivers"].map(TestReceiverResultFromJSON)
  };
}
function TestReceiversResultToJSON(json) {
  return TestReceiversResultToJSONTyped(json, false);
}
function TestReceiversResultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "alert": TestReceiversConfigAlertParamsToJSON(value["alert"]),
    "notified_at": value["notifiedAt"] == null ? void 0 : value["notifiedAt"].toISOString(),
    "receivers": value["receivers"] == null ? void 0 : value["receivers"].map(TestReceiverResultToJSON)
  };
}

// models/TestRulePayload.ts
function instanceOfTestRulePayload(value) {
  return true;
}
function TestRulePayloadFromJSON(json) {
  return TestRulePayloadFromJSONTyped(json);
}
function TestRulePayloadFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "expr": json["expr"] == null ? void 0 : json["expr"],
    "grafanaCondition": json["grafana_condition"] == null ? void 0 : EvalAlertConditionCommandFromJSON(json["grafana_condition"])
  };
}
function TestRulePayloadToJSON(json) {
  return TestRulePayloadToJSONTyped(json, false);
}
function TestRulePayloadToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "expr": value["expr"],
    "grafana_condition": EvalAlertConditionCommandToJSON(value["grafanaCondition"])
  };
}

// models/TestRuleResponse.ts
function instanceOfTestRuleResponse(value) {
  return true;
}
function TestRuleResponseFromJSON(json) {
  return TestRuleResponseFromJSONTyped(json);
}
function TestRuleResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "alerts": json["alerts"] == null ? void 0 : json["alerts"].map(SampleFromJSON),
    "grafanaAlertInstances": json["grafana_alert_instances"] == null ? void 0 : AlertInstancesResponseFromJSON(json["grafana_alert_instances"])
  };
}
function TestRuleResponseToJSON(json) {
  return TestRuleResponseToJSONTyped(json, false);
}
function TestRuleResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "alerts": value["alerts"] == null ? void 0 : value["alerts"].map(SampleToJSON),
    "grafana_alert_instances": AlertInstancesResponseToJSON(value["grafanaAlertInstances"])
  };
}

// models/TestTemplatesConfigBodyParams.ts
function instanceOfTestTemplatesConfigBodyParams(value) {
  return true;
}
function TestTemplatesConfigBodyParamsFromJSON(json) {
  return TestTemplatesConfigBodyParamsFromJSONTyped(json);
}
function TestTemplatesConfigBodyParamsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "alerts": json["alerts"] == null ? void 0 : json["alerts"].map(PostableAlertFromJSON),
    "name": json["name"] == null ? void 0 : json["name"],
    "template": json["template"] == null ? void 0 : json["template"]
  };
}
function TestTemplatesConfigBodyParamsToJSON(json) {
  return TestTemplatesConfigBodyParamsToJSONTyped(json, false);
}
function TestTemplatesConfigBodyParamsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "alerts": value["alerts"] == null ? void 0 : value["alerts"].map(PostableAlertToJSON),
    "name": value["name"],
    "template": value["template"]
  };
}

// models/TestTemplatesErrorResult.ts
var TestTemplatesErrorResultKindEnum = {
  InvalidTemplate: "invalid_template",
  ExecutionError: "execution_error"
};
function instanceOfTestTemplatesErrorResult(value) {
  return true;
}
function TestTemplatesErrorResultFromJSON(json) {
  return TestTemplatesErrorResultFromJSONTyped(json);
}
function TestTemplatesErrorResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "kind": json["kind"] == null ? void 0 : json["kind"],
    "message": json["message"] == null ? void 0 : json["message"],
    "name": json["name"] == null ? void 0 : json["name"]
  };
}
function TestTemplatesErrorResultToJSON(json) {
  return TestTemplatesErrorResultToJSONTyped(json, false);
}
function TestTemplatesErrorResultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "kind": value["kind"],
    "message": value["message"],
    "name": value["name"]
  };
}

// models/TestTemplatesResult.ts
function instanceOfTestTemplatesResult(value) {
  return true;
}
function TestTemplatesResultFromJSON(json) {
  return TestTemplatesResultFromJSONTyped(json);
}
function TestTemplatesResultFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "text": json["text"] == null ? void 0 : json["text"]
  };
}
function TestTemplatesResultToJSON(json) {
  return TestTemplatesResultToJSONTyped(json, false);
}
function TestTemplatesResultToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "text": value["text"]
  };
}

// models/TestTemplatesResults.ts
function instanceOfTestTemplatesResults(value) {
  return true;
}
function TestTemplatesResultsFromJSON(json) {
  return TestTemplatesResultsFromJSONTyped(json);
}
function TestTemplatesResultsFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "errors": json["errors"] == null ? void 0 : json["errors"].map(TestTemplatesErrorResultFromJSON),
    "results": json["results"] == null ? void 0 : json["results"].map(TestTemplatesResultFromJSON)
  };
}
function TestTemplatesResultsToJSON(json) {
  return TestTemplatesResultsToJSONTyped(json, false);
}
function TestTemplatesResultsToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "errors": value["errors"] == null ? void 0 : value["errors"].map(TestTemplatesErrorResultToJSON),
    "results": value["results"] == null ? void 0 : value["results"].map(TestTemplatesResultToJSON)
  };
}

// models/Token.ts
function instanceOfToken(value) {
  return true;
}
function TokenFromJSON(json) {
  return TokenFromJSONTyped(json);
}
function TokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "account": json["account"] == null ? void 0 : json["account"],
    "anonymousRatio": json["anonymousRatio"] == null ? void 0 : json["anonymousRatio"],
    "company": json["company"] == null ? void 0 : json["company"],
    "detailsUrl": json["details_url"] == null ? void 0 : json["details_url"],
    "exp": json["exp"] == null ? void 0 : json["exp"],
    "iat": json["iat"] == null ? void 0 : json["iat"],
    "includedUsers": json["included_users"] == null ? void 0 : json["included_users"],
    "iss": json["iss"] == null ? void 0 : json["iss"],
    "jti": json["jti"] == null ? void 0 : json["jti"],
    "lexp": json["lexp"] == null ? void 0 : json["lexp"],
    "licExpWarnDays": json["lic_exp_warn_days"] == null ? void 0 : json["lic_exp_warn_days"],
    "lid": json["lid"] == null ? void 0 : json["lid"],
    "limitBy": json["limit_by"] == null ? void 0 : json["limit_by"],
    "maxConcurrentUserSessions": json["max_concurrent_user_sessions"] == null ? void 0 : json["max_concurrent_user_sessions"],
    "nbf": json["nbf"] == null ? void 0 : json["nbf"],
    "prod": json["prod"] == null ? void 0 : json["prod"],
    "slug": json["slug"] == null ? void 0 : json["slug"],
    "status": json["status"] == null ? void 0 : json["status"],
    "sub": json["sub"] == null ? void 0 : json["sub"],
    "tokExpWarnDays": json["tok_exp_warn_days"] == null ? void 0 : json["tok_exp_warn_days"],
    "trial": json["trial"] == null ? void 0 : json["trial"],
    "trialExp": json["trial_exp"] == null ? void 0 : json["trial_exp"],
    "updateDays": json["update_days"] == null ? void 0 : json["update_days"],
    "usageBilling": json["usage_billing"] == null ? void 0 : json["usage_billing"]
  };
}
function TokenToJSON(json) {
  return TokenToJSONTyped(json, false);
}
function TokenToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "account": value["account"],
    "anonymousRatio": value["anonymousRatio"],
    "company": value["company"],
    "details_url": value["detailsUrl"],
    "exp": value["exp"],
    "iat": value["iat"],
    "included_users": value["includedUsers"],
    "iss": value["iss"],
    "jti": value["jti"],
    "lexp": value["lexp"],
    "lic_exp_warn_days": value["licExpWarnDays"],
    "lid": value["lid"],
    "limit_by": value["limitBy"],
    "max_concurrent_user_sessions": value["maxConcurrentUserSessions"],
    "nbf": value["nbf"],
    "prod": value["prod"],
    "slug": value["slug"],
    "status": value["status"],
    "sub": value["sub"],
    "tok_exp_warn_days": value["tokExpWarnDays"],
    "trial": value["trial"],
    "trial_exp": value["trialExp"],
    "update_days": value["updateDays"],
    "usage_billing": value["usageBilling"]
  };
}

// models/TokenDTO.ts
function instanceOfTokenDTO(value) {
  return true;
}
function TokenDTOFromJSON(json) {
  return TokenDTOFromJSONTyped(json);
}
function TokenDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "created": json["created"] == null ? void 0 : new Date(json["created"]),
    "expiration": json["expiration"] == null ? void 0 : new Date(json["expiration"]),
    "hasExpired": json["hasExpired"] == null ? void 0 : json["hasExpired"],
    "id": json["id"] == null ? void 0 : json["id"],
    "isRevoked": json["isRevoked"] == null ? void 0 : json["isRevoked"],
    "lastUsedAt": json["lastUsedAt"] == null ? void 0 : new Date(json["lastUsedAt"]),
    "name": json["name"] == null ? void 0 : json["name"],
    "secondsUntilExpiration": json["secondsUntilExpiration"] == null ? void 0 : json["secondsUntilExpiration"]
  };
}
function TokenDTOToJSON(json) {
  return TokenDTOToJSONTyped(json, false);
}
function TokenDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "created": value["created"] == null ? void 0 : value["created"].toISOString(),
    "expiration": value["expiration"] == null ? void 0 : value["expiration"].toISOString(),
    "hasExpired": value["hasExpired"],
    "id": value["id"],
    "isRevoked": value["isRevoked"],
    "lastUsedAt": value["lastUsedAt"] == null ? void 0 : value["lastUsedAt"].toISOString(),
    "name": value["name"],
    "secondsUntilExpiration": value["secondsUntilExpiration"]
  };
}

// models/TypeMeta.ts
function instanceOfTypeMeta(value) {
  return true;
}
function TypeMetaFromJSON(json) {
  return TypeMetaFromJSONTyped(json);
}
function TypeMetaFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "apiVersion": json["apiVersion"] == null ? void 0 : json["apiVersion"],
    "kind": json["kind"] == null ? void 0 : json["kind"]
  };
}
function TypeMetaToJSON(json) {
  return TypeMetaToJSONTyped(json, false);
}
function TypeMetaToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "apiVersion": value["apiVersion"],
    "kind": value["kind"]
  };
}

// models/UpdateAnnotationsCmd.ts
function instanceOfUpdateAnnotationsCmd(value) {
  return true;
}
function UpdateAnnotationsCmdFromJSON(json) {
  return UpdateAnnotationsCmdFromJSONTyped(json);
}
function UpdateAnnotationsCmdFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "data": json["data"] == null ? void 0 : json["data"],
    "id": json["id"] == null ? void 0 : json["id"],
    "tags": json["tags"] == null ? void 0 : json["tags"],
    "text": json["text"] == null ? void 0 : json["text"],
    "time": json["time"] == null ? void 0 : json["time"],
    "timeEnd": json["timeEnd"] == null ? void 0 : json["timeEnd"]
  };
}
function UpdateAnnotationsCmdToJSON(json) {
  return UpdateAnnotationsCmdToJSONTyped(json, false);
}
function UpdateAnnotationsCmdToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "data": value["data"],
    "id": value["id"],
    "tags": value["tags"],
    "text": value["text"],
    "time": value["time"],
    "timeEnd": value["timeEnd"]
  };
}

// models/UpdateCorrelationCommand.ts
function instanceOfUpdateCorrelationCommand(value) {
  return true;
}
function UpdateCorrelationCommandFromJSON(json) {
  return UpdateCorrelationCommandFromJSONTyped(json);
}
function UpdateCorrelationCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "config": json["config"] == null ? void 0 : CorrelationConfigUpdateDTOFromJSON(json["config"]),
    "description": json["description"] == null ? void 0 : json["description"],
    "label": json["label"] == null ? void 0 : json["label"]
  };
}
function UpdateCorrelationCommandToJSON(json) {
  return UpdateCorrelationCommandToJSONTyped(json, false);
}
function UpdateCorrelationCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "config": CorrelationConfigUpdateDTOToJSON(value["config"]),
    "description": value["description"],
    "label": value["label"]
  };
}

// models/UpdateCorrelationResponseBody.ts
function instanceOfUpdateCorrelationResponseBody(value) {
  return true;
}
function UpdateCorrelationResponseBodyFromJSON(json) {
  return UpdateCorrelationResponseBodyFromJSONTyped(json);
}
function UpdateCorrelationResponseBodyFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "message": json["message"] == null ? void 0 : json["message"],
    "result": json["result"] == null ? void 0 : CorrelationFromJSON(json["result"])
  };
}
function UpdateCorrelationResponseBodyToJSON(json) {
  return UpdateCorrelationResponseBodyToJSONTyped(json, false);
}
function UpdateCorrelationResponseBodyToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "message": value["message"],
    "result": CorrelationToJSON(value["result"])
  };
}

// models/UpdateDashboardACLCommand.ts
function instanceOfUpdateDashboardACLCommand(value) {
  return true;
}
function UpdateDashboardACLCommandFromJSON(json) {
  return UpdateDashboardACLCommandFromJSONTyped(json);
}
function UpdateDashboardACLCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "items": json["items"] == null ? void 0 : json["items"].map(DashboardACLUpdateItemFromJSON)
  };
}
function UpdateDashboardACLCommandToJSON(json) {
  return UpdateDashboardACLCommandToJSONTyped(json, false);
}
function UpdateDashboardACLCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "items": value["items"] == null ? void 0 : value["items"].map(DashboardACLUpdateItemToJSON)
  };
}

// models/UpdateDataSourceCommand.ts
function instanceOfUpdateDataSourceCommand(value) {
  return true;
}
function UpdateDataSourceCommandFromJSON(json) {
  return UpdateDataSourceCommandFromJSONTyped(json);
}
function UpdateDataSourceCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "access": json["access"] == null ? void 0 : json["access"],
    "basicAuth": json["basicAuth"] == null ? void 0 : json["basicAuth"],
    "basicAuthUser": json["basicAuthUser"] == null ? void 0 : json["basicAuthUser"],
    "database": json["database"] == null ? void 0 : json["database"],
    "isDefault": json["isDefault"] == null ? void 0 : json["isDefault"],
    "jsonData": json["jsonData"] == null ? void 0 : json["jsonData"],
    "name": json["name"] == null ? void 0 : json["name"],
    "secureJsonData": json["secureJsonData"] == null ? void 0 : json["secureJsonData"],
    "type": json["type"] == null ? void 0 : json["type"],
    "uid": json["uid"] == null ? void 0 : json["uid"],
    "url": json["url"] == null ? void 0 : json["url"],
    "user": json["user"] == null ? void 0 : json["user"],
    "version": json["version"] == null ? void 0 : json["version"],
    "withCredentials": json["withCredentials"] == null ? void 0 : json["withCredentials"]
  };
}
function UpdateDataSourceCommandToJSON(json) {
  return UpdateDataSourceCommandToJSONTyped(json, false);
}
function UpdateDataSourceCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "access": value["access"],
    "basicAuth": value["basicAuth"],
    "basicAuthUser": value["basicAuthUser"],
    "database": value["database"],
    "isDefault": value["isDefault"],
    "jsonData": value["jsonData"],
    "name": value["name"],
    "secureJsonData": value["secureJsonData"],
    "type": value["type"],
    "uid": value["uid"],
    "url": value["url"],
    "user": value["user"],
    "version": value["version"],
    "withCredentials": value["withCredentials"]
  };
}

// models/UpdateFolderCommand.ts
function instanceOfUpdateFolderCommand(value) {
  return true;
}
function UpdateFolderCommandFromJSON(json) {
  return UpdateFolderCommandFromJSONTyped(json);
}
function UpdateFolderCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "description": json["description"] == null ? void 0 : json["description"],
    "overwrite": json["overwrite"] == null ? void 0 : json["overwrite"],
    "title": json["title"] == null ? void 0 : json["title"],
    "version": json["version"] == null ? void 0 : json["version"]
  };
}
function UpdateFolderCommandToJSON(json) {
  return UpdateFolderCommandToJSONTyped(json, false);
}
function UpdateFolderCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "description": value["description"],
    "overwrite": value["overwrite"],
    "title": value["title"],
    "version": value["version"]
  };
}

// models/UpdateOrgAddressForm.ts
function instanceOfUpdateOrgAddressForm(value) {
  return true;
}
function UpdateOrgAddressFormFromJSON(json) {
  return UpdateOrgAddressFormFromJSONTyped(json);
}
function UpdateOrgAddressFormFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "address1": json["address1"] == null ? void 0 : json["address1"],
    "address2": json["address2"] == null ? void 0 : json["address2"],
    "city": json["city"] == null ? void 0 : json["city"],
    "country": json["country"] == null ? void 0 : json["country"],
    "state": json["state"] == null ? void 0 : json["state"],
    "zipcode": json["zipcode"] == null ? void 0 : json["zipcode"]
  };
}
function UpdateOrgAddressFormToJSON(json) {
  return UpdateOrgAddressFormToJSONTyped(json, false);
}
function UpdateOrgAddressFormToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "address1": value["address1"],
    "address2": value["address2"],
    "city": value["city"],
    "country": value["country"],
    "state": value["state"],
    "zipcode": value["zipcode"]
  };
}

// models/UpdateOrgForm.ts
function instanceOfUpdateOrgForm(value) {
  return true;
}
function UpdateOrgFormFromJSON(json) {
  return UpdateOrgFormFromJSONTyped(json);
}
function UpdateOrgFormFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"]
  };
}
function UpdateOrgFormToJSON(json) {
  return UpdateOrgFormToJSONTyped(json, false);
}
function UpdateOrgFormToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"]
  };
}

// models/UpdateOrgUserCommand.ts
var UpdateOrgUserCommandRoleEnum = {
  None: "None",
  Viewer: "Viewer",
  Editor: "Editor",
  Admin: "Admin"
};
function instanceOfUpdateOrgUserCommand(value) {
  return true;
}
function UpdateOrgUserCommandFromJSON(json) {
  return UpdateOrgUserCommandFromJSONTyped(json);
}
function UpdateOrgUserCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "role": json["role"] == null ? void 0 : json["role"]
  };
}
function UpdateOrgUserCommandToJSON(json) {
  return UpdateOrgUserCommandToJSONTyped(json, false);
}
function UpdateOrgUserCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "role": value["role"]
  };
}

// models/UpdatePlaylistCommand.ts
function instanceOfUpdatePlaylistCommand(value) {
  return true;
}
function UpdatePlaylistCommandFromJSON(json) {
  return UpdatePlaylistCommandFromJSONTyped(json);
}
function UpdatePlaylistCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "interval": json["interval"] == null ? void 0 : json["interval"],
    "items": json["items"] == null ? void 0 : json["items"].map(PlaylistItemFromJSON),
    "name": json["name"] == null ? void 0 : json["name"],
    "uid": json["uid"] == null ? void 0 : json["uid"]
  };
}
function UpdatePlaylistCommandToJSON(json) {
  return UpdatePlaylistCommandToJSONTyped(json, false);
}
function UpdatePlaylistCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "interval": value["interval"],
    "items": value["items"] == null ? void 0 : value["items"].map(PlaylistItemToJSON),
    "name": value["name"],
    "uid": value["uid"]
  };
}

// models/UpdatePrefsCmd.ts
var UpdatePrefsCmdThemeEnum = {
  Light: "light",
  Dark: "dark",
  System: "system"
};
var UpdatePrefsCmdTimezoneEnum = {
  Utc: "utc",
  Browser: "browser"
};
function instanceOfUpdatePrefsCmd(value) {
  return true;
}
function UpdatePrefsCmdFromJSON(json) {
  return UpdatePrefsCmdFromJSONTyped(json);
}
function UpdatePrefsCmdFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "cookies": json["cookies"] == null ? void 0 : json["cookies"],
    "homeDashboardId": json["homeDashboardId"] == null ? void 0 : json["homeDashboardId"],
    "homeDashboardUID": json["homeDashboardUID"] == null ? void 0 : json["homeDashboardUID"],
    "language": json["language"] == null ? void 0 : json["language"],
    "queryHistory": json["queryHistory"] == null ? void 0 : QueryHistoryPreferenceFromJSON(json["queryHistory"]),
    "theme": json["theme"] == null ? void 0 : json["theme"],
    "timezone": json["timezone"] == null ? void 0 : json["timezone"],
    "weekStart": json["weekStart"] == null ? void 0 : json["weekStart"]
  };
}
function UpdatePrefsCmdToJSON(json) {
  return UpdatePrefsCmdToJSONTyped(json, false);
}
function UpdatePrefsCmdToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "cookies": value["cookies"],
    "homeDashboardId": value["homeDashboardId"],
    "homeDashboardUID": value["homeDashboardUID"],
    "language": value["language"],
    "queryHistory": QueryHistoryPreferenceToJSON(value["queryHistory"]),
    "theme": value["theme"],
    "timezone": value["timezone"],
    "weekStart": value["weekStart"]
  };
}

// models/UpdateProviderSettingsRequest.ts
function instanceOfUpdateProviderSettingsRequest(value) {
  return true;
}
function UpdateProviderSettingsRequestFromJSON(json) {
  return UpdateProviderSettingsRequestFromJSONTyped(json);
}
function UpdateProviderSettingsRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"] == null ? void 0 : json["id"],
    "provider": json["provider"] == null ? void 0 : json["provider"],
    "settings": json["settings"] == null ? void 0 : json["settings"]
  };
}
function UpdateProviderSettingsRequestToJSON(json) {
  return UpdateProviderSettingsRequestToJSONTyped(json, false);
}
function UpdateProviderSettingsRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "provider": value["provider"],
    "settings": value["settings"]
  };
}

// models/UpdateQuotaCmd.ts
function instanceOfUpdateQuotaCmd(value) {
  return true;
}
function UpdateQuotaCmdFromJSON(json) {
  return UpdateQuotaCmdFromJSONTyped(json);
}
function UpdateQuotaCmdFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "limit": json["limit"] == null ? void 0 : json["limit"],
    "target": json["target"] == null ? void 0 : json["target"]
  };
}
function UpdateQuotaCmdToJSON(json) {
  return UpdateQuotaCmdToJSONTyped(json, false);
}
function UpdateQuotaCmdToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "limit": value["limit"],
    "target": value["target"]
  };
}

// models/UpdateRoleCommand.ts
function instanceOfUpdateRoleCommand(value) {
  return true;
}
function UpdateRoleCommandFromJSON(json) {
  return UpdateRoleCommandFromJSONTyped(json);
}
function UpdateRoleCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "description": json["description"] == null ? void 0 : json["description"],
    "displayName": json["displayName"] == null ? void 0 : json["displayName"],
    "global": json["global"] == null ? void 0 : json["global"],
    "group": json["group"] == null ? void 0 : json["group"],
    "hidden": json["hidden"] == null ? void 0 : json["hidden"],
    "name": json["name"] == null ? void 0 : json["name"],
    "permissions": json["permissions"] == null ? void 0 : json["permissions"].map(PermissionFromJSON),
    "version": json["version"] == null ? void 0 : json["version"]
  };
}
function UpdateRoleCommandToJSON(json) {
  return UpdateRoleCommandToJSONTyped(json, false);
}
function UpdateRoleCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "description": value["description"],
    "displayName": value["displayName"],
    "global": value["global"],
    "group": value["group"],
    "hidden": value["hidden"],
    "name": value["name"],
    "permissions": value["permissions"] == null ? void 0 : value["permissions"].map(PermissionToJSON),
    "version": value["version"]
  };
}

// models/UpdateRuleGroupResponse.ts
function instanceOfUpdateRuleGroupResponse(value) {
  return true;
}
function UpdateRuleGroupResponseFromJSON(json) {
  return UpdateRuleGroupResponseFromJSONTyped(json);
}
function UpdateRuleGroupResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "created": json["created"] == null ? void 0 : json["created"],
    "deleted": json["deleted"] == null ? void 0 : json["deleted"],
    "message": json["message"] == null ? void 0 : json["message"],
    "updated": json["updated"] == null ? void 0 : json["updated"]
  };
}
function UpdateRuleGroupResponseToJSON(json) {
  return UpdateRuleGroupResponseToJSONTyped(json, false);
}
function UpdateRuleGroupResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "created": value["created"],
    "deleted": value["deleted"],
    "message": value["message"],
    "updated": value["updated"]
  };
}

// models/UpdateServiceAccount200Response.ts
function instanceOfUpdateServiceAccount200Response(value) {
  return true;
}
function UpdateServiceAccount200ResponseFromJSON(json) {
  return UpdateServiceAccount200ResponseFromJSONTyped(json);
}
function UpdateServiceAccount200ResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"] == null ? void 0 : json["id"],
    "message": json["message"] == null ? void 0 : json["message"],
    "name": json["name"] == null ? void 0 : json["name"],
    "serviceaccount": json["serviceaccount"] == null ? void 0 : ServiceAccountProfileDTOFromJSON(json["serviceaccount"])
  };
}
function UpdateServiceAccount200ResponseToJSON(json) {
  return UpdateServiceAccount200ResponseToJSONTyped(json, false);
}
function UpdateServiceAccount200ResponseToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "message": value["message"],
    "name": value["name"],
    "serviceaccount": ServiceAccountProfileDTOToJSON(value["serviceaccount"])
  };
}

// models/UpdateServiceAccountForm.ts
var UpdateServiceAccountFormRoleEnum = {
  None: "None",
  Viewer: "Viewer",
  Editor: "Editor",
  Admin: "Admin"
};
function instanceOfUpdateServiceAccountForm(value) {
  return true;
}
function UpdateServiceAccountFormFromJSON(json) {
  return UpdateServiceAccountFormFromJSONTyped(json);
}
function UpdateServiceAccountFormFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "isDisabled": json["isDisabled"] == null ? void 0 : json["isDisabled"],
    "name": json["name"] == null ? void 0 : json["name"],
    "role": json["role"] == null ? void 0 : json["role"],
    "serviceAccountId": json["serviceAccountId"] == null ? void 0 : json["serviceAccountId"]
  };
}
function UpdateServiceAccountFormToJSON(json) {
  return UpdateServiceAccountFormToJSONTyped(json, false);
}
function UpdateServiceAccountFormToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "isDisabled": value["isDisabled"],
    "name": value["name"],
    "role": value["role"],
    "serviceAccountId": value["serviceAccountId"]
  };
}

// models/UpdateTeamCommand.ts
function instanceOfUpdateTeamCommand(value) {
  return true;
}
function UpdateTeamCommandFromJSON(json) {
  return UpdateTeamCommandFromJSONTyped(json);
}
function UpdateTeamCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "email": json["Email"] == null ? void 0 : json["Email"],
    "iD": json["ID"] == null ? void 0 : json["ID"],
    "name": json["Name"] == null ? void 0 : json["Name"]
  };
}
function UpdateTeamCommandToJSON(json) {
  return UpdateTeamCommandToJSONTyped(json, false);
}
function UpdateTeamCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "Email": value["email"],
    "ID": value["iD"],
    "Name": value["name"]
  };
}

// models/UpdateTeamMemberCommand.ts
function instanceOfUpdateTeamMemberCommand(value) {
  return true;
}
function UpdateTeamMemberCommandFromJSON(json) {
  return UpdateTeamMemberCommandFromJSONTyped(json);
}
function UpdateTeamMemberCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "permission": json["permission"] == null ? void 0 : json["permission"]
  };
}
function UpdateTeamMemberCommandToJSON(json) {
  return UpdateTeamMemberCommandToJSONTyped(json, false);
}
function UpdateTeamMemberCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "permission": value["permission"]
  };
}

// models/UpdateUserCommand.ts
function instanceOfUpdateUserCommand(value) {
  return true;
}
function UpdateUserCommandFromJSON(json) {
  return UpdateUserCommandFromJSONTyped(json);
}
function UpdateUserCommandFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "email": json["email"] == null ? void 0 : json["email"],
    "login": json["login"] == null ? void 0 : json["login"],
    "name": json["name"] == null ? void 0 : json["name"],
    "theme": json["theme"] == null ? void 0 : json["theme"]
  };
}
function UpdateUserCommandToJSON(json) {
  return UpdateUserCommandToJSONTyped(json, false);
}
function UpdateUserCommandToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "email": value["email"],
    "login": value["login"],
    "name": value["name"],
    "theme": value["theme"]
  };
}

// models/UserLookupDTO.ts
function instanceOfUserLookupDTO(value) {
  return true;
}
function UserLookupDTOFromJSON(json) {
  return UserLookupDTOFromJSONTyped(json);
}
function UserLookupDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "avatarUrl": json["avatarUrl"] == null ? void 0 : json["avatarUrl"],
    "login": json["login"] == null ? void 0 : json["login"],
    "userId": json["userId"] == null ? void 0 : json["userId"]
  };
}
function UserLookupDTOToJSON(json) {
  return UserLookupDTOToJSONTyped(json, false);
}
function UserLookupDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "avatarUrl": value["avatarUrl"],
    "login": value["login"],
    "userId": value["userId"]
  };
}

// models/UserOrgDTO.ts
var UserOrgDTORoleEnum = {
  None: "None",
  Viewer: "Viewer",
  Editor: "Editor",
  Admin: "Admin"
};
function instanceOfUserOrgDTO(value) {
  return true;
}
function UserOrgDTOFromJSON(json) {
  return UserOrgDTOFromJSONTyped(json);
}
function UserOrgDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "name": json["name"] == null ? void 0 : json["name"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "role": json["role"] == null ? void 0 : json["role"]
  };
}
function UserOrgDTOToJSON(json) {
  return UserOrgDTOToJSONTyped(json, false);
}
function UserOrgDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "name": value["name"],
    "orgId": value["orgId"],
    "role": value["role"]
  };
}

// models/UserProfileDTO.ts
function instanceOfUserProfileDTO(value) {
  return true;
}
function UserProfileDTOFromJSON(json) {
  return UserProfileDTOFromJSONTyped(json);
}
function UserProfileDTOFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "accessControl": json["accessControl"] == null ? void 0 : json["accessControl"],
    "authLabels": json["authLabels"] == null ? void 0 : json["authLabels"],
    "avatarUrl": json["avatarUrl"] == null ? void 0 : json["avatarUrl"],
    "createdAt": json["createdAt"] == null ? void 0 : new Date(json["createdAt"]),
    "email": json["email"] == null ? void 0 : json["email"],
    "id": json["id"] == null ? void 0 : json["id"],
    "isDisabled": json["isDisabled"] == null ? void 0 : json["isDisabled"],
    "isExternal": json["isExternal"] == null ? void 0 : json["isExternal"],
    "isExternallySynced": json["isExternallySynced"] == null ? void 0 : json["isExternallySynced"],
    "isGrafanaAdmin": json["isGrafanaAdmin"] == null ? void 0 : json["isGrafanaAdmin"],
    "isGrafanaAdminExternallySynced": json["isGrafanaAdminExternallySynced"] == null ? void 0 : json["isGrafanaAdminExternallySynced"],
    "login": json["login"] == null ? void 0 : json["login"],
    "name": json["name"] == null ? void 0 : json["name"],
    "orgId": json["orgId"] == null ? void 0 : json["orgId"],
    "theme": json["theme"] == null ? void 0 : json["theme"],
    "uid": json["uid"] == null ? void 0 : json["uid"],
    "updatedAt": json["updatedAt"] == null ? void 0 : new Date(json["updatedAt"])
  };
}
function UserProfileDTOToJSON(json) {
  return UserProfileDTOToJSONTyped(json, false);
}
function UserProfileDTOToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "accessControl": value["accessControl"],
    "authLabels": value["authLabels"],
    "avatarUrl": value["avatarUrl"],
    "createdAt": value["createdAt"] == null ? void 0 : value["createdAt"].toISOString(),
    "email": value["email"],
    "id": value["id"],
    "isDisabled": value["isDisabled"],
    "isExternal": value["isExternal"],
    "isExternallySynced": value["isExternallySynced"],
    "isGrafanaAdmin": value["isGrafanaAdmin"],
    "isGrafanaAdminExternallySynced": value["isGrafanaAdminExternallySynced"],
    "login": value["login"],
    "name": value["name"],
    "orgId": value["orgId"],
    "theme": value["theme"],
    "uid": value["uid"],
    "updatedAt": value["updatedAt"] == null ? void 0 : value["updatedAt"].toISOString()
  };
}

// models/UserToken.ts
function instanceOfUserToken(value) {
  return true;
}
function UserTokenFromJSON(json) {
  return UserTokenFromJSONTyped(json);
}
function UserTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "authToken": json["AuthToken"] == null ? void 0 : json["AuthToken"],
    "authTokenSeen": json["AuthTokenSeen"] == null ? void 0 : json["AuthTokenSeen"],
    "clientIp": json["ClientIp"] == null ? void 0 : json["ClientIp"],
    "createdAt": json["CreatedAt"] == null ? void 0 : json["CreatedAt"],
    "id": json["Id"] == null ? void 0 : json["Id"],
    "prevAuthToken": json["PrevAuthToken"] == null ? void 0 : json["PrevAuthToken"],
    "revokedAt": json["RevokedAt"] == null ? void 0 : json["RevokedAt"],
    "rotatedAt": json["RotatedAt"] == null ? void 0 : json["RotatedAt"],
    "seenAt": json["SeenAt"] == null ? void 0 : json["SeenAt"],
    "unhashedToken": json["UnhashedToken"] == null ? void 0 : json["UnhashedToken"],
    "updatedAt": json["UpdatedAt"] == null ? void 0 : json["UpdatedAt"],
    "userAgent": json["UserAgent"] == null ? void 0 : json["UserAgent"],
    "userId": json["UserId"] == null ? void 0 : json["UserId"]
  };
}
function UserTokenToJSON(json) {
  return UserTokenToJSONTyped(json, false);
}
function UserTokenToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "AuthToken": value["authToken"],
    "AuthTokenSeen": value["authTokenSeen"],
    "ClientIp": value["clientIp"],
    "CreatedAt": value["createdAt"],
    "Id": value["id"],
    "PrevAuthToken": value["prevAuthToken"],
    "RevokedAt": value["revokedAt"],
    "RotatedAt": value["rotatedAt"],
    "SeenAt": value["seenAt"],
    "UnhashedToken": value["unhashedToken"],
    "UpdatedAt": value["updatedAt"],
    "UserAgent": value["userAgent"],
    "UserId": value["userId"]
  };
}

// models/ValidationError.ts
function instanceOfValidationError(value) {
  return true;
}
function ValidationErrorFromJSON(json) {
  return ValidationErrorFromJSONTyped(json);
}
function ValidationErrorFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "msg": json["msg"] == null ? void 0 : json["msg"]
  };
}
function ValidationErrorToJSON(json) {
  return ValidationErrorToJSONTyped(json, false);
}
function ValidationErrorToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "msg": value["msg"]
  };
}

// apis/AccessControlApi.ts
var AccessControlApi = class extends BaseAPI {
  /**
   * You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`.
   * Add team role.
   */
  async addTeamRoleRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling addTeamRole().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling addTeamRole().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/teams/{teamId}/roles`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AddTeamRoleCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`.
   * Add team role.
   */
  async addTeamRole(requestParameters, initOverrides) {
    const response = await this.addTeamRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Assign a role to a specific user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
   * Add a user role assignment.
   */
  async addUserRoleRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling addUserRole().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling addUserRole().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/users/{userId}/roles`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AddUserRoleCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Assign a role to a specific user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
   * Add a user role assignment.
   */
  async addUserRole(requestParameters, initOverrides) {
    const response = await this.addUserRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.  You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
   * Create a new custom role.
   */
  async createRoleRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createRole().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/roles`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateRoleFormToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RoleDTOFromJSON(jsonValue));
  }
  /**
   * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.  You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
   * Create a new custom role.
   */
  async createRole(requestParameters, initOverrides) {
    const response = await this.createRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.  You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
   * Delete a custom role.
   */
  async deleteRoleRaw(requestParameters, initOverrides) {
    if (requestParameters["roleUID"] == null) {
      throw new RequiredError(
        "roleUID",
        'Required parameter "roleUID" was null or undefined when calling deleteRole().'
      );
    }
    const queryParameters = {};
    if (requestParameters["force"] != null) {
      queryParameters["force"] = requestParameters["force"];
    }
    if (requestParameters["global"] != null) {
      queryParameters["global"] = requestParameters["global"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters["roleUID"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.  You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
   * Delete a custom role.
   */
  async deleteRole(requestParameters, initOverrides) {
    const response = await this.deleteRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Returns an indicator to check if fine-grained access control is enabled or not.  You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
   * Get status.
   */
  async getAccessControlStatusRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/status`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * Returns an indicator to check if fine-grained access control is enabled or not.  You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
   * Get status.
   */
  async getAccessControlStatus(initOverrides) {
    const response = await this.getAccessControlStatusRaw(initOverrides);
    return await response.value();
  }
  /**
   * Get a description of a resource\'s access control properties.
   */
  async getResourceDescriptionRaw(requestParameters, initOverrides) {
    if (requestParameters["resource"] == null) {
      throw new RequiredError(
        "resource",
        'Required parameter "resource" was null or undefined when calling getResourceDescription().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/{resource}/description`.replace(`{${"resource"}}`, encodeURIComponent(String(requestParameters["resource"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DescriptionFromJSON(jsonValue));
  }
  /**
   * Get a description of a resource\'s access control properties.
   */
  async getResourceDescription(requestParameters, initOverrides) {
    const response = await this.getResourceDescriptionRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get permissions for a resource.
   */
  async getResourcePermissionsRaw(requestParameters, initOverrides) {
    if (requestParameters["resource"] == null) {
      throw new RequiredError(
        "resource",
        'Required parameter "resource" was null or undefined when calling getResourcePermissions().'
      );
    }
    if (requestParameters["resourceID"] == null) {
      throw new RequiredError(
        "resourceID",
        'Required parameter "resourceID" was null or undefined when calling getResourcePermissions().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/{resource}/{resourceID}`.replace(`{${"resource"}}`, encodeURIComponent(String(requestParameters["resource"]))).replace(`{${"resourceID"}}`, encodeURIComponent(String(requestParameters["resourceID"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(ResourcePermissionDTOFromJSON));
  }
  /**
   * Get permissions for a resource.
   */
  async getResourcePermissions(requestParameters, initOverrides) {
    const response = await this.getResourcePermissionsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a role for the given UID.  You need to have a permission with action `roles:read` and scope `roles:*`.
   * Get a role.
   */
  async getRoleRaw(requestParameters, initOverrides) {
    if (requestParameters["roleUID"] == null) {
      throw new RequiredError(
        "roleUID",
        'Required parameter "roleUID" was null or undefined when calling getRole().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters["roleUID"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RoleDTOFromJSON(jsonValue));
  }
  /**
   * Get a role for the given UID.  You need to have a permission with action `roles:read` and scope `roles:*`.
   * Get a role.
   */
  async getRole(requestParameters, initOverrides) {
    const response = await this.getRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
   * Get role assignments.
   */
  async getRoleAssignmentsRaw(requestParameters, initOverrides) {
    if (requestParameters["roleUID"] == null) {
      throw new RequiredError(
        "roleUID",
        'Required parameter "roleUID" was null or undefined when calling getRoleAssignments().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/roles/{roleUID}/assignments`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters["roleUID"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RoleAssignmentsDTOFromJSON(jsonValue));
  }
  /**
   * Get role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
   * Get role assignments.
   */
  async getRoleAssignments(requestParameters, initOverrides) {
    const response = await this.getRoleAssignmentsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.  You need to have a permission with action `roles:read` and scope `roles:*`.
   * Get all roles.
   */
  async listRolesRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["delegatable"] != null) {
      queryParameters["delegatable"] = requestParameters["delegatable"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/roles`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(RoleDTOFromJSON));
  }
  /**
   * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.  You need to have a permission with action `roles:read` and scope `roles:*`.
   * Get all roles.
   */
  async listRoles(requestParameters = {}, initOverrides) {
    const response = await this.listRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`.
   * Get team roles.
   */
  async listTeamRolesRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling listTeamRoles().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/teams/{teamId}/roles`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`.
   * Get team roles.
   */
  async listTeamRoles(requestParameters, initOverrides) {
    const response = await this.listTeamRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Lists the roles that have been directly assigned to the given teams.  You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
   * List roles assigned to multiple teams.
   */
  async listTeamsRolesRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling listTeamsRoles().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/teams/roles/search`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RolesSearchQueryToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response);
  }
  /**
   * Lists the roles that have been directly assigned to the given teams.  You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
   * List roles assigned to multiple teams.
   */
  async listTeamsRoles(requestParameters, initOverrides) {
    const response = await this.listTeamsRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
   * List roles assigned to a user.
   */
  async listUserRolesRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling listUserRoles().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/users/{userId}/roles`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(RoleDTOFromJSON));
  }
  /**
   * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
   * List roles assigned to a user.
   */
  async listUserRoles(requestParameters, initOverrides) {
    const response = await this.listUserRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:*`.
   * List roles assigned to multiple users.
   */
  async listUsersRolesRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling listUsersRoles().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/users/roles/search`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RolesSearchQueryToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response);
  }
  /**
   * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:*`.
   * List roles assigned to multiple users.
   */
  async listUsersRoles(requestParameters, initOverrides) {
    const response = await this.listUsersRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`.
   * Remove team role.
   */
  async removeTeamRoleRaw(requestParameters, initOverrides) {
    if (requestParameters["roleUID"] == null) {
      throw new RequiredError(
        "roleUID",
        'Required parameter "roleUID" was null or undefined when calling removeTeamRole().'
      );
    }
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling removeTeamRole().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/teams/{teamId}/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters["roleUID"]))).replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`.
   * Remove team role.
   */
  async removeTeamRole(requestParameters, initOverrides) {
    const response = await this.removeTeamRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Revoke a role from a user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
   * Remove a user role assignment.
   */
  async removeUserRoleRaw(requestParameters, initOverrides) {
    if (requestParameters["roleUID"] == null) {
      throw new RequiredError(
        "roleUID",
        'Required parameter "roleUID" was null or undefined when calling removeUserRole().'
      );
    }
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling removeUserRole().'
      );
    }
    const queryParameters = {};
    if (requestParameters["global"] != null) {
      queryParameters["global"] = requestParameters["global"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/users/{userId}/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters["roleUID"]))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Revoke a role from a user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
   * Remove a user role assignment.
   */
  async removeUserRole(requestParameters, initOverrides) {
    const response = await this.removeUserRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to one or many assignment types. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
   * Set resource permissions.
   */
  async setResourcePermissionsRaw(requestParameters, initOverrides) {
    if (requestParameters["resource"] == null) {
      throw new RequiredError(
        "resource",
        'Required parameter "resource" was null or undefined when calling setResourcePermissions().'
      );
    }
    if (requestParameters["resourceID"] == null) {
      throw new RequiredError(
        "resourceID",
        'Required parameter "resourceID" was null or undefined when calling setResourcePermissions().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling setResourcePermissions().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/{resource}/{resourceID}`.replace(`{${"resource"}}`, encodeURIComponent(String(requestParameters["resource"]))).replace(`{${"resourceID"}}`, encodeURIComponent(String(requestParameters["resourceID"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SetPermissionsCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to one or many assignment types. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
   * Set resource permissions.
   */
  async setResourcePermissions(requestParameters, initOverrides) {
    const response = await this.setResourcePermissionsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a built-in role. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
   * Set resource permissions for a built-in role.
   */
  async setResourcePermissionsForBuiltInRoleRaw(requestParameters, initOverrides) {
    if (requestParameters["resource"] == null) {
      throw new RequiredError(
        "resource",
        'Required parameter "resource" was null or undefined when calling setResourcePermissionsForBuiltInRole().'
      );
    }
    if (requestParameters["resourceID"] == null) {
      throw new RequiredError(
        "resourceID",
        'Required parameter "resourceID" was null or undefined when calling setResourcePermissionsForBuiltInRole().'
      );
    }
    if (requestParameters["builtInRole"] == null) {
      throw new RequiredError(
        "builtInRole",
        'Required parameter "builtInRole" was null or undefined when calling setResourcePermissionsForBuiltInRole().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling setResourcePermissionsForBuiltInRole().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/{resource}/{resourceID}/builtInRoles/{builtInRole}`.replace(`{${"resource"}}`, encodeURIComponent(String(requestParameters["resource"]))).replace(`{${"resourceID"}}`, encodeURIComponent(String(requestParameters["resourceID"]))).replace(`{${"builtInRole"}}`, encodeURIComponent(String(requestParameters["builtInRole"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SetPermissionCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a built-in role. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
   * Set resource permissions for a built-in role.
   */
  async setResourcePermissionsForBuiltInRole(requestParameters, initOverrides) {
    const response = await this.setResourcePermissionsForBuiltInRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a team. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
   * Set resource permissions for a team.
   */
  async setResourcePermissionsForTeamRaw(requestParameters, initOverrides) {
    if (requestParameters["resource"] == null) {
      throw new RequiredError(
        "resource",
        'Required parameter "resource" was null or undefined when calling setResourcePermissionsForTeam().'
      );
    }
    if (requestParameters["resourceID"] == null) {
      throw new RequiredError(
        "resourceID",
        'Required parameter "resourceID" was null or undefined when calling setResourcePermissionsForTeam().'
      );
    }
    if (requestParameters["teamID"] == null) {
      throw new RequiredError(
        "teamID",
        'Required parameter "teamID" was null or undefined when calling setResourcePermissionsForTeam().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling setResourcePermissionsForTeam().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/{resource}/{resourceID}/teams/{teamID}`.replace(`{${"resource"}}`, encodeURIComponent(String(requestParameters["resource"]))).replace(`{${"resourceID"}}`, encodeURIComponent(String(requestParameters["resourceID"]))).replace(`{${"teamID"}}`, encodeURIComponent(String(requestParameters["teamID"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SetPermissionCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a team. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
   * Set resource permissions for a team.
   */
  async setResourcePermissionsForTeam(requestParameters, initOverrides) {
    const response = await this.setResourcePermissionsForTeamRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a user or a service account. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
   * Set resource permissions for a user.
   */
  async setResourcePermissionsForUserRaw(requestParameters, initOverrides) {
    if (requestParameters["resource"] == null) {
      throw new RequiredError(
        "resource",
        'Required parameter "resource" was null or undefined when calling setResourcePermissionsForUser().'
      );
    }
    if (requestParameters["resourceID"] == null) {
      throw new RequiredError(
        "resourceID",
        'Required parameter "resourceID" was null or undefined when calling setResourcePermissionsForUser().'
      );
    }
    if (requestParameters["userID"] == null) {
      throw new RequiredError(
        "userID",
        'Required parameter "userID" was null or undefined when calling setResourcePermissionsForUser().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling setResourcePermissionsForUser().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/{resource}/{resourceID}/users/{userID}`.replace(`{${"resource"}}`, encodeURIComponent(String(requestParameters["resource"]))).replace(`{${"resourceID"}}`, encodeURIComponent(String(requestParameters["resourceID"]))).replace(`{${"userID"}}`, encodeURIComponent(String(requestParameters["userID"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SetPermissionCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a user or a service account. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
   * Set resource permissions for a user.
   */
  async setResourcePermissionsForUser(requestParameters, initOverrides) {
    const response = await this.setResourcePermissionsForUserRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Set role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
   * Set role assignments.
   */
  async setRoleAssignmentsRaw(requestParameters, initOverrides) {
    if (requestParameters["roleUID"] == null) {
      throw new RequiredError(
        "roleUID",
        'Required parameter "roleUID" was null or undefined when calling setRoleAssignments().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling setRoleAssignments().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/roles/{roleUID}/assignments`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters["roleUID"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: SetRoleAssignmentsCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RoleAssignmentsDTOFromJSON(jsonValue));
  }
  /**
   * Set role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
   * Set role assignments.
   */
  async setRoleAssignments(requestParameters, initOverrides) {
    const response = await this.setRoleAssignmentsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each.
   * Update team role.
   */
  async setTeamRolesRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling setTeamRoles().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/teams/{teamId}/roles`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each.
   * Update team role.
   */
  async setTeamRoles(requestParameters, initOverrides) {
    const response = await this.setTeamRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user. If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.  You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
   * Set user role assignments.
   */
  async setUserRolesRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling setUserRoles().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling setUserRoles().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/users/{userId}/roles`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: SetUserRolesCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user. If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.  You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
   * Set user role assignments.
   */
  async setUserRoles(requestParameters, initOverrides) {
    const response = await this.setUserRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
   * Update a custom role.
   */
  async updateRoleRaw(requestParameters, initOverrides) {
    if (requestParameters["roleUID"] == null) {
      throw new RequiredError(
        "roleUID",
        'Required parameter "roleUID" was null or undefined when calling updateRole().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateRole().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters["roleUID"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateRoleCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RoleDTOFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
   * Update a custom role.
   */
  async updateRole(requestParameters, initOverrides) {
    const response = await this.updateRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/AccessControlProvisioningApi.ts
var AccessControlProvisioningApi = class extends BaseAPI {
  /**
   * You need to have a permission with action `provisioning:reload` with scope `provisioners:accesscontrol`.
   */
  async adminProvisioningReloadAccessControlRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/provisioning/access-control/reload`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ErrorResponseBodyFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `provisioning:reload` with scope `provisioners:accesscontrol`.
   */
  async adminProvisioningReloadAccessControl(initOverrides) {
    const response = await this.adminProvisioningReloadAccessControlRaw(initOverrides);
    return await response.value();
  }
};

// apis/AdminApi.ts
var AdminApi = class extends BaseAPI {
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `settings:read` and scopes: `settings:*`, `settings:auth.saml:` and `settings:auth.saml:enabled` (property level).
   * Fetch settings.
   */
  async adminGetSettingsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/settings`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response);
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `settings:read` and scopes: `settings:*`, `settings:auth.saml:` and `settings:auth.saml:enabled` (property level).
   * Fetch settings.
   */
  async adminGetSettings(initOverrides) {
    const response = await this.adminGetSettingsRaw(initOverrides);
    return await response.value();
  }
  /**
   * Only works with Basic Authentication (username and password). See introduction for an explanation. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `server:stats:read`.
   * Fetch Grafana Stats.
   */
  async adminGetStatsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/stats`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AdminStatsFromJSON(jsonValue));
  }
  /**
   * Only works with Basic Authentication (username and password). See introduction for an explanation. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `server:stats:read`.
   * Fetch Grafana Stats.
   */
  async adminGetStats(initOverrides) {
    const response = await this.adminGetStatsRaw(initOverrides);
    return await response.value();
  }
};

// apis/AdminLdapApi.ts
var AdminLdapApi = class extends BaseAPI {
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.status:read`.
   * Attempts to connect to all the configured LDAP servers and returns information on whenever they\'re available or not.
   */
  async getLDAPStatusRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/ldap/status`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.status:read`.
   * Attempts to connect to all the configured LDAP servers and returns information on whenever they\'re available or not.
   */
  async getLDAPStatus(initOverrides) {
    const response = await this.getLDAPStatusRaw(initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:read`.
   * Finds an user based on a username in LDAP. This helps illustrate how would the particular user be mapped in Grafana when synced.
   */
  async getUserFromLDAPRaw(requestParameters, initOverrides) {
    if (requestParameters["userName"] == null) {
      throw new RequiredError(
        "userName",
        'Required parameter "userName" was null or undefined when calling getUserFromLDAP().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/ldap/{user_name}`.replace(`{${"user_name"}}`, encodeURIComponent(String(requestParameters["userName"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:read`.
   * Finds an user based on a username in LDAP. This helps illustrate how would the particular user be mapped in Grafana when synced.
   */
  async getUserFromLDAP(requestParameters, initOverrides) {
    const response = await this.getUserFromLDAPRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:sync`.
   * Enables a single Grafana user to be synchronized against LDAP.
   */
  async postSyncUserWithLDAPRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling postSyncUserWithLDAP().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/ldap/sync/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:sync`.
   * Enables a single Grafana user to be synchronized against LDAP.
   */
  async postSyncUserWithLDAP(requestParameters, initOverrides) {
    const response = await this.postSyncUserWithLDAPRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.config:reload`.
   * Reloads the LDAP configuration.
   */
  async reloadLDAPCfgRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/ldap/reload`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.config:reload`.
   * Reloads the LDAP configuration.
   */
  async reloadLDAPCfg(initOverrides) {
    const response = await this.reloadLDAPCfgRaw(initOverrides);
    return await response.value();
  }
};

// apis/AdminProvisioningApi.ts
var AdminProvisioningApi = class extends BaseAPI {
  /**
   * Reloads the provisioning config files for dashboards again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:dashboards`.
   * Reload dashboard provisioning configurations.
   */
  async adminProvisioningReloadDashboardsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/provisioning/dashboards/reload`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Reloads the provisioning config files for dashboards again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:dashboards`.
   * Reload dashboard provisioning configurations.
   */
  async adminProvisioningReloadDashboards(initOverrides) {
    const response = await this.adminProvisioningReloadDashboardsRaw(initOverrides);
    return await response.value();
  }
  /**
   * Reloads the provisioning config files for datasources again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:datasources`.
   * Reload datasource provisioning configurations.
   */
  async adminProvisioningReloadDatasourcesRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/provisioning/datasources/reload`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Reloads the provisioning config files for datasources again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:datasources`.
   * Reload datasource provisioning configurations.
   */
  async adminProvisioningReloadDatasources(initOverrides) {
    const response = await this.adminProvisioningReloadDatasourcesRaw(initOverrides);
    return await response.value();
  }
  /**
   * Reloads the provisioning config files for plugins again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:plugin`.
   * Reload plugin provisioning configurations.
   */
  async adminProvisioningReloadPluginsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/provisioning/plugins/reload`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Reloads the provisioning config files for plugins again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:plugin`.
   * Reload plugin provisioning configurations.
   */
  async adminProvisioningReloadPlugins(initOverrides) {
    const response = await this.adminProvisioningReloadPluginsRaw(initOverrides);
    return await response.value();
  }
};

// apis/AdminUsersApi.ts
var AdminUsersApi = class extends BaseAPI {
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:create`. Note that OrgId is an optional parameter that can be used to assign a new user to a different organization when `auto_assign_org` is set to `true`.
   * Create new user.
   */
  async adminCreateUserRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling adminCreateUser().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/users`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AdminCreateUserFormToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AdminCreateUserResponseFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:create`. Note that OrgId is an optional parameter that can be used to assign a new user to a different organization when `auto_assign_org` is set to `true`.
   * Create new user.
   */
  async adminCreateUser(requestParameters, initOverrides) {
    const response = await this.adminCreateUserRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:delete` and scope `global.users:*`.
   * Delete global User.
   */
  async adminDeleteUserRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling adminDeleteUser().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/users/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:delete` and scope `global.users:*`.
   * Delete global User.
   */
  async adminDeleteUser(requestParameters, initOverrides) {
    const response = await this.adminDeleteUserRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:disable` and scope `global.users:1` (userIDScope).
   * Disable user.
   */
  async adminDisableUserRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling adminDisableUser().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/users/{user_id}/disable`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:disable` and scope `global.users:1` (userIDScope).
   * Disable user.
   */
  async adminDisableUser(requestParameters, initOverrides) {
    const response = await this.adminDisableUserRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:enable` and scope `global.users:1` (userIDScope).
   * Enable user.
   */
  async adminEnableUserRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling adminEnableUser().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/users/{user_id}/enable`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:enable` and scope `global.users:1` (userIDScope).
   * Enable user.
   */
  async adminEnableUser(requestParameters, initOverrides) {
    const response = await this.adminEnableUserRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:list` and scope `global.users:*`.
   * Return a list of all auth tokens (devices) that the user currently have logged in from.
   */
  async adminGetUserAuthTokensRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling adminGetUserAuthTokens().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/users/{user_id}/auth-tokens`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(UserTokenFromJSON));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:list` and scope `global.users:*`.
   * Return a list of all auth tokens (devices) that the user currently have logged in from.
   */
  async adminGetUserAuthTokens(requestParameters, initOverrides) {
    const response = await this.adminGetUserAuthTokensRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.logout` and scope `global.users:*`.
   * Logout user revokes all auth tokens (devices) for the user. User of issued auth tokens (devices) will no longer be logged in and will be required to authenticate again upon next activity.
   */
  async adminLogoutUserRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling adminLogoutUser().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/users/{user_id}/logout`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.logout` and scope `global.users:*`.
   * Logout user revokes all auth tokens (devices) for the user. User of issued auth tokens (devices) will no longer be logged in and will be required to authenticate again upon next activity.
   */
  async adminLogoutUser(requestParameters, initOverrides) {
    const response = await this.adminLogoutUserRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Revokes the given auth token (device) for the user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:update` and scope `global.users:*`.
   * Revoke auth token for user.
   */
  async adminRevokeUserAuthTokenRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling adminRevokeUserAuthToken().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling adminRevokeUserAuthToken().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/users/{user_id}/revoke-auth-token`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RevokeAuthTokenCmdToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Revokes the given auth token (device) for the user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:update` and scope `global.users:*`.
   * Revoke auth token for user.
   */
  async adminRevokeUserAuthToken(requestParameters, initOverrides) {
    const response = await this.adminRevokeUserAuthTokenRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.password:update` and scope `global.users:*`.
   * Set password for user.
   */
  async adminUpdateUserPasswordRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling adminUpdateUserPassword().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling adminUpdateUserPassword().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/users/{user_id}/password`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: AdminUpdateUserPasswordFormToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.password:update` and scope `global.users:*`.
   * Set password for user.
   */
  async adminUpdateUserPassword(requestParameters, initOverrides) {
    const response = await this.adminUpdateUserPasswordRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Only works with Basic Authentication (username and password). See introduction for an explanation. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.permissions:update` and scope `global.users:*`.
   * Set permissions for user.
   */
  async adminUpdateUserPermissionsRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling adminUpdateUserPermissions().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling adminUpdateUserPermissions().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/users/{user_id}/permissions`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: AdminUpdateUserPermissionsFormToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Only works with Basic Authentication (username and password). See introduction for an explanation. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.permissions:update` and scope `global.users:*`.
   * Set permissions for user.
   */
  async adminUpdateUserPermissions(requestParameters, initOverrides) {
    const response = await this.adminUpdateUserPermissionsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:list` and scope `global.users:1` (userIDScope).
   * Fetch user quota.
   */
  async getUserQuotaRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling getUserQuota().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/users/{user_id}/quotas`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(QuotaDTOFromJSON));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:list` and scope `global.users:1` (userIDScope).
   * Fetch user quota.
   */
  async getUserQuota(requestParameters, initOverrides) {
    const response = await this.getUserQuotaRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:update` and scope `global.users:1` (userIDScope).
   * Update user quota.
   */
  async updateUserQuotaRaw(requestParameters, initOverrides) {
    if (requestParameters["quotaTarget"] == null) {
      throw new RequiredError(
        "quotaTarget",
        'Required parameter "quotaTarget" was null or undefined when calling updateUserQuota().'
      );
    }
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling updateUserQuota().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateUserQuota().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/users/{user_id}/quotas/{quota_target}`.replace(`{${"quota_target"}}`, encodeURIComponent(String(requestParameters["quotaTarget"]))).replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateQuotaCmdToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:update` and scope `global.users:1` (userIDScope).
   * Update user quota.
   */
  async updateUserQuota(requestParameters, initOverrides) {
    const response = await this.updateUserQuotaRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/AnnotationsApi.ts
var AnnotationsApi = class extends BaseAPI {
  /**
   * Deletes the annotation that matches the specified ID.
   * Delete Annotation By ID.
   */
  async deleteAnnotationByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["annotationId"] == null) {
      throw new RequiredError(
        "annotationId",
        'Required parameter "annotationId" was null or undefined when calling deleteAnnotationByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/annotations/{annotation_id}`.replace(`{${"annotation_id"}}`, encodeURIComponent(String(requestParameters["annotationId"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Deletes the annotation that matches the specified ID.
   * Delete Annotation By ID.
   */
  async deleteAnnotationByID(requestParameters, initOverrides) {
    const response = await this.deleteAnnotationByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get Annotation by ID.
   */
  async getAnnotationByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["annotationId"] == null) {
      throw new RequiredError(
        "annotationId",
        'Required parameter "annotationId" was null or undefined when calling getAnnotationByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/annotations/{annotation_id}`.replace(`{${"annotation_id"}}`, encodeURIComponent(String(requestParameters["annotationId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AnnotationFromJSON(jsonValue));
  }
  /**
   * Get Annotation by ID.
   */
  async getAnnotationByID(requestParameters, initOverrides) {
    const response = await this.getAnnotationByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Find all the event tags created in the annotations.
   * Find Annotations Tags.
   */
  async getAnnotationTagsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["tag"] != null) {
      queryParameters["tag"] = requestParameters["tag"];
    }
    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/annotations/tags`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => GetAnnotationTagsResponseFromJSON(jsonValue));
  }
  /**
   * Find all the event tags created in the annotations.
   * Find Annotations Tags.
   */
  async getAnnotationTags(requestParameters = {}, initOverrides) {
    const response = await this.getAnnotationTagsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Starting in Grafana v6.4 regions annotations are now returned in one entity that now includes the timeEnd property.
   * Find Annotations.
   */
  async getAnnotationsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["from"] != null) {
      queryParameters["from"] = requestParameters["from"];
    }
    if (requestParameters["to"] != null) {
      queryParameters["to"] = requestParameters["to"];
    }
    if (requestParameters["userId"] != null) {
      queryParameters["userId"] = requestParameters["userId"];
    }
    if (requestParameters["alertId"] != null) {
      queryParameters["alertId"] = requestParameters["alertId"];
    }
    if (requestParameters["dashboardId"] != null) {
      queryParameters["dashboardId"] = requestParameters["dashboardId"];
    }
    if (requestParameters["dashboardUID"] != null) {
      queryParameters["dashboardUID"] = requestParameters["dashboardUID"];
    }
    if (requestParameters["panelId"] != null) {
      queryParameters["panelId"] = requestParameters["panelId"];
    }
    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }
    if (requestParameters["tags"] != null) {
      queryParameters["tags"] = requestParameters["tags"];
    }
    if (requestParameters["type"] != null) {
      queryParameters["type"] = requestParameters["type"];
    }
    if (requestParameters["matchAny"] != null) {
      queryParameters["matchAny"] = requestParameters["matchAny"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/annotations`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(AnnotationFromJSON));
  }
  /**
   * Starting in Grafana v6.4 regions annotations are now returned in one entity that now includes the timeEnd property.
   * Find Annotations.
   */
  async getAnnotations(requestParameters = {}, initOverrides) {
    const response = await this.getAnnotationsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Delete multiple annotations.
   */
  async massDeleteAnnotationsRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling massDeleteAnnotations().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/annotations/mass-delete`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: MassDeleteAnnotationsCmdToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Delete multiple annotations.
   */
  async massDeleteAnnotations(requestParameters, initOverrides) {
    const response = await this.massDeleteAnnotationsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Updates one or more properties of an annotation that matches the specified ID. This operation currently supports updating of the `text`, `tags`, `time` and `timeEnd` properties. This is available in Grafana 6.0.0-beta2 and above.
   * Patch Annotation.
   */
  async patchAnnotationRaw(requestParameters, initOverrides) {
    if (requestParameters["annotationId"] == null) {
      throw new RequiredError(
        "annotationId",
        'Required parameter "annotationId" was null or undefined when calling patchAnnotation().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling patchAnnotation().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/annotations/{annotation_id}`.replace(`{${"annotation_id"}}`, encodeURIComponent(String(requestParameters["annotationId"]))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: PatchAnnotationsCmdToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Updates one or more properties of an annotation that matches the specified ID. This operation currently supports updating of the `text`, `tags`, `time` and `timeEnd` properties. This is available in Grafana 6.0.0-beta2 and above.
   * Patch Annotation.
   */
  async patchAnnotation(requestParameters, initOverrides) {
    const response = await this.patchAnnotationRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Creates an annotation in the Grafana database. The dashboardId and panelId fields are optional. If they are not specified then an organization annotation is created and can be queried in any dashboard that adds the Grafana annotations data source. When creating a region annotation include the timeEnd property. The format for `time` and `timeEnd` should be epoch numbers in millisecond resolution. The response for this HTTP request is slightly different in versions prior to v6.4. In prior versions you would also get an endId if you where creating a region. But in 6.4 regions are represented using a single event with time and timeEnd properties.
   * Create Annotation.
   */
  async postAnnotationRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling postAnnotation().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/annotations`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: PostAnnotationsCmdToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PostAnnotation200ResponseFromJSON(jsonValue));
  }
  /**
   * Creates an annotation in the Grafana database. The dashboardId and panelId fields are optional. If they are not specified then an organization annotation is created and can be queried in any dashboard that adds the Grafana annotations data source. When creating a region annotation include the timeEnd property. The format for `time` and `timeEnd` should be epoch numbers in millisecond resolution. The response for this HTTP request is slightly different in versions prior to v6.4. In prior versions you would also get an endId if you where creating a region. But in 6.4 regions are represented using a single event with time and timeEnd properties.
   * Create Annotation.
   */
  async postAnnotation(requestParameters, initOverrides) {
    const response = await this.postAnnotationRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Creates an annotation by using Graphite-compatible event format. The `when` and `data` fields are optional. If `when` is not specified then the current time will be used as annotation’s timestamp. The `tags` field can also be in prior to Graphite `0.10.0` format (string with multiple tags being separated by a space).
   * Create Annotation in Graphite format.
   */
  async postGraphiteAnnotationRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling postGraphiteAnnotation().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/annotations/graphite`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: PostGraphiteAnnotationsCmdToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PostAnnotation200ResponseFromJSON(jsonValue));
  }
  /**
   * Creates an annotation by using Graphite-compatible event format. The `when` and `data` fields are optional. If `when` is not specified then the current time will be used as annotation’s timestamp. The `tags` field can also be in prior to Graphite `0.10.0` format (string with multiple tags being separated by a space).
   * Create Annotation in Graphite format.
   */
  async postGraphiteAnnotation(requestParameters, initOverrides) {
    const response = await this.postGraphiteAnnotationRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Updates all properties of an annotation that matches the specified id. To only update certain property, consider using the Patch Annotation operation.
   * Update Annotation.
   */
  async updateAnnotationRaw(requestParameters, initOverrides) {
    if (requestParameters["annotationId"] == null) {
      throw new RequiredError(
        "annotationId",
        'Required parameter "annotationId" was null or undefined when calling updateAnnotation().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateAnnotation().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/annotations/{annotation_id}`.replace(`{${"annotation_id"}}`, encodeURIComponent(String(requestParameters["annotationId"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateAnnotationsCmdToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Updates all properties of an annotation that matches the specified id. To only update certain property, consider using the Patch Annotation operation.
   * Update Annotation.
   */
  async updateAnnotation(requestParameters, initOverrides) {
    const response = await this.updateAnnotationRaw(requestParameters, initOverrides);
    return await response.value();
  }
};
var GetAnnotationsTypeEnum = {
  Alert: "alert",
  Annotation: "annotation"
};

// apis/ApiKeysApi.ts
var ApiKeysApi = class extends BaseAPI {
  /**
   * Will return details of the created API key.
   * Creates an API key.
   * @deprecated
   */
  async addAPIkeyRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling addAPIkey().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/auth/keys`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AddAPIKeyCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => NewApiKeyResultFromJSON(jsonValue));
  }
  /**
   * Will return details of the created API key.
   * Creates an API key.
   * @deprecated
   */
  async addAPIkey(requestParameters, initOverrides) {
    const response = await this.addAPIkeyRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Deletes an API key. Deprecated. See: https://grafana.com/docs/grafana/next/administration/api-keys/#migrate-api-keys-to-grafana-service-accounts-using-the-api.
   * Delete API key.
   * @deprecated
   */
  async deleteAPIkeyRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling deleteAPIkey().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/auth/keys/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Deletes an API key. Deprecated. See: https://grafana.com/docs/grafana/next/administration/api-keys/#migrate-api-keys-to-grafana-service-accounts-using-the-api.
   * Delete API key.
   * @deprecated
   */
  async deleteAPIkey(requestParameters, initOverrides) {
    const response = await this.deleteAPIkeyRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Will return auth keys.  Deprecated: true.  Deprecated. Please use GET /api/serviceaccounts and GET /api/serviceaccounts/{id}/tokens instead see https://grafana.com/docs/grafana/next/administration/api-keys/#migrate-api-keys-to-grafana-service-accounts-using-the-api.
   * Get auth keys.
   */
  async getAPIkeysRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["includeExpired"] != null) {
      queryParameters["includeExpired"] = requestParameters["includeExpired"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/auth/keys`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(ApiKeyDTOFromJSON));
  }
  /**
   * Will return auth keys.  Deprecated: true.  Deprecated. Please use GET /api/serviceaccounts and GET /api/serviceaccounts/{id}/tokens instead see https://grafana.com/docs/grafana/next/administration/api-keys/#migrate-api-keys-to-grafana-service-accounts-using-the-api.
   * Get auth keys.
   */
  async getAPIkeys(requestParameters = {}, initOverrides) {
    const response = await this.getAPIkeysRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/CorrelationsApi.ts
var CorrelationsApi = class extends BaseAPI {
  /**
   * Add correlation.
   */
  async createCorrelationRaw(requestParameters, initOverrides) {
    if (requestParameters["sourceUID"] == null) {
      throw new RequiredError(
        "sourceUID",
        'Required parameter "sourceUID" was null or undefined when calling createCorrelation().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createCorrelation().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/uid/{sourceUID}/correlations`.replace(`{${"sourceUID"}}`, encodeURIComponent(String(requestParameters["sourceUID"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateCorrelationCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CreateCorrelationResponseBodyFromJSON(jsonValue));
  }
  /**
   * Add correlation.
   */
  async createCorrelation(requestParameters, initOverrides) {
    const response = await this.createCorrelationRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Delete a correlation.
   */
  async deleteCorrelationRaw(requestParameters, initOverrides) {
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling deleteCorrelation().'
      );
    }
    if (requestParameters["correlationUID"] == null) {
      throw new RequiredError(
        "correlationUID",
        'Required parameter "correlationUID" was null or undefined when calling deleteCorrelation().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/uid/{uid}/correlations/{correlationUID}`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))).replace(`{${"correlationUID"}}`, encodeURIComponent(String(requestParameters["correlationUID"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DeleteCorrelationResponseBodyFromJSON(jsonValue));
  }
  /**
   * Delete a correlation.
   */
  async deleteCorrelation(requestParameters, initOverrides) {
    const response = await this.deleteCorrelationRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Gets a correlation.
   */
  async getCorrelationRaw(requestParameters, initOverrides) {
    if (requestParameters["sourceUID"] == null) {
      throw new RequiredError(
        "sourceUID",
        'Required parameter "sourceUID" was null or undefined when calling getCorrelation().'
      );
    }
    if (requestParameters["correlationUID"] == null) {
      throw new RequiredError(
        "correlationUID",
        'Required parameter "correlationUID" was null or undefined when calling getCorrelation().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/uid/{sourceUID}/correlations/{correlationUID}`.replace(`{${"sourceUID"}}`, encodeURIComponent(String(requestParameters["sourceUID"]))).replace(`{${"correlationUID"}}`, encodeURIComponent(String(requestParameters["correlationUID"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CorrelationFromJSON(jsonValue));
  }
  /**
   * Gets a correlation.
   */
  async getCorrelation(requestParameters, initOverrides) {
    const response = await this.getCorrelationRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Gets all correlations.
   */
  async getCorrelationsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    if (requestParameters["sourceUID"] != null) {
      queryParameters["sourceUID"] = requestParameters["sourceUID"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/correlations`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(CorrelationFromJSON));
  }
  /**
   * Gets all correlations.
   */
  async getCorrelations(requestParameters = {}, initOverrides) {
    const response = await this.getCorrelationsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Gets all correlations originating from the given data source.
   */
  async getCorrelationsBySourceUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["sourceUID"] == null) {
      throw new RequiredError(
        "sourceUID",
        'Required parameter "sourceUID" was null or undefined when calling getCorrelationsBySourceUID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/uid/{sourceUID}/correlations`.replace(`{${"sourceUID"}}`, encodeURIComponent(String(requestParameters["sourceUID"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(CorrelationFromJSON));
  }
  /**
   * Gets all correlations originating from the given data source.
   */
  async getCorrelationsBySourceUID(requestParameters, initOverrides) {
    const response = await this.getCorrelationsBySourceUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Updates a correlation.
   */
  async updateCorrelationRaw(requestParameters, initOverrides) {
    if (requestParameters["sourceUID"] == null) {
      throw new RequiredError(
        "sourceUID",
        'Required parameter "sourceUID" was null or undefined when calling updateCorrelation().'
      );
    }
    if (requestParameters["correlationUID"] == null) {
      throw new RequiredError(
        "correlationUID",
        'Required parameter "correlationUID" was null or undefined when calling updateCorrelation().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/uid/{sourceUID}/correlations/{correlationUID}`.replace(`{${"sourceUID"}}`, encodeURIComponent(String(requestParameters["sourceUID"]))).replace(`{${"correlationUID"}}`, encodeURIComponent(String(requestParameters["correlationUID"]))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateCorrelationCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UpdateCorrelationResponseBodyFromJSON(jsonValue));
  }
  /**
   * Updates a correlation.
   */
  async updateCorrelation(requestParameters, initOverrides) {
    const response = await this.updateCorrelationRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/DashboardPermissionsApi.ts
var DashboardPermissionsApi = class extends BaseAPI {
  /**
   * Please refer to [updated API](#/dashboard_permissions/getDashboardPermissionsListByUID) instead
   * Gets all existing permissions for the given dashboard.
   * @deprecated
   */
  async getDashboardPermissionsListByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["dashboardID"] == null) {
      throw new RequiredError(
        "dashboardID",
        'Required parameter "dashboardID" was null or undefined when calling getDashboardPermissionsListByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/id/{DashboardID}/permissions`.replace(`{${"DashboardID"}}`, encodeURIComponent(String(requestParameters["dashboardID"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(DashboardACLInfoDTOFromJSON));
  }
  /**
   * Please refer to [updated API](#/dashboard_permissions/getDashboardPermissionsListByUID) instead
   * Gets all existing permissions for the given dashboard.
   * @deprecated
   */
  async getDashboardPermissionsListByID(requestParameters, initOverrides) {
    const response = await this.getDashboardPermissionsListByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Gets all existing permissions for the given dashboard.
   */
  async getDashboardPermissionsListByUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling getDashboardPermissionsListByUID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/uid/{uid}/permissions`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(DashboardACLInfoDTOFromJSON));
  }
  /**
   * Gets all existing permissions for the given dashboard.
   */
  async getDashboardPermissionsListByUID(requestParameters, initOverrides) {
    const response = await this.getDashboardPermissionsListByUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Please refer to [updated API](#/dashboard_permissions/updateDashboardPermissionsByUID) instead  This operation will remove existing permissions if they’re not included in the request.
   * Updates permissions for a dashboard.
   * @deprecated
   */
  async updateDashboardPermissionsByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["dashboardID"] == null) {
      throw new RequiredError(
        "dashboardID",
        'Required parameter "dashboardID" was null or undefined when calling updateDashboardPermissionsByID().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateDashboardPermissionsByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/id/{DashboardID}/permissions`.replace(`{${"DashboardID"}}`, encodeURIComponent(String(requestParameters["dashboardID"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateDashboardACLCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Please refer to [updated API](#/dashboard_permissions/updateDashboardPermissionsByUID) instead  This operation will remove existing permissions if they’re not included in the request.
   * Updates permissions for a dashboard.
   * @deprecated
   */
  async updateDashboardPermissionsByID(requestParameters, initOverrides) {
    const response = await this.updateDashboardPermissionsByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * This operation will remove existing permissions if they’re not included in the request.
   * Updates permissions for a dashboard.
   */
  async updateDashboardPermissionsByUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling updateDashboardPermissionsByUID().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateDashboardPermissionsByUID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/uid/{uid}/permissions`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateDashboardACLCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * This operation will remove existing permissions if they’re not included in the request.
   * Updates permissions for a dashboard.
   */
  async updateDashboardPermissionsByUID(requestParameters, initOverrides) {
    const response = await this.updateDashboardPermissionsByUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/DashboardPublicApi.ts
var DashboardPublicApi = class extends BaseAPI {
  /**
   * Create public dashboard for a dashboard
   */
  async createPublicDashboardRaw(requestParameters, initOverrides) {
    if (requestParameters["dashboardUid"] == null) {
      throw new RequiredError(
        "dashboardUid",
        'Required parameter "dashboardUid" was null or undefined when calling createPublicDashboard().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createPublicDashboard().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/uid/{dashboardUid}/public-dashboards`.replace(`{${"dashboardUid"}}`, encodeURIComponent(String(requestParameters["dashboardUid"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: PublicDashboardDTOToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PublicDashboardFromJSON(jsonValue));
  }
  /**
   * Create public dashboard for a dashboard
   */
  async createPublicDashboard(requestParameters, initOverrides) {
    const response = await this.createPublicDashboardRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Delete public dashboard for a dashboard
   */
  async deletePublicDashboardRaw(requestParameters, initOverrides) {
    if (requestParameters["dashboardUid"] == null) {
      throw new RequiredError(
        "dashboardUid",
        'Required parameter "dashboardUid" was null or undefined when calling deletePublicDashboard().'
      );
    }
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling deletePublicDashboard().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/uid/{dashboardUid}/public-dashboards/{uid}`.replace(`{${"dashboardUid"}}`, encodeURIComponent(String(requestParameters["dashboardUid"]))).replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Delete public dashboard for a dashboard
   */
  async deletePublicDashboard(requestParameters, initOverrides) {
    const response = await this.deletePublicDashboardRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get annotations for a public dashboard
   */
  async getPublicAnnotationsRaw(requestParameters, initOverrides) {
    if (requestParameters["accessToken"] == null) {
      throw new RequiredError(
        "accessToken",
        'Required parameter "accessToken" was null or undefined when calling getPublicAnnotations().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/public/dashboards/{accessToken}/annotations`.replace(`{${"accessToken"}}`, encodeURIComponent(String(requestParameters["accessToken"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(AnnotationEventFromJSON));
  }
  /**
   * Get annotations for a public dashboard
   */
  async getPublicAnnotations(requestParameters, initOverrides) {
    const response = await this.getPublicAnnotationsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get public dashboard by dashboardUid
   */
  async getPublicDashboardRaw(requestParameters, initOverrides) {
    if (requestParameters["dashboardUid"] == null) {
      throw new RequiredError(
        "dashboardUid",
        'Required parameter "dashboardUid" was null or undefined when calling getPublicDashboard().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/uid/{dashboardUid}/public-dashboards`.replace(`{${"dashboardUid"}}`, encodeURIComponent(String(requestParameters["dashboardUid"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PublicDashboardFromJSON(jsonValue));
  }
  /**
   * Get public dashboard by dashboardUid
   */
  async getPublicDashboard(requestParameters, initOverrides) {
    const response = await this.getPublicDashboardRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get list of public dashboards
   */
  async listPublicDashboardsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/public-dashboards`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PublicDashboardListResponseWithPaginationFromJSON(jsonValue));
  }
  /**
   * Get list of public dashboards
   */
  async listPublicDashboards(initOverrides) {
    const response = await this.listPublicDashboardsRaw(initOverrides);
    return await response.value();
  }
  /**
   * Get results for a given panel on a public dashboard
   */
  async queryPublicDashboardRaw(requestParameters, initOverrides) {
    if (requestParameters["accessToken"] == null) {
      throw new RequiredError(
        "accessToken",
        'Required parameter "accessToken" was null or undefined when calling queryPublicDashboard().'
      );
    }
    if (requestParameters["panelId"] == null) {
      throw new RequiredError(
        "panelId",
        'Required parameter "panelId" was null or undefined when calling queryPublicDashboard().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/public/dashboards/{accessToken}/panels/{panelId}/query`.replace(`{${"accessToken"}}`, encodeURIComponent(String(requestParameters["accessToken"]))).replace(`{${"panelId"}}`, encodeURIComponent(String(requestParameters["panelId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => QueryDataResponseFromJSON(jsonValue));
  }
  /**
   * Get results for a given panel on a public dashboard
   */
  async queryPublicDashboard(requestParameters, initOverrides) {
    const response = await this.queryPublicDashboardRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update public dashboard for a dashboard
   */
  async updatePublicDashboardRaw(requestParameters, initOverrides) {
    if (requestParameters["dashboardUid"] == null) {
      throw new RequiredError(
        "dashboardUid",
        'Required parameter "dashboardUid" was null or undefined when calling updatePublicDashboard().'
      );
    }
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling updatePublicDashboard().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updatePublicDashboard().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/uid/{dashboardUid}/public-dashboards/{uid}`.replace(`{${"dashboardUid"}}`, encodeURIComponent(String(requestParameters["dashboardUid"]))).replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: PublicDashboardDTOToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PublicDashboardFromJSON(jsonValue));
  }
  /**
   * Update public dashboard for a dashboard
   */
  async updatePublicDashboard(requestParameters, initOverrides) {
    const response = await this.updatePublicDashboardRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get public dashboard for view
   */
  async viewPublicDashboardRaw(requestParameters, initOverrides) {
    if (requestParameters["accessToken"] == null) {
      throw new RequiredError(
        "accessToken",
        'Required parameter "accessToken" was null or undefined when calling viewPublicDashboard().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/public/dashboards/{accessToken}`.replace(`{${"accessToken"}}`, encodeURIComponent(String(requestParameters["accessToken"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DashboardFullWithMetaFromJSON(jsonValue));
  }
  /**
   * Get public dashboard for view
   */
  async viewPublicDashboard(requestParameters, initOverrides) {
    const response = await this.viewPublicDashboardRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/DashboardVersionsApi.ts
var DashboardVersionsApi = class extends BaseAPI {
  /**
   * Please refer to [updated API](#/dashboard_versions/getDashboardVersionByUID) instead
   * Get a specific dashboard version.
   * @deprecated
   */
  async getDashboardVersionByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["dashboardID"] == null) {
      throw new RequiredError(
        "dashboardID",
        'Required parameter "dashboardID" was null or undefined when calling getDashboardVersionByID().'
      );
    }
    if (requestParameters["dashboardVersionID"] == null) {
      throw new RequiredError(
        "dashboardVersionID",
        'Required parameter "dashboardVersionID" was null or undefined when calling getDashboardVersionByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/id/{DashboardID}/versions/{DashboardVersionID}`.replace(`{${"DashboardID"}}`, encodeURIComponent(String(requestParameters["dashboardID"]))).replace(`{${"DashboardVersionID"}}`, encodeURIComponent(String(requestParameters["dashboardVersionID"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DashboardVersionMetaFromJSON(jsonValue));
  }
  /**
   * Please refer to [updated API](#/dashboard_versions/getDashboardVersionByUID) instead
   * Get a specific dashboard version.
   * @deprecated
   */
  async getDashboardVersionByID(requestParameters, initOverrides) {
    const response = await this.getDashboardVersionByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a specific dashboard version using UID.
   */
  async getDashboardVersionByUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["dashboardVersionID"] == null) {
      throw new RequiredError(
        "dashboardVersionID",
        'Required parameter "dashboardVersionID" was null or undefined when calling getDashboardVersionByUID().'
      );
    }
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling getDashboardVersionByUID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/uid/{uid}/versions/{DashboardVersionID}`.replace(`{${"DashboardVersionID"}}`, encodeURIComponent(String(requestParameters["dashboardVersionID"]))).replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DashboardVersionMetaFromJSON(jsonValue));
  }
  /**
   * Get a specific dashboard version using UID.
   */
  async getDashboardVersionByUID(requestParameters, initOverrides) {
    const response = await this.getDashboardVersionByUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Please refer to [updated API](#/dashboard_versions/getDashboardVersionsByUID) instead
   * Gets all existing versions for the dashboard.
   * @deprecated
   */
  async getDashboardVersionsByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["dashboardID"] == null) {
      throw new RequiredError(
        "dashboardID",
        'Required parameter "dashboardID" was null or undefined when calling getDashboardVersionsByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/id/{DashboardID}/versions`.replace(`{${"DashboardID"}}`, encodeURIComponent(String(requestParameters["dashboardID"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(DashboardVersionMetaFromJSON));
  }
  /**
   * Please refer to [updated API](#/dashboard_versions/getDashboardVersionsByUID) instead
   * Gets all existing versions for the dashboard.
   * @deprecated
   */
  async getDashboardVersionsByID(requestParameters, initOverrides) {
    const response = await this.getDashboardVersionsByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Gets all existing versions for the dashboard using UID.
   */
  async getDashboardVersionsByUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling getDashboardVersionsByUID().'
      );
    }
    const queryParameters = {};
    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }
    if (requestParameters["start"] != null) {
      queryParameters["start"] = requestParameters["start"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/uid/{uid}/versions`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(DashboardVersionMetaFromJSON));
  }
  /**
   * Gets all existing versions for the dashboard using UID.
   */
  async getDashboardVersionsByUID(requestParameters, initOverrides) {
    const response = await this.getDashboardVersionsByUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Please refer to [updated API](#/dashboard_versions/restoreDashboardVersionByUID) instead
   * Restore a dashboard to a given dashboard version.
   * @deprecated
   */
  async restoreDashboardVersionByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["dashboardID"] == null) {
      throw new RequiredError(
        "dashboardID",
        'Required parameter "dashboardID" was null or undefined when calling restoreDashboardVersionByID().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling restoreDashboardVersionByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/id/{DashboardID}/restore`.replace(`{${"DashboardID"}}`, encodeURIComponent(String(requestParameters["dashboardID"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RestoreDashboardVersionCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PostDashboard200ResponseFromJSON(jsonValue));
  }
  /**
   * Please refer to [updated API](#/dashboard_versions/restoreDashboardVersionByUID) instead
   * Restore a dashboard to a given dashboard version.
   * @deprecated
   */
  async restoreDashboardVersionByID(requestParameters, initOverrides) {
    const response = await this.restoreDashboardVersionByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Restore a dashboard to a given dashboard version using UID.
   */
  async restoreDashboardVersionByUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling restoreDashboardVersionByUID().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling restoreDashboardVersionByUID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/uid/{uid}/restore`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RestoreDashboardVersionCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PostDashboard200ResponseFromJSON(jsonValue));
  }
  /**
   * Restore a dashboard to a given dashboard version using UID.
   */
  async restoreDashboardVersionByUID(requestParameters, initOverrides) {
    const response = await this.restoreDashboardVersionByUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/DashboardsApi.ts
var DashboardsApi = class extends BaseAPI {
  /**
   * Perform diff on two dashboards.
   */
  async calculateDashboardDiffRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling calculateDashboardDiff().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/calculate-diff`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CalculateDashboardDiffRequestToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response);
  }
  /**
   * Perform diff on two dashboards.
   */
  async calculateDashboardDiff(requestParameters, initOverrides) {
    const response = await this.calculateDashboardDiffRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Will delete the dashboard given the specified unique identifier (uid).
   * Delete dashboard by uid.
   */
  async deleteDashboardByUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling deleteDashboardByUID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/uid/{uid}`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DeleteDashboardByUID200ResponseFromJSON(jsonValue));
  }
  /**
   * Will delete the dashboard given the specified unique identifier (uid).
   * Delete dashboard by uid.
   */
  async deleteDashboardByUID(requestParameters, initOverrides) {
    const response = await this.deleteDashboardByUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Will return the dashboard given the dashboard unique identifier (uid).
   * Get dashboard by uid.
   */
  async getDashboardByUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling getDashboardByUID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/uid/{uid}`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DashboardFullWithMetaFromJSON(jsonValue));
  }
  /**
   * Will return the dashboard given the dashboard unique identifier (uid).
   * Get dashboard by uid.
   */
  async getDashboardByUID(requestParameters, initOverrides) {
    const response = await this.getDashboardByUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get all dashboards tags of an organisation.
   */
  async getDashboardTagsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/tags`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(DashboardTagCloudItemFromJSON));
  }
  /**
   * Get all dashboards tags of an organisation.
   */
  async getDashboardTags(initOverrides) {
    const response = await this.getDashboardTagsRaw(initOverrides);
    return await response.value();
  }
  /**
   * Get home dashboard.
   */
  async getHomeDashboardRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/home`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => GetHomeDashboardResponseFromJSON(jsonValue));
  }
  /**
   * Get home dashboard.
   */
  async getHomeDashboard(initOverrides) {
    const response = await this.getHomeDashboardRaw(initOverrides);
    return await response.value();
  }
  /**
   * Import dashboard.
   */
  async importDashboardRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling importDashboard().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/import`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ImportDashboardRequestToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ImportDashboardResponseFromJSON(jsonValue));
  }
  /**
   * Import dashboard.
   */
  async importDashboard(requestParameters, initOverrides) {
    const response = await this.importDashboardRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Creates a new dashboard or updates an existing dashboard. Note: This endpoint is not intended for creating folders, use `POST /api/folders` for that.
   * Create / Update dashboard
   */
  async postDashboardRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling postDashboard().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboards/db`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: SaveDashboardCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PostDashboard200ResponseFromJSON(jsonValue));
  }
  /**
   * Creates a new dashboard or updates an existing dashboard. Note: This endpoint is not intended for creating folders, use `POST /api/folders` for that.
   * Create / Update dashboard
   */
  async postDashboard(requestParameters, initOverrides) {
    const response = await this.postDashboardRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/DatasourcesApi.ts
var DatasourcesApi = class extends BaseAPI {
  /**
   * By defining `password` and `basicAuthPassword` under secureJsonData property Grafana encrypts them securely as an encrypted blob in the database. The response then lists the encrypted fields under secureJsonFields.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:create`
   * Create a data source.
   */
  async addDataSourceRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling addDataSource().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AddDataSourceCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AddDataSource200ResponseFromJSON(jsonValue));
  }
  /**
   * By defining `password` and `basicAuthPassword` under secureJsonData property Grafana encrypts them securely as an encrypted blob in the database. The response then lists the encrypted fields under secureJsonFields.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:create`
   * Create a data source.
   */
  async addDataSource(requestParameters, initOverrides) {
    const response = await this.addDataSourceRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Please refer to [updated API](#/datasources/callDatasourceResourceWithUID) instead
   * Fetch data source resources by Id.
   * @deprecated
   */
  async callDatasourceResourceByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["datasourceProxyRoute"] == null) {
      throw new RequiredError(
        "datasourceProxyRoute",
        'Required parameter "datasourceProxyRoute" was null or undefined when calling callDatasourceResourceByID().'
      );
    }
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling callDatasourceResourceByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/{id}/resources/{datasource_proxy_route}`.replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(requestParameters["datasourceProxyRoute"]))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Please refer to [updated API](#/datasources/callDatasourceResourceWithUID) instead
   * Fetch data source resources by Id.
   * @deprecated
   */
  async callDatasourceResourceByID(requestParameters, initOverrides) {
    const response = await this.callDatasourceResourceByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Fetch data source resources.
   */
  async callDatasourceResourceWithUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["datasourceProxyRoute"] == null) {
      throw new RequiredError(
        "datasourceProxyRoute",
        'Required parameter "datasourceProxyRoute" was null or undefined when calling callDatasourceResourceWithUID().'
      );
    }
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling callDatasourceResourceWithUID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/uid/{uid}/resources/{datasource_proxy_route}`.replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(requestParameters["datasourceProxyRoute"]))).replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Fetch data source resources.
   */
  async callDatasourceResourceWithUID(requestParameters, initOverrides) {
    const response = await this.callDatasourceResourceWithUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Please refer to [updated API](#/datasources/checkDatasourceHealthWithUID) instead
   * Sends a health check request to the plugin datasource identified by the ID.
   * @deprecated
   */
  async checkDatasourceHealthByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling checkDatasourceHealthByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/{id}/health`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Please refer to [updated API](#/datasources/checkDatasourceHealthWithUID) instead
   * Sends a health check request to the plugin datasource identified by the ID.
   * @deprecated
   */
  async checkDatasourceHealthByID(requestParameters, initOverrides) {
    const response = await this.checkDatasourceHealthByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Sends a health check request to the plugin datasource identified by the UID.
   */
  async checkDatasourceHealthWithUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling checkDatasourceHealthWithUID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/uid/{uid}/health`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Sends a health check request to the plugin datasource identified by the UID.
   */
  async checkDatasourceHealthWithUID(requestParameters, initOverrides) {
    const response = await this.checkDatasourceHealthWithUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Proxies all calls to the actual data source.
   * Data source proxy DELETE calls.
   */
  async datasourceProxyDELETEByUIDcallsRaw(requestParameters, initOverrides) {
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling datasourceProxyDELETEByUIDcalls().'
      );
    }
    if (requestParameters["datasourceProxyRoute"] == null) {
      throw new RequiredError(
        "datasourceProxyRoute",
        'Required parameter "datasourceProxyRoute" was null or undefined when calling datasourceProxyDELETEByUIDcalls().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/proxy/uid/{uid}/{datasource_proxy_route}`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))).replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(requestParameters["datasourceProxyRoute"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Proxies all calls to the actual data source.
   * Data source proxy DELETE calls.
   */
  async datasourceProxyDELETEByUIDcalls(requestParameters, initOverrides) {
    await this.datasourceProxyDELETEByUIDcallsRaw(requestParameters, initOverrides);
  }
  /**
   * Proxies all calls to the actual data source.  Please refer to [updated API](#/datasources/datasourceProxyDELETEByUIDcalls) instead
   * Data source proxy DELETE calls.
   * @deprecated
   */
  async datasourceProxyDELETEcallsRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling datasourceProxyDELETEcalls().'
      );
    }
    if (requestParameters["datasourceProxyRoute"] == null) {
      throw new RequiredError(
        "datasourceProxyRoute",
        'Required parameter "datasourceProxyRoute" was null or undefined when calling datasourceProxyDELETEcalls().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/proxy/{id}/{datasource_proxy_route}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))).replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(requestParameters["datasourceProxyRoute"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Proxies all calls to the actual data source.  Please refer to [updated API](#/datasources/datasourceProxyDELETEByUIDcalls) instead
   * Data source proxy DELETE calls.
   * @deprecated
   */
  async datasourceProxyDELETEcalls(requestParameters, initOverrides) {
    await this.datasourceProxyDELETEcallsRaw(requestParameters, initOverrides);
  }
  /**
   * Proxies all calls to the actual data source.
   * Data source proxy GET calls.
   */
  async datasourceProxyGETByUIDcallsRaw(requestParameters, initOverrides) {
    if (requestParameters["datasourceProxyRoute"] == null) {
      throw new RequiredError(
        "datasourceProxyRoute",
        'Required parameter "datasourceProxyRoute" was null or undefined when calling datasourceProxyGETByUIDcalls().'
      );
    }
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling datasourceProxyGETByUIDcalls().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/proxy/uid/{uid}/{datasource_proxy_route}`.replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(requestParameters["datasourceProxyRoute"]))).replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Proxies all calls to the actual data source.
   * Data source proxy GET calls.
   */
  async datasourceProxyGETByUIDcalls(requestParameters, initOverrides) {
    await this.datasourceProxyGETByUIDcallsRaw(requestParameters, initOverrides);
  }
  /**
   * Proxies all calls to the actual data source.  Please refer to [updated API](#/datasources/datasourceProxyGETByUIDcalls) instead
   * Data source proxy GET calls.
   * @deprecated
   */
  async datasourceProxyGETcallsRaw(requestParameters, initOverrides) {
    if (requestParameters["datasourceProxyRoute"] == null) {
      throw new RequiredError(
        "datasourceProxyRoute",
        'Required parameter "datasourceProxyRoute" was null or undefined when calling datasourceProxyGETcalls().'
      );
    }
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling datasourceProxyGETcalls().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/proxy/{id}/{datasource_proxy_route}`.replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(requestParameters["datasourceProxyRoute"]))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Proxies all calls to the actual data source.  Please refer to [updated API](#/datasources/datasourceProxyGETByUIDcalls) instead
   * Data source proxy GET calls.
   * @deprecated
   */
  async datasourceProxyGETcalls(requestParameters, initOverrides) {
    await this.datasourceProxyGETcallsRaw(requestParameters, initOverrides);
  }
  /**
   * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined
   * Data source proxy POST calls.
   */
  async datasourceProxyPOSTByUIDcallsRaw(requestParameters, initOverrides) {
    if (requestParameters["datasourceProxyRoute"] == null) {
      throw new RequiredError(
        "datasourceProxyRoute",
        'Required parameter "datasourceProxyRoute" was null or undefined when calling datasourceProxyPOSTByUIDcalls().'
      );
    }
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling datasourceProxyPOSTByUIDcalls().'
      );
    }
    if (requestParameters["datasourceProxyParam"] == null) {
      throw new RequiredError(
        "datasourceProxyParam",
        'Required parameter "datasourceProxyParam" was null or undefined when calling datasourceProxyPOSTByUIDcalls().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/proxy/uid/{uid}/{datasource_proxy_route}`.replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(requestParameters["datasourceProxyRoute"]))).replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters["datasourceProxyParam"]
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined
   * Data source proxy POST calls.
   */
  async datasourceProxyPOSTByUIDcalls(requestParameters, initOverrides) {
    await this.datasourceProxyPOSTByUIDcallsRaw(requestParameters, initOverrides);
  }
  /**
   * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined  Please refer to [updated API](#/datasources/datasourceProxyPOSTByUIDcalls) instead
   * Data source proxy POST calls.
   * @deprecated
   */
  async datasourceProxyPOSTcallsRaw(requestParameters, initOverrides) {
    if (requestParameters["datasourceProxyRoute"] == null) {
      throw new RequiredError(
        "datasourceProxyRoute",
        'Required parameter "datasourceProxyRoute" was null or undefined when calling datasourceProxyPOSTcalls().'
      );
    }
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling datasourceProxyPOSTcalls().'
      );
    }
    if (requestParameters["datasourceProxyParam"] == null) {
      throw new RequiredError(
        "datasourceProxyParam",
        'Required parameter "datasourceProxyParam" was null or undefined when calling datasourceProxyPOSTcalls().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/proxy/{id}/{datasource_proxy_route}`.replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(requestParameters["datasourceProxyRoute"]))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters["datasourceProxyParam"]
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined  Please refer to [updated API](#/datasources/datasourceProxyPOSTByUIDcalls) instead
   * Data source proxy POST calls.
   * @deprecated
   */
  async datasourceProxyPOSTcalls(requestParameters, initOverrides) {
    await this.datasourceProxyPOSTcallsRaw(requestParameters, initOverrides);
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/deleteDataSourceByUID) instead
   * Delete an existing data source by id.
   * @deprecated
   */
  async deleteDataSourceByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling deleteDataSourceByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/deleteDataSourceByUID) instead
   * Delete an existing data source by id.
   * @deprecated
   */
  async deleteDataSourceByID(requestParameters, initOverrides) {
    const response = await this.deleteDataSourceByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
   * Delete an existing data source by name.
   */
  async deleteDataSourceByNameRaw(requestParameters, initOverrides) {
    if (requestParameters["name"] == null) {
      throw new RequiredError(
        "name",
        'Required parameter "name" was null or undefined when calling deleteDataSourceByName().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/name/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters["name"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DeleteDataSourceByName200ResponseFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
   * Delete an existing data source by name.
   */
  async deleteDataSourceByName(requestParameters, initOverrides) {
    const response = await this.deleteDataSourceByNameRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
   * Delete an existing data source by UID.
   */
  async deleteDataSourceByUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling deleteDataSourceByUID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/uid/{uid}`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
   * Delete an existing data source by UID.
   */
  async deleteDataSourceByUID(requestParameters, initOverrides) {
    const response = await this.deleteDataSourceByUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/getDataSourceByUID) instead
   * Get a single data source by Id.
   * @deprecated
   */
  async getDataSourceByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling getDataSourceByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DataSourceFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/getDataSourceByUID) instead
   * Get a single data source by Id.
   * @deprecated
   */
  async getDataSourceByID(requestParameters, initOverrides) {
    const response = await this.getDataSourceByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
   * Get a single data source by Name.
   */
  async getDataSourceByNameRaw(requestParameters, initOverrides) {
    if (requestParameters["name"] == null) {
      throw new RequiredError(
        "name",
        'Required parameter "name" was null or undefined when calling getDataSourceByName().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/name/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters["name"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DataSourceFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
   * Get a single data source by Name.
   */
  async getDataSourceByName(requestParameters, initOverrides) {
    const response = await this.getDataSourceByNameRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
   * Get a single data source by UID.
   */
  async getDataSourceByUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling getDataSourceByUID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/uid/{uid}`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DataSourceFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
   * Get a single data source by UID.
   */
  async getDataSourceByUID(requestParameters, initOverrides) {
    const response = await this.getDataSourceByUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
   * Get data source Id by Name.
   */
  async getDataSourceIdByNameRaw(requestParameters, initOverrides) {
    if (requestParameters["name"] == null) {
      throw new RequiredError(
        "name",
        'Required parameter "name" was null or undefined when calling getDataSourceIdByName().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/id/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters["name"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => GetDataSourceIdByName200ResponseFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
   * Get data source Id by Name.
   */
  async getDataSourceIdByName(requestParameters, initOverrides) {
    const response = await this.getDataSourceIdByNameRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scope: `datasources:*`.
   * Get all data sources.
   */
  async getDataSourcesRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(DataSourceListItemDTOFromJSON));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scope: `datasources:*`.
   * Get all data sources.
   */
  async getDataSources(initOverrides) {
    const response = await this.getDataSourcesRaw(initOverrides);
    return await response.value();
  }
  /**
   * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the encrypted fields are listed under secureJsonFields section in the response.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/updateDataSourceByUID) instead
   * Update an existing data source by its sequential ID.
   * @deprecated
   */
  async updateDataSourceByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling updateDataSourceByID().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateDataSourceByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateDataSourceCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AddDataSource200ResponseFromJSON(jsonValue));
  }
  /**
   * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the encrypted fields are listed under secureJsonFields section in the response.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/updateDataSourceByUID) instead
   * Update an existing data source by its sequential ID.
   * @deprecated
   */
  async updateDataSourceByID(requestParameters, initOverrides) {
    const response = await this.updateDataSourceByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the encrypted fields are listed under secureJsonFields section in the response.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:1` (single data source).
   * Update an existing data source.
   */
  async updateDataSourceByUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling updateDataSourceByUID().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateDataSourceByUID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/datasources/uid/{uid}`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateDataSourceCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AddDataSource200ResponseFromJSON(jsonValue));
  }
  /**
   * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the encrypted fields are listed under secureJsonFields section in the response.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:1` (single data source).
   * Update an existing data source.
   */
  async updateDataSourceByUID(requestParameters, initOverrides) {
    const response = await this.updateDataSourceByUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/DevicesApi.ts
var DevicesApi = class extends BaseAPI {
  /**
   * Lists all devices within the last 30 days
   */
  async listDevicesRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/stats`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(DeviceDTOFromJSON));
  }
  /**
   * Lists all devices within the last 30 days
   */
  async listDevices(initOverrides) {
    const response = await this.listDevicesRaw(initOverrides);
    return await response.value();
  }
  /**
   * Lists all devices within the last 30 days
   */
  async searchDevicesRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/search`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchDeviceQueryResultFromJSON(jsonValue));
  }
  /**
   * Lists all devices within the last 30 days
   */
  async searchDevices(initOverrides) {
    const response = await this.searchDevicesRaw(initOverrides);
    return await response.value();
  }
};

// apis/DsApi.ts
var DsApi = class extends BaseAPI {
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:query`.
   * DataSource query metrics with expressions.
   */
  async queryMetricsWithExpressionsRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling queryMetricsWithExpressions().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/ds/query`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: MetricRequestToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => QueryDataResponseFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:query`.
   * DataSource query metrics with expressions.
   */
  async queryMetricsWithExpressions(requestParameters, initOverrides) {
    const response = await this.queryMetricsWithExpressionsRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/EnterpriseApi.ts
var EnterpriseApi = class extends BaseAPI {
  /**
   * Add External Group.
   */
  async addTeamGroupApiRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling addTeamGroupApi().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling addTeamGroupApi().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/teams/{teamId}/groups`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: TeamGroupMappingToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Add External Group.
   */
  async addTeamGroupApi(requestParameters, initOverrides) {
    const response = await this.addTeamGroupApiRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`.
   * Add team role.
   */
  async addTeamRoleRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling addTeamRole().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling addTeamRole().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/teams/{teamId}/roles`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AddTeamRoleCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`.
   * Add team role.
   */
  async addTeamRole(requestParameters, initOverrides) {
    const response = await this.addTeamRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Assign a role to a specific user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
   * Add a user role assignment.
   */
  async addUserRoleRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling addUserRole().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling addUserRole().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/users/{userId}/roles`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AddUserRoleCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Assign a role to a specific user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
   * Add a user role assignment.
   */
  async addUserRole(requestParameters, initOverrides) {
    const response = await this.addUserRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * You need to have a permission with action `provisioning:reload` with scope `provisioners:accesscontrol`.
   */
  async adminProvisioningReloadAccessControlRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/provisioning/access-control/reload`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ErrorResponseBodyFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `provisioning:reload` with scope `provisioners:accesscontrol`.
   */
  async adminProvisioningReloadAccessControl(initOverrides) {
    const response = await this.adminProvisioningReloadAccessControlRaw(initOverrides);
    return await response.value();
  }
  /**
   * Create a recording rule that is then registered and started.
   */
  async createRecordingRuleRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createRecordingRule().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/recording-rules`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RecordingRuleJSONToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RecordingRuleJSONFromJSON(jsonValue));
  }
  /**
   * Create a recording rule that is then registered and started.
   */
  async createRecordingRule(requestParameters, initOverrides) {
    const response = await this.createRecordingRuleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * It returns a 422 if there is not an existing prometheus data source configured.
   * Create a remote write target.
   */
  async createRecordingRuleWriteTargetRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createRecordingRuleWriteTarget().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/recording-rules/writer`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: PrometheusRemoteWriteTargetJSONToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PrometheusRemoteWriteTargetJSONFromJSON(jsonValue));
  }
  /**
   * It returns a 422 if there is not an existing prometheus data source configured.
   * Create a remote write target.
   */
  async createRecordingRuleWriteTarget(requestParameters, initOverrides) {
    const response = await this.createRecordingRuleWriteTargetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Available to org admins only and with a valid license.  You need to have a permission with action `reports.admin:create`.
   * Create a report.
   */
  async createReportRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createReport().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateOrUpdateReportConfigToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CreateReport200ResponseFromJSON(jsonValue));
  }
  /**
   * Available to org admins only and with a valid license.  You need to have a permission with action `reports.admin:create`.
   * Create a report.
   */
  async createReport(requestParameters, initOverrides) {
    const response = await this.createReportRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.  You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
   * Create a new custom role.
   */
  async createRoleRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createRole().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/roles`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateRoleFormToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RoleDTOFromJSON(jsonValue));
  }
  /**
   * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.  You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
   * Create a new custom role.
   */
  async createRole(requestParameters, initOverrides) {
    const response = await this.createRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Removes the license stored in the Grafana database. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:delete`.
   * Remove license from database.
   */
  async deleteLicenseTokenRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling deleteLicenseToken().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/licensing/token`,
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters,
      body: DeleteTokenCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ErrorResponseBodyFromJSON(jsonValue));
  }
  /**
   * Removes the license stored in the Grafana database. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:delete`.
   * Remove license from database.
   */
  async deleteLicenseToken(requestParameters, initOverrides) {
    const response = await this.deleteLicenseTokenRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Delete removes the rule from the registry and stops it.
   */
  async deleteRecordingRuleRaw(requestParameters, initOverrides) {
    if (requestParameters["recordingRuleID"] == null) {
      throw new RequiredError(
        "recordingRuleID",
        'Required parameter "recordingRuleID" was null or undefined when calling deleteRecordingRule().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/recording-rules/{recordingRuleID}`.replace(`{${"recordingRuleID"}}`, encodeURIComponent(String(requestParameters["recordingRuleID"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Delete removes the rule from the registry and stops it.
   */
  async deleteRecordingRule(requestParameters, initOverrides) {
    const response = await this.deleteRecordingRuleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Delete the remote write target.
   */
  async deleteRecordingRuleWriteTargetRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/recording-rules/writer`,
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Delete the remote write target.
   */
  async deleteRecordingRuleWriteTarget(initOverrides) {
    const response = await this.deleteRecordingRuleWriteTargetRaw(initOverrides);
    return await response.value();
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.delete` with scope `reports:id:<report ID>`.
   * Delete a report.
   */
  async deleteReportRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling deleteReport().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.delete` with scope `reports:id:<report ID>`.
   * Delete a report.
   */
  async deleteReport(requestParameters, initOverrides) {
    const response = await this.deleteReportRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.  You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
   * Delete a custom role.
   */
  async deleteRoleRaw(requestParameters, initOverrides) {
    if (requestParameters["roleUID"] == null) {
      throw new RequiredError(
        "roleUID",
        'Required parameter "roleUID" was null or undefined when calling deleteRole().'
      );
    }
    const queryParameters = {};
    if (requestParameters["force"] != null) {
      queryParameters["force"] = requestParameters["force"];
    }
    if (requestParameters["global"] != null) {
      queryParameters["global"] = requestParameters["global"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters["roleUID"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.  You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
   * Delete a custom role.
   */
  async deleteRole(requestParameters, initOverrides) {
    const response = await this.deleteRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Returns an indicator to check if fine-grained access control is enabled or not.  You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
   * Get status.
   */
  async getAccessControlStatusRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/status`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new JSONApiResponse(response);
    } else {
      return new TextApiResponse(response);
    }
  }
  /**
   * Returns an indicator to check if fine-grained access control is enabled or not.  You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
   * Get status.
   */
  async getAccessControlStatus(initOverrides) {
    const response = await this.getAccessControlStatusRaw(initOverrides);
    return await response.value();
  }
  /**
   * You need to have a permission with action `licensing.reports:read`.
   * Get custom permissions report in CSV format.
   * @deprecated
   */
  async getCustomPermissionsCSVRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/licensing/custom-permissions-csv`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * You need to have a permission with action `licensing.reports:read`.
   * Get custom permissions report in CSV format.
   * @deprecated
   */
  async getCustomPermissionsCSV(initOverrides) {
    await this.getCustomPermissionsCSVRaw(initOverrides);
  }
  /**
   * You need to have a permission with action `licensing.reports:read`.
   * Get custom permissions report.
   * @deprecated
   */
  async getCustomPermissionsReportRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/licensing/custom-permissions`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * You need to have a permission with action `licensing.reports:read`.
   * Get custom permissions report.
   * @deprecated
   */
  async getCustomPermissionsReport(initOverrides) {
    await this.getCustomPermissionsReportRaw(initOverrides);
  }
  /**
   * You need to have a permission with action `licensing:read`.
   * Get license token.
   */
  async getLicenseTokenRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/licensing/token`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TokenFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `licensing:read`.
   * Get license token.
   */
  async getLicenseToken(initOverrides) {
    const response = await this.getLicenseTokenRaw(initOverrides);
    return await response.value();
  }
  /**
   * It exposes the SP (Grafana\'s) metadata for the IdP\'s consumption.
   */
  async getMetadataRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/saml/metadata`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response);
  }
  /**
   * It exposes the SP (Grafana\'s) metadata for the IdP\'s consumption.
   */
  async getMetadata(initOverrides) {
    const response = await this.getMetadataRaw(initOverrides);
    return await response.value();
  }
  /**
   * Return the prometheus remote write target.
   */
  async getRecordingRuleWriteTargetRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/recording-rules/writer`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PrometheusRemoteWriteTargetJSONFromJSON(jsonValue));
  }
  /**
   * Return the prometheus remote write target.
   */
  async getRecordingRuleWriteTarget(initOverrides) {
    const response = await this.getRecordingRuleWriteTargetRaw(initOverrides);
    return await response.value();
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:id:<report ID>`.
   * Get a report.
   */
  async getReportRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling getReport().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ReportFromJSON(jsonValue));
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:id:<report ID>`.
   * Get a report.
   */
  async getReport(requestParameters, initOverrides) {
    const response = await this.getReportRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`x.
   * Get settings.
   */
  async getReportSettingsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports/settings`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ReportSettingsFromJSON(jsonValue));
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`x.
   * Get settings.
   */
  async getReportSettings(initOverrides) {
    const response = await this.getReportSettingsRaw(initOverrides);
    return await response.value();
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:*`.
   * List reports.
   */
  async getReportsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(ReportFromJSON));
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:*`.
   * List reports.
   */
  async getReports(initOverrides) {
    const response = await this.getReportsRaw(initOverrides);
    return await response.value();
  }
  /**
   * Get a role for the given UID.  You need to have a permission with action `roles:read` and scope `roles:*`.
   * Get a role.
   */
  async getRoleRaw(requestParameters, initOverrides) {
    if (requestParameters["roleUID"] == null) {
      throw new RequiredError(
        "roleUID",
        'Required parameter "roleUID" was null or undefined when calling getRole().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters["roleUID"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RoleDTOFromJSON(jsonValue));
  }
  /**
   * Get a role for the given UID.  You need to have a permission with action `roles:read` and scope `roles:*`.
   * Get a role.
   */
  async getRole(requestParameters, initOverrides) {
    const response = await this.getRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
   * Get role assignments.
   */
  async getRoleAssignmentsRaw(requestParameters, initOverrides) {
    if (requestParameters["roleUID"] == null) {
      throw new RequiredError(
        "roleUID",
        'Required parameter "roleUID" was null or undefined when calling getRoleAssignments().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/roles/{roleUID}/assignments`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters["roleUID"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RoleAssignmentsDTOFromJSON(jsonValue));
  }
  /**
   * Get role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
   * Get role assignments.
   */
  async getRoleAssignments(requestParameters, initOverrides) {
    const response = await this.getRoleAssignmentsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * GetLogout initiates single logout process.
   */
  async getSAMLLogoutRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/logout/saml`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * GetLogout initiates single logout process.
   */
  async getSAMLLogout(initOverrides) {
    await this.getSAMLLogoutRaw(initOverrides);
  }
  /**
   * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
   * It performs Single Logout (SLO) callback.
   */
  async getSLORaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/saml/slo`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
   * It performs Single Logout (SLO) callback.
   */
  async getSLO(initOverrides) {
    await this.getSLORaw(initOverrides);
  }
  /**
   * Check license availability.
   */
  async getStatusRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/licensing/check`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Check license availability.
   */
  async getStatus(initOverrides) {
    await this.getStatusRaw(initOverrides);
  }
  /**
   * You need to have a permission with action `ldap.status:read`.
   * Returns the current state of the LDAP background sync integration.
   */
  async getSyncStatusRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/ldap-sync-status`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ActiveSyncStatusDTOFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `ldap.status:read`.
   * Returns the current state of the LDAP background sync integration.
   */
  async getSyncStatus(initOverrides) {
    const response = await this.getSyncStatusRaw(initOverrides);
    return await response.value();
  }
  /**
   * Get External Groups.
   */
  async getTeamGroupsApiRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling getTeamGroupsApi().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/teams/{teamId}/groups`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(TeamGroupDTOFromJSON));
  }
  /**
   * Get External Groups.
   */
  async getTeamGroupsApi(requestParameters, initOverrides) {
    const response = await this.getTeamGroupsApiRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Lists all rules in the database: active or deleted.
   */
  async listRecordingRulesRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/recording-rules`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(RecordingRuleJSONFromJSON));
  }
  /**
   * Lists all rules in the database: active or deleted.
   */
  async listRecordingRules(initOverrides) {
    const response = await this.listRecordingRulesRaw(initOverrides);
    return await response.value();
  }
  /**
   * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.  You need to have a permission with action `roles:read` and scope `roles:*`.
   * Get all roles.
   */
  async listRolesRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["delegatable"] != null) {
      queryParameters["delegatable"] = requestParameters["delegatable"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/roles`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(RoleDTOFromJSON));
  }
  /**
   * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.  You need to have a permission with action `roles:read` and scope `roles:*`.
   * Get all roles.
   */
  async listRoles(requestParameters = {}, initOverrides) {
    const response = await this.listRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`.
   * Get team roles.
   */
  async listTeamRolesRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling listTeamRoles().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/teams/{teamId}/roles`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`.
   * Get team roles.
   */
  async listTeamRoles(requestParameters, initOverrides) {
    const response = await this.listTeamRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Lists the roles that have been directly assigned to the given teams.  You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
   * List roles assigned to multiple teams.
   */
  async listTeamsRolesRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling listTeamsRoles().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/teams/roles/search`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RolesSearchQueryToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response);
  }
  /**
   * Lists the roles that have been directly assigned to the given teams.  You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
   * List roles assigned to multiple teams.
   */
  async listTeamsRoles(requestParameters, initOverrides) {
    const response = await this.listTeamsRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
   * List roles assigned to a user.
   */
  async listUserRolesRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling listUserRoles().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/users/{userId}/roles`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(RoleDTOFromJSON));
  }
  /**
   * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
   * List roles assigned to a user.
   */
  async listUserRoles(requestParameters, initOverrides) {
    const response = await this.listUserRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:*`.
   * List roles assigned to multiple users.
   */
  async listUsersRolesRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling listUsersRoles().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/users/roles/search`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RolesSearchQueryToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response);
  }
  /**
   * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:*`.
   * List roles assigned to multiple users.
   */
  async listUsersRoles(requestParameters, initOverrides) {
    const response = await this.listUsersRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * It performs Assertion Consumer Service (ACS).
   */
  async postACSRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["relayState"] != null) {
      queryParameters["RelayState"] = requestParameters["relayState"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/saml/acs`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * It performs Assertion Consumer Service (ACS).
   */
  async postACS(requestParameters = {}, initOverrides) {
    await this.postACSRaw(requestParameters, initOverrides);
  }
  /**
   * You need to have a permission with action `licensing:update`.
   * Create license token.
   */
  async postLicenseTokenRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling postLicenseToken().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/licensing/token`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: DeleteTokenCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TokenFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `licensing:update`.
   * Create license token.
   */
  async postLicenseToken(requestParameters, initOverrides) {
    const response = await this.postLicenseTokenRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Manually ask license issuer for a new token. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:update`.
   * Manually force license refresh.
   */
  async postRenewLicenseTokenRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling postRenewLicenseToken().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/licensing/token/renew`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters["body"]
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Manually ask license issuer for a new token. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:update`.
   * Manually force license refresh.
   */
  async postRenewLicenseToken(requestParameters, initOverrides) {
    await this.postRenewLicenseTokenRaw(requestParameters, initOverrides);
  }
  /**
   * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
   * It performs Single Logout (SLO) callback.
   */
  async postSLORaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["sAMLRequest"] != null) {
      queryParameters["SAMLRequest"] = requestParameters["sAMLRequest"];
    }
    if (requestParameters["sAMLResponse"] != null) {
      queryParameters["SAMLResponse"] = requestParameters["sAMLResponse"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/saml/slo`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
   * It performs Single Logout (SLO) callback.
   */
  async postSLO(requestParameters = {}, initOverrides) {
    await this.postSLORaw(requestParameters, initOverrides);
  }
  /**
   * You need to have a permission with action `licensing:read`.
   * Refresh license stats.
   */
  async refreshLicenseStatsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/licensing/refresh-stats`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ActiveUserStatsFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `licensing:read`.
   * Refresh license stats.
   */
  async refreshLicenseStats(initOverrides) {
    const response = await this.refreshLicenseStatsRaw(initOverrides);
    return await response.value();
  }
  /**
   * Remove External Group.
   */
  async removeTeamGroupApiQueryRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling removeTeamGroupApiQuery().'
      );
    }
    const queryParameters = {};
    if (requestParameters["groupId"] != null) {
      queryParameters["groupId"] = requestParameters["groupId"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/teams/{teamId}/groups`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Remove External Group.
   */
  async removeTeamGroupApiQuery(requestParameters, initOverrides) {
    const response = await this.removeTeamGroupApiQueryRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`.
   * Remove team role.
   */
  async removeTeamRoleRaw(requestParameters, initOverrides) {
    if (requestParameters["roleUID"] == null) {
      throw new RequiredError(
        "roleUID",
        'Required parameter "roleUID" was null or undefined when calling removeTeamRole().'
      );
    }
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling removeTeamRole().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/teams/{teamId}/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters["roleUID"]))).replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`.
   * Remove team role.
   */
  async removeTeamRole(requestParameters, initOverrides) {
    const response = await this.removeTeamRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Revoke a role from a user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
   * Remove a user role assignment.
   */
  async removeUserRoleRaw(requestParameters, initOverrides) {
    if (requestParameters["roleUID"] == null) {
      throw new RequiredError(
        "roleUID",
        'Required parameter "roleUID" was null or undefined when calling removeUserRole().'
      );
    }
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling removeUserRole().'
      );
    }
    const queryParameters = {};
    if (requestParameters["global"] != null) {
      queryParameters["global"] = requestParameters["global"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/users/{userId}/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters["roleUID"]))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Revoke a role from a user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
   * Remove a user role assignment.
   */
  async removeUserRole(requestParameters, initOverrides) {
    const response = await this.removeUserRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Available to all users and with a valid license.
   * Render report for multiple dashboards.
   */
  async renderReportPDFsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["dashboardID"] != null) {
      queryParameters["dashboardID"] = requestParameters["dashboardID"];
    }
    if (requestParameters["orientation"] != null) {
      queryParameters["orientation"] = requestParameters["orientation"];
    }
    if (requestParameters["layout"] != null) {
      queryParameters["layout"] = requestParameters["layout"];
    }
    if (requestParameters["title"] != null) {
      queryParameters["title"] = requestParameters["title"];
    }
    if (requestParameters["scaleFactor"] != null) {
      queryParameters["scaleFactor"] = requestParameters["scaleFactor"];
    }
    if (requestParameters["includeTables"] != null) {
      queryParameters["includeTables"] = requestParameters["includeTables"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports/render/pdfs`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response);
  }
  /**
   * Available to all users and with a valid license.
   * Render report for multiple dashboards.
   */
  async renderReportPDFs(requestParameters = {}, initOverrides) {
    const response = await this.renderReportPDFsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:write`xx.
   * Save settings.
   */
  async saveReportSettingsRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling saveReportSettings().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports/settings`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ReportSettingsToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:write`xx.
   * Save settings.
   */
  async saveReportSettings(requestParameters, initOverrides) {
    const response = await this.saveReportSettingsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Returns the result of the search through access-control role assignments.  You need to have a permission with action `teams.roles:read` on scope `teams:*` and a permission with action `users.roles:read` on scope `users:*`.
   * Debug permissions.
   */
  async searchResultRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/assignments/search`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchResultFromJSON(jsonValue));
  }
  /**
   * Returns the result of the search through access-control role assignments.  You need to have a permission with action `teams.roles:read` on scope `teams:*` and a permission with action `users.roles:read` on scope `users:*`.
   * Debug permissions.
   */
  async searchResult(initOverrides) {
    const response = await this.searchResultRaw(initOverrides);
    return await response.value();
  }
  /**
   * Generate and send a report. This API waits for the report to be generated before returning. We recommend that you set the client’s timeout to at least 60 seconds. Available to org admins only and with a valid license.  Only available in Grafana Enterprise v7.0+. This API endpoint is experimental and may be deprecated in a future release. On deprecation, a migration strategy will be provided and the endpoint will remain functional until the next major release of Grafana.  You need to have a permission with action `reports:send`.
   * Send a report.
   */
  async sendReportRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling sendReport().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports/email`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ReportEmailToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Generate and send a report. This API waits for the report to be generated before returning. We recommend that you set the client’s timeout to at least 60 seconds. Available to org admins only and with a valid license.  Only available in Grafana Enterprise v7.0+. This API endpoint is experimental and may be deprecated in a future release. On deprecation, a migration strategy will be provided and the endpoint will remain functional until the next major release of Grafana.  You need to have a permission with action `reports:send`.
   * Send a report.
   */
  async sendReport(requestParameters, initOverrides) {
    const response = await this.sendReportRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Available to org admins only and with a valid license.  You need to have a permission with action `reports:send`.
   * Send test report via email.
   */
  async sendTestEmailRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling sendTestEmail().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports/test-email`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateOrUpdateReportConfigToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Available to org admins only and with a valid license.  You need to have a permission with action `reports:send`.
   * Send test report via email.
   */
  async sendTestEmail(requestParameters, initOverrides) {
    const response = await this.sendTestEmailRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Set role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
   * Set role assignments.
   */
  async setRoleAssignmentsRaw(requestParameters, initOverrides) {
    if (requestParameters["roleUID"] == null) {
      throw new RequiredError(
        "roleUID",
        'Required parameter "roleUID" was null or undefined when calling setRoleAssignments().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling setRoleAssignments().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/roles/{roleUID}/assignments`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters["roleUID"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: SetRoleAssignmentsCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RoleAssignmentsDTOFromJSON(jsonValue));
  }
  /**
   * Set role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
   * Set role assignments.
   */
  async setRoleAssignments(requestParameters, initOverrides) {
    const response = await this.setRoleAssignmentsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each.
   * Update team role.
   */
  async setTeamRolesRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling setTeamRoles().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/teams/{teamId}/roles`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each.
   * Update team role.
   */
  async setTeamRoles(requestParameters, initOverrides) {
    const response = await this.setTeamRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user. If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.  You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
   * Set user role assignments.
   */
  async setUserRolesRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling setUserRoles().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling setUserRoles().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/users/{userId}/roles`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: SetUserRolesCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user. If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.  You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
   * Set user role assignments.
   */
  async setUserRoles(requestParameters, initOverrides) {
    const response = await this.setUserRolesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Test a recording rule.
   */
  async testCreateRecordingRuleRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling testCreateRecordingRule().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/recording-rules/test`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RecordingRuleJSONToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Test a recording rule.
   */
  async testCreateRecordingRule(requestParameters, initOverrides) {
    const response = await this.testCreateRecordingRuleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update the active status of a rule.
   */
  async updateRecordingRuleRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateRecordingRule().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/recording-rules`,
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: RecordingRuleJSONToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RecordingRuleJSONFromJSON(jsonValue));
  }
  /**
   * Update the active status of a rule.
   */
  async updateRecordingRule(requestParameters, initOverrides) {
    const response = await this.updateRecordingRuleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.admin:write` with scope `reports:id:<report ID>`.
   * Update a report.
   */
  async updateReportRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling updateReport().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateReport().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: CreateOrUpdateReportConfigToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.admin:write` with scope `reports:id:<report ID>`.
   * Update a report.
   */
  async updateReport(requestParameters, initOverrides) {
    const response = await this.updateReportRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
   * Update a custom role.
   */
  async updateRoleRaw(requestParameters, initOverrides) {
    if (requestParameters["roleUID"] == null) {
      throw new RequiredError(
        "roleUID",
        'Required parameter "roleUID" was null or undefined when calling updateRole().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateRole().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/access-control/roles/{roleUID}`.replace(`{${"roleUID"}}`, encodeURIComponent(String(requestParameters["roleUID"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateRoleCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RoleDTOFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
   * Update a custom role.
   */
  async updateRole(requestParameters, initOverrides) {
    const response = await this.updateRoleRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/FolderPermissionsApi.ts
var FolderPermissionsApi = class extends BaseAPI {
  /**
   * Gets all existing permissions for the folder with the given `uid`.
   */
  async getFolderPermissionListRaw(requestParameters, initOverrides) {
    if (requestParameters["folderUid"] == null) {
      throw new RequiredError(
        "folderUid",
        'Required parameter "folderUid" was null or undefined when calling getFolderPermissionList().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/folders/{folder_uid}/permissions`.replace(`{${"folder_uid"}}`, encodeURIComponent(String(requestParameters["folderUid"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(DashboardACLInfoDTOFromJSON));
  }
  /**
   * Gets all existing permissions for the folder with the given `uid`.
   */
  async getFolderPermissionList(requestParameters, initOverrides) {
    const response = await this.getFolderPermissionListRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Updates permissions for a folder. This operation will remove existing permissions if they’re not included in the request.
   */
  async updateFolderPermissionsRaw(requestParameters, initOverrides) {
    if (requestParameters["folderUid"] == null) {
      throw new RequiredError(
        "folderUid",
        'Required parameter "folderUid" was null or undefined when calling updateFolderPermissions().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateFolderPermissions().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/folders/{folder_uid}/permissions`.replace(`{${"folder_uid"}}`, encodeURIComponent(String(requestParameters["folderUid"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateDashboardACLCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Updates permissions for a folder. This operation will remove existing permissions if they’re not included in the request.
   */
  async updateFolderPermissions(requestParameters, initOverrides) {
    const response = await this.updateFolderPermissionsRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/FoldersApi.ts
var FoldersApi = class extends BaseAPI {
  /**
   * If nested folders are enabled then it additionally expects the parent folder UID.
   * Create folder.
   */
  async createFolderRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createFolder().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/folders`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateFolderCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
  }
  /**
   * If nested folders are enabled then it additionally expects the parent folder UID.
   * Create folder.
   */
  async createFolder(requestParameters, initOverrides) {
    const response = await this.createFolderRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Deletes an existing folder identified by UID along with all dashboards (and their alerts) stored in the folder. This operation cannot be reverted. If nested folders are enabled then it also deletes all the subfolders.
   * Delete folder.
   */
  async deleteFolderRaw(requestParameters, initOverrides) {
    if (requestParameters["folderUid"] == null) {
      throw new RequiredError(
        "folderUid",
        'Required parameter "folderUid" was null or undefined when calling deleteFolder().'
      );
    }
    const queryParameters = {};
    if (requestParameters["forceDeleteRules"] != null) {
      queryParameters["forceDeleteRules"] = requestParameters["forceDeleteRules"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/folders/{folder_uid}`.replace(`{${"folder_uid"}}`, encodeURIComponent(String(requestParameters["folderUid"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => DeleteFolder200ResponseFromJSON(jsonValue));
  }
  /**
   * Deletes an existing folder identified by UID along with all dashboards (and their alerts) stored in the folder. This operation cannot be reverted. If nested folders are enabled then it also deletes all the subfolders.
   * Delete folder.
   */
  async deleteFolder(requestParameters, initOverrides) {
    const response = await this.deleteFolderRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Returns the folder identified by id. This is deprecated. Please refer to [updated API](#/folders/getFolderByUID) instead
   * Get folder by id.
   * @deprecated
   */
  async getFolderByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["folderId"] == null) {
      throw new RequiredError(
        "folderId",
        'Required parameter "folderId" was null or undefined when calling getFolderByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/folders/id/{folder_id}`.replace(`{${"folder_id"}}`, encodeURIComponent(String(requestParameters["folderId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
  }
  /**
   * Returns the folder identified by id. This is deprecated. Please refer to [updated API](#/folders/getFolderByUID) instead
   * Get folder by id.
   * @deprecated
   */
  async getFolderByID(requestParameters, initOverrides) {
    const response = await this.getFolderByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get folder by uid.
   */
  async getFolderByUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["folderUid"] == null) {
      throw new RequiredError(
        "folderUid",
        'Required parameter "folderUid" was null or undefined when calling getFolderByUID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/folders/{folder_uid}`.replace(`{${"folder_uid"}}`, encodeURIComponent(String(requestParameters["folderUid"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
  }
  /**
   * Get folder by uid.
   */
  async getFolderByUID(requestParameters, initOverrides) {
    const response = await this.getFolderByUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Gets the count of each descendant of a folder by kind. The folder is identified by UID.
   */
  async getFolderDescendantCountsRaw(requestParameters, initOverrides) {
    if (requestParameters["folderUid"] == null) {
      throw new RequiredError(
        "folderUid",
        'Required parameter "folderUid" was null or undefined when calling getFolderDescendantCounts().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/folders/{folder_uid}/counts`.replace(`{${"folder_uid"}}`, encodeURIComponent(String(requestParameters["folderUid"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response);
  }
  /**
   * Gets the count of each descendant of a folder by kind. The folder is identified by UID.
   */
  async getFolderDescendantCounts(requestParameters, initOverrides) {
    const response = await this.getFolderDescendantCountsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * It returns all folders that the authenticated user has permission to view. If nested folders are enabled, it expects an additional query parameter with the parent folder UID and returns the immediate subfolders that the authenticated user has permission to view. If the parameter is not supplied then it returns immediate subfolders under the root that the authenticated user has permission to view.
   * Get all folders.
   */
  async getFoldersRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    if (requestParameters["parentUid"] != null) {
      queryParameters["parentUid"] = requestParameters["parentUid"];
    }
    if (requestParameters["permission"] != null) {
      queryParameters["permission"] = requestParameters["permission"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/folders`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(FolderSearchHitFromJSON));
  }
  /**
   * It returns all folders that the authenticated user has permission to view. If nested folders are enabled, it expects an additional query parameter with the parent folder UID and returns the immediate subfolders that the authenticated user has permission to view. If the parameter is not supplied then it returns immediate subfolders under the root that the authenticated user has permission to view.
   * Get all folders.
   */
  async getFolders(requestParameters = {}, initOverrides) {
    const response = await this.getFoldersRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Move folder.
   */
  async moveFolderRaw(requestParameters, initOverrides) {
    if (requestParameters["folderUid"] == null) {
      throw new RequiredError(
        "folderUid",
        'Required parameter "folderUid" was null or undefined when calling moveFolder().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling moveFolder().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/folders/{folder_uid}/move`.replace(`{${"folder_uid"}}`, encodeURIComponent(String(requestParameters["folderUid"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: MoveFolderCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
  }
  /**
   * Move folder.
   */
  async moveFolder(requestParameters, initOverrides) {
    const response = await this.moveFolderRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update folder.
   */
  async updateFolderRaw(requestParameters, initOverrides) {
    if (requestParameters["folderUid"] == null) {
      throw new RequiredError(
        "folderUid",
        'Required parameter "folderUid" was null or undefined when calling updateFolder().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateFolder().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/folders/{folder_uid}`.replace(`{${"folder_uid"}}`, encodeURIComponent(String(requestParameters["folderUid"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateFolderCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => FolderFromJSON(jsonValue));
  }
  /**
   * Update folder.
   */
  async updateFolder(requestParameters, initOverrides) {
    const response = await this.updateFolderRaw(requestParameters, initOverrides);
    return await response.value();
  }
};
var GetFoldersPermissionEnum = {
  Edit: "Edit",
  View: "View"
};

// apis/GetCurrentOrgApi.ts
var GetCurrentOrgApi = class extends BaseAPI {
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope).
   * Fetch Organization quota.
   */
  async getCurrentOrgQuotaRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/org/quotas`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(QuotaDTOFromJSON));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope).
   * Fetch Organization quota.
   */
  async getCurrentOrgQuota(initOverrides) {
    const response = await this.getCurrentOrgQuotaRaw(initOverrides);
    return await response.value();
  }
};

// apis/LdapDebugApi.ts
var LdapDebugApi = class extends BaseAPI {
  /**
   * You need to have a permission with action `ldap.status:read`.
   * Returns the current state of the LDAP background sync integration.
   */
  async getSyncStatusRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/admin/ldap-sync-status`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ActiveSyncStatusDTOFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `ldap.status:read`.
   * Returns the current state of the LDAP background sync integration.
   */
  async getSyncStatus(initOverrides) {
    const response = await this.getSyncStatusRaw(initOverrides);
    return await response.value();
  }
};

// apis/LibraryElementsApi.ts
var LibraryElementsApi = class extends BaseAPI {
  /**
   * Creates a new library element.
   * Create library element.
   */
  async createLibraryElementRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createLibraryElement().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/library-elements`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateLibraryElementCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => LibraryElementResponseFromJSON(jsonValue));
  }
  /**
   * Creates a new library element.
   * Create library element.
   */
  async createLibraryElement(requestParameters, initOverrides) {
    const response = await this.createLibraryElementRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Deletes an existing library element as specified by the UID. This operation cannot be reverted. You cannot delete a library element that is connected. This operation cannot be reverted.
   * Delete library element.
   */
  async deleteLibraryElementByUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["libraryElementUid"] == null) {
      throw new RequiredError(
        "libraryElementUid",
        'Required parameter "libraryElementUid" was null or undefined when calling deleteLibraryElementByUID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/library-elements/{library_element_uid}`.replace(`{${"library_element_uid"}}`, encodeURIComponent(String(requestParameters["libraryElementUid"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Deletes an existing library element as specified by the UID. This operation cannot be reverted. You cannot delete a library element that is connected. This operation cannot be reverted.
   * Delete library element.
   */
  async deleteLibraryElementByUID(requestParameters, initOverrides) {
    const response = await this.deleteLibraryElementByUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Returns a library element with the given name.
   * Get library element by name.
   */
  async getLibraryElementByNameRaw(requestParameters, initOverrides) {
    if (requestParameters["libraryElementName"] == null) {
      throw new RequiredError(
        "libraryElementName",
        'Required parameter "libraryElementName" was null or undefined when calling getLibraryElementByName().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/library-elements/name/{library_element_name}`.replace(`{${"library_element_name"}}`, encodeURIComponent(String(requestParameters["libraryElementName"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => LibraryElementArrayResponseFromJSON(jsonValue));
  }
  /**
   * Returns a library element with the given name.
   * Get library element by name.
   */
  async getLibraryElementByName(requestParameters, initOverrides) {
    const response = await this.getLibraryElementByNameRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Returns a library element with the given UID.
   * Get library element by UID.
   */
  async getLibraryElementByUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["libraryElementUid"] == null) {
      throw new RequiredError(
        "libraryElementUid",
        'Required parameter "libraryElementUid" was null or undefined when calling getLibraryElementByUID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/library-elements/{library_element_uid}`.replace(`{${"library_element_uid"}}`, encodeURIComponent(String(requestParameters["libraryElementUid"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => LibraryElementResponseFromJSON(jsonValue));
  }
  /**
   * Returns a library element with the given UID.
   * Get library element by UID.
   */
  async getLibraryElementByUID(requestParameters, initOverrides) {
    const response = await this.getLibraryElementByUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Returns a list of connections for a library element based on the UID specified.
   * Get library element connections.
   */
  async getLibraryElementConnectionsRaw(requestParameters, initOverrides) {
    if (requestParameters["libraryElementUid"] == null) {
      throw new RequiredError(
        "libraryElementUid",
        'Required parameter "libraryElementUid" was null or undefined when calling getLibraryElementConnections().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/library-elements/{library_element_uid}/connections/`.replace(`{${"library_element_uid"}}`, encodeURIComponent(String(requestParameters["libraryElementUid"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => LibraryElementConnectionsResponseFromJSON(jsonValue));
  }
  /**
   * Returns a list of connections for a library element based on the UID specified.
   * Get library element connections.
   */
  async getLibraryElementConnections(requestParameters, initOverrides) {
    const response = await this.getLibraryElementConnectionsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Returns a list of all library elements the authenticated user has permission to view. Use the `perPage` query parameter to control the maximum number of library elements returned; the default limit is `100`. You can also use the `page` query parameter to fetch library elements from any page other than the first one.
   * Get all library elements.
   */
  async getLibraryElementsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["searchString"] != null) {
      queryParameters["searchString"] = requestParameters["searchString"];
    }
    if (requestParameters["kind"] != null) {
      queryParameters["kind"] = requestParameters["kind"];
    }
    if (requestParameters["sortDirection"] != null) {
      queryParameters["sortDirection"] = requestParameters["sortDirection"];
    }
    if (requestParameters["typeFilter"] != null) {
      queryParameters["typeFilter"] = requestParameters["typeFilter"];
    }
    if (requestParameters["excludeUid"] != null) {
      queryParameters["excludeUid"] = requestParameters["excludeUid"];
    }
    if (requestParameters["folderFilter"] != null) {
      queryParameters["folderFilter"] = requestParameters["folderFilter"];
    }
    if (requestParameters["perPage"] != null) {
      queryParameters["perPage"] = requestParameters["perPage"];
    }
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/library-elements`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => LibraryElementSearchResponseFromJSON(jsonValue));
  }
  /**
   * Returns a list of all library elements the authenticated user has permission to view. Use the `perPage` query parameter to control the maximum number of library elements returned; the default limit is `100`. You can also use the `page` query parameter to fetch library elements from any page other than the first one.
   * Get all library elements.
   */
  async getLibraryElements(requestParameters = {}, initOverrides) {
    const response = await this.getLibraryElementsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Updates an existing library element identified by uid.
   * Update library element.
   */
  async updateLibraryElementRaw(requestParameters, initOverrides) {
    if (requestParameters["libraryElementUid"] == null) {
      throw new RequiredError(
        "libraryElementUid",
        'Required parameter "libraryElementUid" was null or undefined when calling updateLibraryElement().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateLibraryElement().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/library-elements/{library_element_uid}`.replace(`{${"library_element_uid"}}`, encodeURIComponent(String(requestParameters["libraryElementUid"]))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: PatchLibraryElementCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => LibraryElementResponseFromJSON(jsonValue));
  }
  /**
   * Updates an existing library element identified by uid.
   * Update library element.
   */
  async updateLibraryElement(requestParameters, initOverrides) {
    const response = await this.updateLibraryElementRaw(requestParameters, initOverrides);
    return await response.value();
  }
};
var GetLibraryElementsKindEnum = {
  NUMBER_1: 1,
  NUMBER_2: 2
};
var GetLibraryElementsSortDirectionEnum = {
  Asc: "alpha-asc",
  Desc: "alpha-desc"
};

// apis/LicensingApi.ts
var LicensingApi = class extends BaseAPI {
  /**
   * Removes the license stored in the Grafana database. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:delete`.
   * Remove license from database.
   */
  async deleteLicenseTokenRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling deleteLicenseToken().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/licensing/token`,
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters,
      body: DeleteTokenCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ErrorResponseBodyFromJSON(jsonValue));
  }
  /**
   * Removes the license stored in the Grafana database. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:delete`.
   * Remove license from database.
   */
  async deleteLicenseToken(requestParameters, initOverrides) {
    const response = await this.deleteLicenseTokenRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * You need to have a permission with action `licensing.reports:read`.
   * Get custom permissions report in CSV format.
   * @deprecated
   */
  async getCustomPermissionsCSVRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/licensing/custom-permissions-csv`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * You need to have a permission with action `licensing.reports:read`.
   * Get custom permissions report in CSV format.
   * @deprecated
   */
  async getCustomPermissionsCSV(initOverrides) {
    await this.getCustomPermissionsCSVRaw(initOverrides);
  }
  /**
   * You need to have a permission with action `licensing.reports:read`.
   * Get custom permissions report.
   * @deprecated
   */
  async getCustomPermissionsReportRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/licensing/custom-permissions`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * You need to have a permission with action `licensing.reports:read`.
   * Get custom permissions report.
   * @deprecated
   */
  async getCustomPermissionsReport(initOverrides) {
    await this.getCustomPermissionsReportRaw(initOverrides);
  }
  /**
   * You need to have a permission with action `licensing:read`.
   * Get license token.
   */
  async getLicenseTokenRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/licensing/token`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TokenFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `licensing:read`.
   * Get license token.
   */
  async getLicenseToken(initOverrides) {
    const response = await this.getLicenseTokenRaw(initOverrides);
    return await response.value();
  }
  /**
   * Check license availability.
   */
  async getStatusRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/licensing/check`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Check license availability.
   */
  async getStatus(initOverrides) {
    await this.getStatusRaw(initOverrides);
  }
  /**
   * You need to have a permission with action `licensing:update`.
   * Create license token.
   */
  async postLicenseTokenRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling postLicenseToken().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/licensing/token`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: DeleteTokenCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TokenFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `licensing:update`.
   * Create license token.
   */
  async postLicenseToken(requestParameters, initOverrides) {
    const response = await this.postLicenseTokenRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Manually ask license issuer for a new token. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:update`.
   * Manually force license refresh.
   */
  async postRenewLicenseTokenRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling postRenewLicenseToken().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/licensing/token/renew`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: requestParameters["body"]
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Manually ask license issuer for a new token. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:update`.
   * Manually force license refresh.
   */
  async postRenewLicenseToken(requestParameters, initOverrides) {
    await this.postRenewLicenseTokenRaw(requestParameters, initOverrides);
  }
  /**
   * You need to have a permission with action `licensing:read`.
   * Refresh license stats.
   */
  async refreshLicenseStatsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/licensing/refresh-stats`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ActiveUserStatsFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `licensing:read`.
   * Refresh license stats.
   */
  async refreshLicenseStats(initOverrides) {
    const response = await this.refreshLicenseStatsRaw(initOverrides);
    return await response.value();
  }
};

// apis/OrgApi.ts
var OrgApi = class extends BaseAPI {
  /**
   * Adds a global user to the current organization.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:add` with scope `users:*`.
   * Add a new user to the current organization.
   */
  async addOrgUserToCurrentOrgRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling addOrgUserToCurrentOrg().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/org/users`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AddOrgUserCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Adds a global user to the current organization.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:add` with scope `users:*`.
   * Add a new user to the current organization.
   */
  async addOrgUserToCurrentOrg(requestParameters, initOverrides) {
    const response = await this.addOrgUserToCurrentOrgRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get current Organization.
   */
  async getCurrentOrgRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/org`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => OrgDetailsDTOFromJSON(jsonValue));
  }
  /**
   * Get current Organization.
   */
  async getCurrentOrg(initOverrides) {
    const response = await this.getCurrentOrgRaw(initOverrides);
    return await response.value();
  }
  /**
   * Returns all org users within the current organization. Accessible to users with org admin role. If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
   * Get all users within the current organization.
   */
  async getOrgUsersForCurrentOrgRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/org/users`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(OrgUserDTOFromJSON));
  }
  /**
   * Returns all org users within the current organization. Accessible to users with org admin role. If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
   * Get all users within the current organization.
   */
  async getOrgUsersForCurrentOrg(initOverrides) {
    const response = await this.getOrgUsersForCurrentOrgRaw(initOverrides);
    return await response.value();
  }
  /**
   * Returns all org users within the current organization, but with less detailed information. Accessible to users with org admin role, admin in any folder or admin of any team. Mainly used by Grafana UI for providing list of users when adding team members and when editing folder/dashboard permissions.
   * Get all users within the current organization (lookup)
   */
  async getOrgUsersForCurrentOrgLookupRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["query"] != null) {
      queryParameters["query"] = requestParameters["query"];
    }
    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/org/users/lookup`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(UserLookupDTOFromJSON));
  }
  /**
   * Returns all org users within the current organization, but with less detailed information. Accessible to users with org admin role, admin in any folder or admin of any team. Mainly used by Grafana UI for providing list of users when adding team members and when editing folder/dashboard permissions.
   * Get all users within the current organization (lookup)
   */
  async getOrgUsersForCurrentOrgLookup(requestParameters = {}, initOverrides) {
    const response = await this.getOrgUsersForCurrentOrgLookupRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:remove` with scope `users:*`.
   * Delete user in current organization.
   */
  async removeOrgUserForCurrentOrgRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling removeOrgUserForCurrentOrg().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/org/users/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:remove` with scope `users:*`.
   * Delete user in current organization.
   */
  async removeOrgUserForCurrentOrg(requestParameters, initOverrides) {
    const response = await this.removeOrgUserForCurrentOrgRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update current Organization.
   */
  async updateCurrentOrgRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateCurrentOrg().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/org`,
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateOrgFormToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Update current Organization.
   */
  async updateCurrentOrg(requestParameters, initOverrides) {
    const response = await this.updateCurrentOrgRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update current Organization\'s address.
   */
  async updateCurrentOrgAddressRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateCurrentOrgAddress().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/org/address`,
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateOrgAddressFormToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Update current Organization\'s address.
   */
  async updateCurrentOrgAddress(requestParameters, initOverrides) {
    const response = await this.updateCurrentOrgAddressRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users.role:update` with scope `users:*`.
   * Updates the given user.
   */
  async updateOrgUserForCurrentOrgRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling updateOrgUserForCurrentOrg().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateOrgUserForCurrentOrg().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/org/users/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateOrgUserCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users.role:update` with scope `users:*`.
   * Updates the given user.
   */
  async updateOrgUserForCurrentOrg(requestParameters, initOverrides) {
    const response = await this.updateOrgUserForCurrentOrgRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/OrgInvitesApi.ts
var OrgInvitesApi = class extends BaseAPI {
  /**
   * Add invite.
   */
  async addOrgInviteRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling addOrgInvite().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/org/invites`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AddInviteFormToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Add invite.
   */
  async addOrgInvite(requestParameters, initOverrides) {
    const response = await this.addOrgInviteRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get pending invites.
   */
  async getPendingOrgInvitesRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/org/invites`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(TempUserDTOFromJSON));
  }
  /**
   * Get pending invites.
   */
  async getPendingOrgInvites(initOverrides) {
    const response = await this.getPendingOrgInvitesRaw(initOverrides);
    return await response.value();
  }
  /**
   * Revoke invite.
   */
  async revokeInviteRaw(requestParameters, initOverrides) {
    if (requestParameters["invitationCode"] == null) {
      throw new RequiredError(
        "invitationCode",
        'Required parameter "invitationCode" was null or undefined when calling revokeInvite().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/org/invites/{invitation_code}/revoke`.replace(`{${"invitation_code"}}`, encodeURIComponent(String(requestParameters["invitationCode"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Revoke invite.
   */
  async revokeInvite(requestParameters, initOverrides) {
    const response = await this.revokeInviteRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/OrgPreferencesApi.ts
var OrgPreferencesApi = class extends BaseAPI {
  /**
   * Get Current Org Prefs.
   */
  async getOrgPreferencesRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/org/preferences`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PreferencesFromJSON(jsonValue));
  }
  /**
   * Get Current Org Prefs.
   */
  async getOrgPreferences(initOverrides) {
    const response = await this.getOrgPreferencesRaw(initOverrides);
    return await response.value();
  }
  /**
   * Patch Current Org Prefs.
   */
  async patchOrgPreferencesRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling patchOrgPreferences().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/org/preferences`,
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: PatchPrefsCmdToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Patch Current Org Prefs.
   */
  async patchOrgPreferences(requestParameters, initOverrides) {
    const response = await this.patchOrgPreferencesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update Current Org Prefs.
   */
  async updateOrgPreferencesRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateOrgPreferences().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/org/preferences`,
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdatePrefsCmdToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Update Current Org Prefs.
   */
  async updateOrgPreferences(requestParameters, initOverrides) {
    const response = await this.updateOrgPreferencesRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/OrgsApi.ts
var OrgsApi = class extends BaseAPI {
  /**
   * Adds a global user to the current organization.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:add` with scope `users:*`.
   * Add a new user to the current organization.
   */
  async addOrgUserRaw(requestParameters, initOverrides) {
    if (requestParameters["orgId"] == null) {
      throw new RequiredError(
        "orgId",
        'Required parameter "orgId" was null or undefined when calling addOrgUser().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling addOrgUser().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/orgs/{org_id}/users`.replace(`{${"org_id"}}`, encodeURIComponent(String(requestParameters["orgId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AddOrgUserCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Adds a global user to the current organization.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:add` with scope `users:*`.
   * Add a new user to the current organization.
   */
  async addOrgUser(requestParameters, initOverrides) {
    const response = await this.addOrgUserRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Only works if [users.allow_org_create](https://grafana.com/docs/grafana/latest/administration/configuration/#allow_org_create) is set.
   * Create Organization.
   */
  async createOrgRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createOrg().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/orgs`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateOrgCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CreateOrg200ResponseFromJSON(jsonValue));
  }
  /**
   * Only works if [users.allow_org_create](https://grafana.com/docs/grafana/latest/administration/configuration/#allow_org_create) is set.
   * Create Organization.
   */
  async createOrg(requestParameters, initOverrides) {
    const response = await this.createOrgRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Delete Organization.
   */
  async deleteOrgByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["orgId"] == null) {
      throw new RequiredError(
        "orgId",
        'Required parameter "orgId" was null or undefined when calling deleteOrgByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/orgs/{org_id}`.replace(`{${"org_id"}}`, encodeURIComponent(String(requestParameters["orgId"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Delete Organization.
   */
  async deleteOrgByID(requestParameters, initOverrides) {
    const response = await this.deleteOrgByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get Organization by ID.
   */
  async getOrgByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["orgId"] == null) {
      throw new RequiredError(
        "orgId",
        'Required parameter "orgId" was null or undefined when calling getOrgByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/orgs/{org_id}`.replace(`{${"org_id"}}`, encodeURIComponent(String(requestParameters["orgId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => OrgDetailsDTOFromJSON(jsonValue));
  }
  /**
   * Get Organization by ID.
   */
  async getOrgByID(requestParameters, initOverrides) {
    const response = await this.getOrgByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get Organization by ID.
   */
  async getOrgByNameRaw(requestParameters, initOverrides) {
    if (requestParameters["orgName"] == null) {
      throw new RequiredError(
        "orgName",
        'Required parameter "orgName" was null or undefined when calling getOrgByName().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/orgs/name/{org_name}`.replace(`{${"org_name"}}`, encodeURIComponent(String(requestParameters["orgName"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => OrgDetailsDTOFromJSON(jsonValue));
  }
  /**
   * Get Organization by ID.
   */
  async getOrgByName(requestParameters, initOverrides) {
    const response = await this.getOrgByNameRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope).
   * Fetch Organization quota.
   */
  async getOrgQuotaRaw(requestParameters, initOverrides) {
    if (requestParameters["orgId"] == null) {
      throw new RequiredError(
        "orgId",
        'Required parameter "orgId" was null or undefined when calling getOrgQuota().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/orgs/{org_id}/quotas`.replace(`{${"org_id"}}`, encodeURIComponent(String(requestParameters["orgId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(QuotaDTOFromJSON));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope).
   * Fetch Organization quota.
   */
  async getOrgQuota(requestParameters, initOverrides) {
    const response = await this.getOrgQuotaRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
   * Get Users in Organization.
   */
  async getOrgUsersRaw(requestParameters, initOverrides) {
    if (requestParameters["orgId"] == null) {
      throw new RequiredError(
        "orgId",
        'Required parameter "orgId" was null or undefined when calling getOrgUsers().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/orgs/{org_id}/users`.replace(`{${"org_id"}}`, encodeURIComponent(String(requestParameters["orgId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(OrgUserDTOFromJSON));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
   * Get Users in Organization.
   */
  async getOrgUsers(requestParameters, initOverrides) {
    const response = await this.getOrgUsersRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:remove` with scope `users:*`.
   * Delete user in current organization.
   */
  async removeOrgUserRaw(requestParameters, initOverrides) {
    if (requestParameters["orgId"] == null) {
      throw new RequiredError(
        "orgId",
        'Required parameter "orgId" was null or undefined when calling removeOrgUser().'
      );
    }
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling removeOrgUser().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/orgs/{org_id}/users/{user_id}`.replace(`{${"org_id"}}`, encodeURIComponent(String(requestParameters["orgId"]))).replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:remove` with scope `users:*`.
   * Delete user in current organization.
   */
  async removeOrgUser(requestParameters, initOverrides) {
    const response = await this.removeOrgUserRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
   * Search Users in Organization.
   */
  async searchOrgUsersRaw(requestParameters, initOverrides) {
    if (requestParameters["orgId"] == null) {
      throw new RequiredError(
        "orgId",
        'Required parameter "orgId" was null or undefined when calling searchOrgUsers().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/orgs/{org_id}/users/search`.replace(`{${"org_id"}}`, encodeURIComponent(String(requestParameters["orgId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchOrgUsersQueryResultFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
   * Search Users in Organization.
   */
  async searchOrgUsers(requestParameters, initOverrides) {
    const response = await this.searchOrgUsersRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Search all Organizations.
   */
  async searchOrgsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    if (requestParameters["perpage"] != null) {
      queryParameters["perpage"] = requestParameters["perpage"];
    }
    if (requestParameters["name"] != null) {
      queryParameters["name"] = requestParameters["name"];
    }
    if (requestParameters["query"] != null) {
      queryParameters["query"] = requestParameters["query"];
    }
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/orgs`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(OrgDTOFromJSON));
  }
  /**
   * Search all Organizations.
   */
  async searchOrgs(requestParameters = {}, initOverrides) {
    const response = await this.searchOrgsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update Organization.
   */
  async updateOrgRaw(requestParameters, initOverrides) {
    if (requestParameters["orgId"] == null) {
      throw new RequiredError(
        "orgId",
        'Required parameter "orgId" was null or undefined when calling updateOrg().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateOrg().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/orgs/{org_id}`.replace(`{${"org_id"}}`, encodeURIComponent(String(requestParameters["orgId"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateOrgFormToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Update Organization.
   */
  async updateOrg(requestParameters, initOverrides) {
    const response = await this.updateOrgRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update Organization\'s address.
   */
  async updateOrgAddressRaw(requestParameters, initOverrides) {
    if (requestParameters["orgId"] == null) {
      throw new RequiredError(
        "orgId",
        'Required parameter "orgId" was null or undefined when calling updateOrgAddress().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateOrgAddress().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/orgs/{org_id}/address`.replace(`{${"org_id"}}`, encodeURIComponent(String(requestParameters["orgId"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateOrgAddressFormToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Update Organization\'s address.
   */
  async updateOrgAddress(requestParameters, initOverrides) {
    const response = await this.updateOrgAddressRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:write` and scope `org:id:1` (orgIDScope).
   * Update user quota.
   */
  async updateOrgQuotaRaw(requestParameters, initOverrides) {
    if (requestParameters["quotaTarget"] == null) {
      throw new RequiredError(
        "quotaTarget",
        'Required parameter "quotaTarget" was null or undefined when calling updateOrgQuota().'
      );
    }
    if (requestParameters["orgId"] == null) {
      throw new RequiredError(
        "orgId",
        'Required parameter "orgId" was null or undefined when calling updateOrgQuota().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateOrgQuota().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/orgs/{org_id}/quotas/{quota_target}`.replace(`{${"quota_target"}}`, encodeURIComponent(String(requestParameters["quotaTarget"]))).replace(`{${"org_id"}}`, encodeURIComponent(String(requestParameters["orgId"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateQuotaCmdToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:write` and scope `org:id:1` (orgIDScope).
   * Update user quota.
   */
  async updateOrgQuota(requestParameters, initOverrides) {
    const response = await this.updateOrgQuotaRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users.role:update` with scope `users:*`.
   * Update Users in Organization.
   */
  async updateOrgUserRaw(requestParameters, initOverrides) {
    if (requestParameters["orgId"] == null) {
      throw new RequiredError(
        "orgId",
        'Required parameter "orgId" was null or undefined when calling updateOrgUser().'
      );
    }
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling updateOrgUser().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateOrgUser().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/orgs/{org_id}/users/{user_id}`.replace(`{${"org_id"}}`, encodeURIComponent(String(requestParameters["orgId"]))).replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateOrgUserCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users.role:update` with scope `users:*`.
   * Update Users in Organization.
   */
  async updateOrgUser(requestParameters, initOverrides) {
    const response = await this.updateOrgUserRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/PlaylistsApi.ts
var PlaylistsApi = class extends BaseAPI {
  /**
   * Create playlist.
   */
  async createPlaylistRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createPlaylist().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/playlists`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreatePlaylistCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PlaylistFromJSON(jsonValue));
  }
  /**
   * Create playlist.
   */
  async createPlaylist(requestParameters, initOverrides) {
    const response = await this.createPlaylistRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Delete playlist.
   */
  async deletePlaylistRaw(requestParameters, initOverrides) {
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling deletePlaylist().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/playlists/{uid}`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Delete playlist.
   */
  async deletePlaylist(requestParameters, initOverrides) {
    const response = await this.deletePlaylistRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get playlist.
   */
  async getPlaylistRaw(requestParameters, initOverrides) {
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling getPlaylist().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/playlists/{uid}`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PlaylistDTOFromJSON(jsonValue));
  }
  /**
   * Get playlist.
   */
  async getPlaylist(requestParameters, initOverrides) {
    const response = await this.getPlaylistRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get playlist items.
   */
  async getPlaylistItemsRaw(requestParameters, initOverrides) {
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling getPlaylistItems().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/playlists/{uid}/items`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(PlaylistItemDTOFromJSON));
  }
  /**
   * Get playlist items.
   */
  async getPlaylistItems(requestParameters, initOverrides) {
    const response = await this.getPlaylistItemsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get playlists.
   */
  async searchPlaylistsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["query"] != null) {
      queryParameters["query"] = requestParameters["query"];
    }
    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/playlists`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(PlaylistFromJSON));
  }
  /**
   * Get playlists.
   */
  async searchPlaylists(requestParameters = {}, initOverrides) {
    const response = await this.searchPlaylistsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update playlist.
   */
  async updatePlaylistRaw(requestParameters, initOverrides) {
    if (requestParameters["uid"] == null) {
      throw new RequiredError(
        "uid",
        'Required parameter "uid" was null or undefined when calling updatePlaylist().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updatePlaylist().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/playlists/{uid}`.replace(`{${"uid"}}`, encodeURIComponent(String(requestParameters["uid"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdatePlaylistCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PlaylistDTOFromJSON(jsonValue));
  }
  /**
   * Update playlist.
   */
  async updatePlaylist(requestParameters, initOverrides) {
    const response = await this.updatePlaylistRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/ProvisioningApi.ts
var ProvisioningApi = class extends BaseAPI {
  /**
   * Delete a specific alert rule by UID.
   */
  async routeDeleteAlertRuleRaw(requestParameters, initOverrides) {
    if (requestParameters["uID"] == null) {
      throw new RequiredError(
        "uID",
        'Required parameter "uID" was null or undefined when calling routeDeleteAlertRule().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (requestParameters["xDisableProvenance"] != null) {
      headerParameters["X-Disable-Provenance"] = String(requestParameters["xDisableProvenance"]);
    }
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/alert-rules/{UID}`.replace(`{${"UID"}}`, encodeURIComponent(String(requestParameters["uID"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Delete a specific alert rule by UID.
   */
  async routeDeleteAlertRule(requestParameters, initOverrides) {
    await this.routeDeleteAlertRuleRaw(requestParameters, initOverrides);
  }
  /**
   * Delete rule group
   */
  async routeDeleteAlertRuleGroupRaw(requestParameters, initOverrides) {
    if (requestParameters["folderUID"] == null) {
      throw new RequiredError(
        "folderUID",
        'Required parameter "folderUID" was null or undefined when calling routeDeleteAlertRuleGroup().'
      );
    }
    if (requestParameters["group"] == null) {
      throw new RequiredError(
        "group",
        'Required parameter "group" was null or undefined when calling routeDeleteAlertRuleGroup().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}`.replace(`{${"FolderUID"}}`, encodeURIComponent(String(requestParameters["folderUID"]))).replace(`{${"Group"}}`, encodeURIComponent(String(requestParameters["group"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Delete rule group
   */
  async routeDeleteAlertRuleGroup(requestParameters, initOverrides) {
    await this.routeDeleteAlertRuleGroupRaw(requestParameters, initOverrides);
  }
  /**
   * Delete a contact point.
   */
  async routeDeleteContactpointsRaw(requestParameters, initOverrides) {
    if (requestParameters["uID"] == null) {
      throw new RequiredError(
        "uID",
        'Required parameter "uID" was null or undefined when calling routeDeleteContactpoints().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/contact-points/{UID}`.replace(`{${"UID"}}`, encodeURIComponent(String(requestParameters["uID"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Delete a contact point.
   */
  async routeDeleteContactpoints(requestParameters, initOverrides) {
    await this.routeDeleteContactpointsRaw(requestParameters, initOverrides);
  }
  /**
   * Delete a mute timing.
   */
  async routeDeleteMuteTimingRaw(requestParameters, initOverrides) {
    if (requestParameters["name"] == null) {
      throw new RequiredError(
        "name",
        'Required parameter "name" was null or undefined when calling routeDeleteMuteTiming().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/mute-timings/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters["name"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Delete a mute timing.
   */
  async routeDeleteMuteTiming(requestParameters, initOverrides) {
    await this.routeDeleteMuteTimingRaw(requestParameters, initOverrides);
  }
  /**
   * Delete a template.
   */
  async routeDeleteTemplateRaw(requestParameters, initOverrides) {
    if (requestParameters["name"] == null) {
      throw new RequiredError(
        "name",
        'Required parameter "name" was null or undefined when calling routeDeleteTemplate().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/templates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters["name"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Delete a template.
   */
  async routeDeleteTemplate(requestParameters, initOverrides) {
    await this.routeDeleteTemplateRaw(requestParameters, initOverrides);
  }
  /**
   * Export a mute timing in provisioning format.
   */
  async routeExportMuteTimingRaw(requestParameters, initOverrides) {
    if (requestParameters["name"] == null) {
      throw new RequiredError(
        "name",
        'Required parameter "name" was null or undefined when calling routeExportMuteTiming().'
      );
    }
    const queryParameters = {};
    if (requestParameters["download"] != null) {
      queryParameters["download"] = requestParameters["download"];
    }
    if (requestParameters["format"] != null) {
      queryParameters["format"] = requestParameters["format"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/mute-timings/{name}/export`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters["name"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AlertingFileExportFromJSON(jsonValue));
  }
  /**
   * Export a mute timing in provisioning format.
   */
  async routeExportMuteTiming(requestParameters, initOverrides) {
    const response = await this.routeExportMuteTimingRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Export all mute timings in provisioning format.
   */
  async routeExportMuteTimingsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["download"] != null) {
      queryParameters["download"] = requestParameters["download"];
    }
    if (requestParameters["format"] != null) {
      queryParameters["format"] = requestParameters["format"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/mute-timings/export`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AlertingFileExportFromJSON(jsonValue));
  }
  /**
   * Export all mute timings in provisioning format.
   */
  async routeExportMuteTimings(requestParameters = {}, initOverrides) {
    const response = await this.routeExportMuteTimingsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a specific alert rule by UID.
   */
  async routeGetAlertRuleRaw(requestParameters, initOverrides) {
    if (requestParameters["uID"] == null) {
      throw new RequiredError(
        "uID",
        'Required parameter "uID" was null or undefined when calling routeGetAlertRule().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/alert-rules/{UID}`.replace(`{${"UID"}}`, encodeURIComponent(String(requestParameters["uID"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ProvisionedAlertRuleFromJSON(jsonValue));
  }
  /**
   * Get a specific alert rule by UID.
   */
  async routeGetAlertRule(requestParameters, initOverrides) {
    const response = await this.routeGetAlertRuleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Export an alert rule in provisioning file format.
   */
  async routeGetAlertRuleExportRaw(requestParameters, initOverrides) {
    if (requestParameters["uID"] == null) {
      throw new RequiredError(
        "uID",
        'Required parameter "uID" was null or undefined when calling routeGetAlertRuleExport().'
      );
    }
    const queryParameters = {};
    if (requestParameters["download"] != null) {
      queryParameters["download"] = requestParameters["download"];
    }
    if (requestParameters["format"] != null) {
      queryParameters["format"] = requestParameters["format"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/alert-rules/{UID}/export`.replace(`{${"UID"}}`, encodeURIComponent(String(requestParameters["uID"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AlertingFileExportFromJSON(jsonValue));
  }
  /**
   * Export an alert rule in provisioning file format.
   */
  async routeGetAlertRuleExport(requestParameters, initOverrides) {
    const response = await this.routeGetAlertRuleExportRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a rule group.
   */
  async routeGetAlertRuleGroupRaw(requestParameters, initOverrides) {
    if (requestParameters["folderUID"] == null) {
      throw new RequiredError(
        "folderUID",
        'Required parameter "folderUID" was null or undefined when calling routeGetAlertRuleGroup().'
      );
    }
    if (requestParameters["group"] == null) {
      throw new RequiredError(
        "group",
        'Required parameter "group" was null or undefined when calling routeGetAlertRuleGroup().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}`.replace(`{${"FolderUID"}}`, encodeURIComponent(String(requestParameters["folderUID"]))).replace(`{${"Group"}}`, encodeURIComponent(String(requestParameters["group"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AlertRuleGroupFromJSON(jsonValue));
  }
  /**
   * Get a rule group.
   */
  async routeGetAlertRuleGroup(requestParameters, initOverrides) {
    const response = await this.routeGetAlertRuleGroupRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Export an alert rule group in provisioning file format.
   */
  async routeGetAlertRuleGroupExportRaw(requestParameters, initOverrides) {
    if (requestParameters["folderUID"] == null) {
      throw new RequiredError(
        "folderUID",
        'Required parameter "folderUID" was null or undefined when calling routeGetAlertRuleGroupExport().'
      );
    }
    if (requestParameters["group"] == null) {
      throw new RequiredError(
        "group",
        'Required parameter "group" was null or undefined when calling routeGetAlertRuleGroupExport().'
      );
    }
    const queryParameters = {};
    if (requestParameters["download"] != null) {
      queryParameters["download"] = requestParameters["download"];
    }
    if (requestParameters["format"] != null) {
      queryParameters["format"] = requestParameters["format"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}/export`.replace(`{${"FolderUID"}}`, encodeURIComponent(String(requestParameters["folderUID"]))).replace(`{${"Group"}}`, encodeURIComponent(String(requestParameters["group"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AlertingFileExportFromJSON(jsonValue));
  }
  /**
   * Export an alert rule group in provisioning file format.
   */
  async routeGetAlertRuleGroupExport(requestParameters, initOverrides) {
    const response = await this.routeGetAlertRuleGroupExportRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get all the alert rules.
   */
  async routeGetAlertRulesRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/alert-rules`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(ProvisionedAlertRuleFromJSON));
  }
  /**
   * Get all the alert rules.
   */
  async routeGetAlertRules(initOverrides) {
    const response = await this.routeGetAlertRulesRaw(initOverrides);
    return await response.value();
  }
  /**
   * Export all alert rules in provisioning file format.
   */
  async routeGetAlertRulesExportRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["download"] != null) {
      queryParameters["download"] = requestParameters["download"];
    }
    if (requestParameters["format"] != null) {
      queryParameters["format"] = requestParameters["format"];
    }
    if (requestParameters["folderUid"] != null) {
      queryParameters["folderUid"] = requestParameters["folderUid"].join(COLLECTION_FORMATS["csv"]);
    }
    if (requestParameters["group"] != null) {
      queryParameters["group"] = requestParameters["group"];
    }
    if (requestParameters["ruleUid"] != null) {
      queryParameters["ruleUid"] = requestParameters["ruleUid"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/alert-rules/export`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AlertingFileExportFromJSON(jsonValue));
  }
  /**
   * Export all alert rules in provisioning file format.
   */
  async routeGetAlertRulesExport(requestParameters = {}, initOverrides) {
    const response = await this.routeGetAlertRulesExportRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get all the contact points.
   */
  async routeGetContactpointsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["name"] != null) {
      queryParameters["name"] = requestParameters["name"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/contact-points`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(EmbeddedContactPointFromJSON));
  }
  /**
   * Get all the contact points.
   */
  async routeGetContactpoints(requestParameters = {}, initOverrides) {
    const response = await this.routeGetContactpointsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Export all contact points in provisioning file format.
   */
  async routeGetContactpointsExportRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["download"] != null) {
      queryParameters["download"] = requestParameters["download"];
    }
    if (requestParameters["format"] != null) {
      queryParameters["format"] = requestParameters["format"];
    }
    if (requestParameters["decrypt"] != null) {
      queryParameters["decrypt"] = requestParameters["decrypt"];
    }
    if (requestParameters["name"] != null) {
      queryParameters["name"] = requestParameters["name"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/contact-points/export`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AlertingFileExportFromJSON(jsonValue));
  }
  /**
   * Export all contact points in provisioning file format.
   */
  async routeGetContactpointsExport(requestParameters = {}, initOverrides) {
    const response = await this.routeGetContactpointsExportRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get a mute timing.
   */
  async routeGetMuteTimingRaw(requestParameters, initOverrides) {
    if (requestParameters["name"] == null) {
      throw new RequiredError(
        "name",
        'Required parameter "name" was null or undefined when calling routeGetMuteTiming().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/mute-timings/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters["name"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => MuteTimeIntervalFromJSON(jsonValue));
  }
  /**
   * Get a mute timing.
   */
  async routeGetMuteTiming(requestParameters, initOverrides) {
    const response = await this.routeGetMuteTimingRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get all the mute timings.
   */
  async routeGetMuteTimingsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/mute-timings`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(MuteTimeIntervalFromJSON));
  }
  /**
   * Get all the mute timings.
   */
  async routeGetMuteTimings(initOverrides) {
    const response = await this.routeGetMuteTimingsRaw(initOverrides);
    return await response.value();
  }
  /**
   * Get the notification policy tree.
   */
  async routeGetPolicyTreeRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/policies`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RouteFromJSON(jsonValue));
  }
  /**
   * Get the notification policy tree.
   */
  async routeGetPolicyTree(initOverrides) {
    const response = await this.routeGetPolicyTreeRaw(initOverrides);
    return await response.value();
  }
  /**
   * Export the notification policy tree in provisioning file format.
   */
  async routeGetPolicyTreeExportRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/policies/export`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AlertingFileExportFromJSON(jsonValue));
  }
  /**
   * Export the notification policy tree in provisioning file format.
   */
  async routeGetPolicyTreeExport(initOverrides) {
    const response = await this.routeGetPolicyTreeExportRaw(initOverrides);
    return await response.value();
  }
  /**
   * Get a notification template.
   */
  async routeGetTemplateRaw(requestParameters, initOverrides) {
    if (requestParameters["name"] == null) {
      throw new RequiredError(
        "name",
        'Required parameter "name" was null or undefined when calling routeGetTemplate().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/templates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters["name"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => NotificationTemplateFromJSON(jsonValue));
  }
  /**
   * Get a notification template.
   */
  async routeGetTemplate(requestParameters, initOverrides) {
    const response = await this.routeGetTemplateRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get all notification templates.
   */
  async routeGetTemplatesRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/templates`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(NotificationTemplateFromJSON));
  }
  /**
   * Get all notification templates.
   */
  async routeGetTemplates(initOverrides) {
    const response = await this.routeGetTemplatesRaw(initOverrides);
    return await response.value();
  }
  /**
   * Create a new alert rule.
   */
  async routePostAlertRuleRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (requestParameters["xDisableProvenance"] != null) {
      headerParameters["X-Disable-Provenance"] = String(requestParameters["xDisableProvenance"]);
    }
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/alert-rules`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ProvisionedAlertRuleToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ProvisionedAlertRuleFromJSON(jsonValue));
  }
  /**
   * Create a new alert rule.
   */
  async routePostAlertRule(requestParameters = {}, initOverrides) {
    const response = await this.routePostAlertRuleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Create a contact point.
   */
  async routePostContactpointsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (requestParameters["xDisableProvenance"] != null) {
      headerParameters["X-Disable-Provenance"] = String(requestParameters["xDisableProvenance"]);
    }
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/contact-points`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: EmbeddedContactPointToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => EmbeddedContactPointFromJSON(jsonValue));
  }
  /**
   * Create a contact point.
   */
  async routePostContactpoints(requestParameters = {}, initOverrides) {
    const response = await this.routePostContactpointsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Create a new mute timing.
   */
  async routePostMuteTimingRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (requestParameters["xDisableProvenance"] != null) {
      headerParameters["X-Disable-Provenance"] = String(requestParameters["xDisableProvenance"]);
    }
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/mute-timings`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: MuteTimeIntervalToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => MuteTimeIntervalFromJSON(jsonValue));
  }
  /**
   * Create a new mute timing.
   */
  async routePostMuteTiming(requestParameters = {}, initOverrides) {
    const response = await this.routePostMuteTimingRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update an existing alert rule.
   */
  async routePutAlertRuleRaw(requestParameters, initOverrides) {
    if (requestParameters["uID"] == null) {
      throw new RequiredError(
        "uID",
        'Required parameter "uID" was null or undefined when calling routePutAlertRule().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (requestParameters["xDisableProvenance"] != null) {
      headerParameters["X-Disable-Provenance"] = String(requestParameters["xDisableProvenance"]);
    }
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/alert-rules/{UID}`.replace(`{${"UID"}}`, encodeURIComponent(String(requestParameters["uID"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: ProvisionedAlertRuleToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ProvisionedAlertRuleFromJSON(jsonValue));
  }
  /**
   * Update an existing alert rule.
   */
  async routePutAlertRule(requestParameters, initOverrides) {
    const response = await this.routePutAlertRuleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Create or update alert rule group.
   */
  async routePutAlertRuleGroupRaw(requestParameters, initOverrides) {
    if (requestParameters["folderUID"] == null) {
      throw new RequiredError(
        "folderUID",
        'Required parameter "folderUID" was null or undefined when calling routePutAlertRuleGroup().'
      );
    }
    if (requestParameters["group"] == null) {
      throw new RequiredError(
        "group",
        'Required parameter "group" was null or undefined when calling routePutAlertRuleGroup().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (requestParameters["xDisableProvenance"] != null) {
      headerParameters["X-Disable-Provenance"] = String(requestParameters["xDisableProvenance"]);
    }
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}`.replace(`{${"FolderUID"}}`, encodeURIComponent(String(requestParameters["folderUID"]))).replace(`{${"Group"}}`, encodeURIComponent(String(requestParameters["group"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: AlertRuleGroupToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => AlertRuleGroupFromJSON(jsonValue));
  }
  /**
   * Create or update alert rule group.
   */
  async routePutAlertRuleGroup(requestParameters, initOverrides) {
    const response = await this.routePutAlertRuleGroupRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update an existing contact point.
   */
  async routePutContactpointRaw(requestParameters, initOverrides) {
    if (requestParameters["uID"] == null) {
      throw new RequiredError(
        "uID",
        'Required parameter "uID" was null or undefined when calling routePutContactpoint().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (requestParameters["xDisableProvenance"] != null) {
      headerParameters["X-Disable-Provenance"] = String(requestParameters["xDisableProvenance"]);
    }
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/contact-points/{UID}`.replace(`{${"UID"}}`, encodeURIComponent(String(requestParameters["uID"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: EmbeddedContactPointToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response);
  }
  /**
   * Update an existing contact point.
   */
  async routePutContactpoint(requestParameters, initOverrides) {
    const response = await this.routePutContactpointRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Replace an existing mute timing.
   */
  async routePutMuteTimingRaw(requestParameters, initOverrides) {
    if (requestParameters["name"] == null) {
      throw new RequiredError(
        "name",
        'Required parameter "name" was null or undefined when calling routePutMuteTiming().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (requestParameters["xDisableProvenance"] != null) {
      headerParameters["X-Disable-Provenance"] = String(requestParameters["xDisableProvenance"]);
    }
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/mute-timings/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters["name"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: MuteTimeIntervalToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => MuteTimeIntervalFromJSON(jsonValue));
  }
  /**
   * Replace an existing mute timing.
   */
  async routePutMuteTiming(requestParameters, initOverrides) {
    const response = await this.routePutMuteTimingRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Sets the notification policy tree.
   */
  async routePutPolicyTreeRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (requestParameters["xDisableProvenance"] != null) {
      headerParameters["X-Disable-Provenance"] = String(requestParameters["xDisableProvenance"]);
    }
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/policies`,
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: RouteToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response);
  }
  /**
   * Sets the notification policy tree.
   */
  async routePutPolicyTree(requestParameters = {}, initOverrides) {
    const response = await this.routePutPolicyTreeRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Updates an existing notification template.
   */
  async routePutTemplateRaw(requestParameters, initOverrides) {
    if (requestParameters["name"] == null) {
      throw new RequiredError(
        "name",
        'Required parameter "name" was null or undefined when calling routePutTemplate().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (requestParameters["xDisableProvenance"] != null) {
      headerParameters["X-Disable-Provenance"] = String(requestParameters["xDisableProvenance"]);
    }
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/templates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters["name"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: NotificationTemplateContentToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => NotificationTemplateFromJSON(jsonValue));
  }
  /**
   * Updates an existing notification template.
   */
  async routePutTemplate(requestParameters, initOverrides) {
    const response = await this.routePutTemplateRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Clears the notification policy tree.
   */
  async routeResetPolicyTreeRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/provisioning/policies`,
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response);
  }
  /**
   * Clears the notification policy tree.
   */
  async routeResetPolicyTree(initOverrides) {
    const response = await this.routeResetPolicyTreeRaw(initOverrides);
    return await response.value();
  }
};
var RouteExportMuteTimingFormatEnum = {
  Yaml: "yaml",
  Json: "json",
  Hcl: "hcl"
};
var RouteExportMuteTimingsFormatEnum = {
  Yaml: "yaml",
  Json: "json",
  Hcl: "hcl"
};
var RouteGetAlertRuleExportFormatEnum = {
  Yaml: "yaml",
  Json: "json",
  Hcl: "hcl"
};
var RouteGetAlertRuleGroupExportFormatEnum = {
  Yaml: "yaml",
  Json: "json",
  Hcl: "hcl"
};
var RouteGetAlertRulesExportFormatEnum = {
  Yaml: "yaml",
  Json: "json",
  Hcl: "hcl"
};
var RouteGetContactpointsExportFormatEnum = {
  Yaml: "yaml",
  Json: "json",
  Hcl: "hcl"
};

// apis/QueryHistoryApi.ts
var QueryHistoryApi = class extends BaseAPI {
  /**
   * Adds new query to query history.
   * Add query to query history.
   */
  async createQueryRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createQuery().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/query-history`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateQueryInQueryHistoryCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => QueryHistoryResponseFromJSON(jsonValue));
  }
  /**
   * Adds new query to query history.
   * Add query to query history.
   */
  async createQuery(requestParameters, initOverrides) {
    const response = await this.createQueryRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Deletes an existing query in query history as specified by the UID. This operation cannot be reverted.
   * Delete query in query history.
   */
  async deleteQueryRaw(requestParameters, initOverrides) {
    if (requestParameters["queryHistoryUid"] == null) {
      throw new RequiredError(
        "queryHistoryUid",
        'Required parameter "queryHistoryUid" was null or undefined when calling deleteQuery().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/query-history/{query_history_uid}`.replace(`{${"query_history_uid"}}`, encodeURIComponent(String(requestParameters["queryHistoryUid"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => QueryHistoryDeleteQueryResponseFromJSON(jsonValue));
  }
  /**
   * Deletes an existing query in query history as specified by the UID. This operation cannot be reverted.
   * Delete query in query history.
   */
  async deleteQuery(requestParameters, initOverrides) {
    const response = await this.deleteQueryRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Updates comment for query in query history as specified by the UID.
   * Update comment for query in query history.
   */
  async patchQueryCommentRaw(requestParameters, initOverrides) {
    if (requestParameters["queryHistoryUid"] == null) {
      throw new RequiredError(
        "queryHistoryUid",
        'Required parameter "queryHistoryUid" was null or undefined when calling patchQueryComment().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling patchQueryComment().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/query-history/{query_history_uid}`.replace(`{${"query_history_uid"}}`, encodeURIComponent(String(requestParameters["queryHistoryUid"]))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: PatchQueryCommentInQueryHistoryCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => QueryHistoryResponseFromJSON(jsonValue));
  }
  /**
   * Updates comment for query in query history as specified by the UID.
   * Update comment for query in query history.
   */
  async patchQueryComment(requestParameters, initOverrides) {
    const response = await this.patchQueryCommentRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Returns a list of queries in the query history that matches the search criteria. Query history search supports pagination. Use the `limit` parameter to control the maximum number of queries returned; the default limit is 100. You can also use the `page` query parameter to fetch queries from any page other than the first one.
   * Query history search.
   */
  async searchQueriesRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["datasourceUid"] != null) {
      queryParameters["datasourceUid"] = requestParameters["datasourceUid"];
    }
    if (requestParameters["searchString"] != null) {
      queryParameters["searchString"] = requestParameters["searchString"];
    }
    if (requestParameters["onlyStarred"] != null) {
      queryParameters["onlyStarred"] = requestParameters["onlyStarred"];
    }
    if (requestParameters["sort"] != null) {
      queryParameters["sort"] = requestParameters["sort"];
    }
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }
    if (requestParameters["from"] != null) {
      queryParameters["from"] = requestParameters["from"];
    }
    if (requestParameters["to"] != null) {
      queryParameters["to"] = requestParameters["to"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/query-history`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => QueryHistorySearchResponseFromJSON(jsonValue));
  }
  /**
   * Returns a list of queries in the query history that matches the search criteria. Query history search supports pagination. Use the `limit` parameter to control the maximum number of queries returned; the default limit is 100. You can also use the `page` query parameter to fetch queries from any page other than the first one.
   * Query history search.
   */
  async searchQueries(requestParameters = {}, initOverrides) {
    const response = await this.searchQueriesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Adds star to query in query history as specified by the UID.
   * Add star to query in query history.
   */
  async starQueryRaw(requestParameters, initOverrides) {
    if (requestParameters["queryHistoryUid"] == null) {
      throw new RequiredError(
        "queryHistoryUid",
        'Required parameter "queryHistoryUid" was null or undefined when calling starQuery().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/query-history/star/{query_history_uid}`.replace(`{${"query_history_uid"}}`, encodeURIComponent(String(requestParameters["queryHistoryUid"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => QueryHistoryResponseFromJSON(jsonValue));
  }
  /**
   * Adds star to query in query history as specified by the UID.
   * Add star to query in query history.
   */
  async starQuery(requestParameters, initOverrides) {
    const response = await this.starQueryRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Removes star from query in query history as specified by the UID.
   * Remove star to query in query history.
   */
  async unstarQueryRaw(requestParameters, initOverrides) {
    if (requestParameters["queryHistoryUid"] == null) {
      throw new RequiredError(
        "queryHistoryUid",
        'Required parameter "queryHistoryUid" was null or undefined when calling unstarQuery().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/query-history/star/{query_history_uid}`.replace(`{${"query_history_uid"}}`, encodeURIComponent(String(requestParameters["queryHistoryUid"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => QueryHistoryResponseFromJSON(jsonValue));
  }
  /**
   * Removes star from query in query history as specified by the UID.
   * Remove star to query in query history.
   */
  async unstarQuery(requestParameters, initOverrides) {
    const response = await this.unstarQueryRaw(requestParameters, initOverrides);
    return await response.value();
  }
};
var SearchQueriesSortEnum = {
  Desc: "time-desc",
  Asc: "time-asc"
};

// apis/RecordingRulesApi.ts
var RecordingRulesApi = class extends BaseAPI {
  /**
   * Create a recording rule that is then registered and started.
   */
  async createRecordingRuleRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createRecordingRule().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/recording-rules`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RecordingRuleJSONToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RecordingRuleJSONFromJSON(jsonValue));
  }
  /**
   * Create a recording rule that is then registered and started.
   */
  async createRecordingRule(requestParameters, initOverrides) {
    const response = await this.createRecordingRuleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * It returns a 422 if there is not an existing prometheus data source configured.
   * Create a remote write target.
   */
  async createRecordingRuleWriteTargetRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createRecordingRuleWriteTarget().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/recording-rules/writer`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: PrometheusRemoteWriteTargetJSONToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PrometheusRemoteWriteTargetJSONFromJSON(jsonValue));
  }
  /**
   * It returns a 422 if there is not an existing prometheus data source configured.
   * Create a remote write target.
   */
  async createRecordingRuleWriteTarget(requestParameters, initOverrides) {
    const response = await this.createRecordingRuleWriteTargetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Delete removes the rule from the registry and stops it.
   */
  async deleteRecordingRuleRaw(requestParameters, initOverrides) {
    if (requestParameters["recordingRuleID"] == null) {
      throw new RequiredError(
        "recordingRuleID",
        'Required parameter "recordingRuleID" was null or undefined when calling deleteRecordingRule().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/recording-rules/{recordingRuleID}`.replace(`{${"recordingRuleID"}}`, encodeURIComponent(String(requestParameters["recordingRuleID"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Delete removes the rule from the registry and stops it.
   */
  async deleteRecordingRule(requestParameters, initOverrides) {
    const response = await this.deleteRecordingRuleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Delete the remote write target.
   */
  async deleteRecordingRuleWriteTargetRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/recording-rules/writer`,
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Delete the remote write target.
   */
  async deleteRecordingRuleWriteTarget(initOverrides) {
    const response = await this.deleteRecordingRuleWriteTargetRaw(initOverrides);
    return await response.value();
  }
  /**
   * Return the prometheus remote write target.
   */
  async getRecordingRuleWriteTargetRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/recording-rules/writer`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PrometheusRemoteWriteTargetJSONFromJSON(jsonValue));
  }
  /**
   * Return the prometheus remote write target.
   */
  async getRecordingRuleWriteTarget(initOverrides) {
    const response = await this.getRecordingRuleWriteTargetRaw(initOverrides);
    return await response.value();
  }
  /**
   * Lists all rules in the database: active or deleted.
   */
  async listRecordingRulesRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/recording-rules`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(RecordingRuleJSONFromJSON));
  }
  /**
   * Lists all rules in the database: active or deleted.
   */
  async listRecordingRules(initOverrides) {
    const response = await this.listRecordingRulesRaw(initOverrides);
    return await response.value();
  }
  /**
   * Test a recording rule.
   */
  async testCreateRecordingRuleRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling testCreateRecordingRule().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/recording-rules/test`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RecordingRuleJSONToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Test a recording rule.
   */
  async testCreateRecordingRule(requestParameters, initOverrides) {
    const response = await this.testCreateRecordingRuleRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update the active status of a rule.
   */
  async updateRecordingRuleRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateRecordingRule().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/recording-rules`,
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: RecordingRuleJSONToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RecordingRuleJSONFromJSON(jsonValue));
  }
  /**
   * Update the active status of a rule.
   */
  async updateRecordingRule(requestParameters, initOverrides) {
    const response = await this.updateRecordingRuleRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/ReportsApi.ts
var ReportsApi = class extends BaseAPI {
  /**
   * Available to org admins only and with a valid license.  You need to have a permission with action `reports.admin:create`.
   * Create a report.
   */
  async createReportRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createReport().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateOrUpdateReportConfigToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CreateReport200ResponseFromJSON(jsonValue));
  }
  /**
   * Available to org admins only and with a valid license.  You need to have a permission with action `reports.admin:create`.
   * Create a report.
   */
  async createReport(requestParameters, initOverrides) {
    const response = await this.createReportRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.delete` with scope `reports:id:<report ID>`.
   * Delete a report.
   */
  async deleteReportRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling deleteReport().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.delete` with scope `reports:id:<report ID>`.
   * Delete a report.
   */
  async deleteReport(requestParameters, initOverrides) {
    const response = await this.deleteReportRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:id:<report ID>`.
   * Get a report.
   */
  async getReportRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling getReport().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ReportFromJSON(jsonValue));
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:id:<report ID>`.
   * Get a report.
   */
  async getReport(requestParameters, initOverrides) {
    const response = await this.getReportRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`x.
   * Get settings.
   */
  async getReportSettingsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports/settings`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ReportSettingsFromJSON(jsonValue));
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`x.
   * Get settings.
   */
  async getReportSettings(initOverrides) {
    const response = await this.getReportSettingsRaw(initOverrides);
    return await response.value();
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:*`.
   * List reports.
   */
  async getReportsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(ReportFromJSON));
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:*`.
   * List reports.
   */
  async getReports(initOverrides) {
    const response = await this.getReportsRaw(initOverrides);
    return await response.value();
  }
  /**
   * Available to all users and with a valid license.
   * Render report for multiple dashboards.
   */
  async renderReportPDFsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["dashboardID"] != null) {
      queryParameters["dashboardID"] = requestParameters["dashboardID"];
    }
    if (requestParameters["orientation"] != null) {
      queryParameters["orientation"] = requestParameters["orientation"];
    }
    if (requestParameters["layout"] != null) {
      queryParameters["layout"] = requestParameters["layout"];
    }
    if (requestParameters["title"] != null) {
      queryParameters["title"] = requestParameters["title"];
    }
    if (requestParameters["scaleFactor"] != null) {
      queryParameters["scaleFactor"] = requestParameters["scaleFactor"];
    }
    if (requestParameters["includeTables"] != null) {
      queryParameters["includeTables"] = requestParameters["includeTables"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports/render/pdfs`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response);
  }
  /**
   * Available to all users and with a valid license.
   * Render report for multiple dashboards.
   */
  async renderReportPDFs(requestParameters = {}, initOverrides) {
    const response = await this.renderReportPDFsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:write`xx.
   * Save settings.
   */
  async saveReportSettingsRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling saveReportSettings().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports/settings`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ReportSettingsToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:write`xx.
   * Save settings.
   */
  async saveReportSettings(requestParameters, initOverrides) {
    const response = await this.saveReportSettingsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Generate and send a report. This API waits for the report to be generated before returning. We recommend that you set the client’s timeout to at least 60 seconds. Available to org admins only and with a valid license.  Only available in Grafana Enterprise v7.0+. This API endpoint is experimental and may be deprecated in a future release. On deprecation, a migration strategy will be provided and the endpoint will remain functional until the next major release of Grafana.  You need to have a permission with action `reports:send`.
   * Send a report.
   */
  async sendReportRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling sendReport().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports/email`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ReportEmailToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Generate and send a report. This API waits for the report to be generated before returning. We recommend that you set the client’s timeout to at least 60 seconds. Available to org admins only and with a valid license.  Only available in Grafana Enterprise v7.0+. This API endpoint is experimental and may be deprecated in a future release. On deprecation, a migration strategy will be provided and the endpoint will remain functional until the next major release of Grafana.  You need to have a permission with action `reports:send`.
   * Send a report.
   */
  async sendReport(requestParameters, initOverrides) {
    const response = await this.sendReportRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Available to org admins only and with a valid license.  You need to have a permission with action `reports:send`.
   * Send test report via email.
   */
  async sendTestEmailRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling sendTestEmail().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports/test-email`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateOrUpdateReportConfigToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Available to org admins only and with a valid license.  You need to have a permission with action `reports:send`.
   * Send test report via email.
   */
  async sendTestEmail(requestParameters, initOverrides) {
    const response = await this.sendTestEmailRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.admin:write` with scope `reports:id:<report ID>`.
   * Update a report.
   */
  async updateReportRaw(requestParameters, initOverrides) {
    if (requestParameters["id"] == null) {
      throw new RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling updateReport().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateReport().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/reports/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters["id"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: CreateOrUpdateReportConfigToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.admin:write` with scope `reports:id:<report ID>`.
   * Update a report.
   */
  async updateReport(requestParameters, initOverrides) {
    const response = await this.updateReportRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/SamlApi.ts
var SamlApi = class extends BaseAPI {
  /**
   * It exposes the SP (Grafana\'s) metadata for the IdP\'s consumption.
   */
  async getMetadataRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/saml/metadata`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response);
  }
  /**
   * It exposes the SP (Grafana\'s) metadata for the IdP\'s consumption.
   */
  async getMetadata(initOverrides) {
    const response = await this.getMetadataRaw(initOverrides);
    return await response.value();
  }
  /**
   * GetLogout initiates single logout process.
   */
  async getSAMLLogoutRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/logout/saml`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * GetLogout initiates single logout process.
   */
  async getSAMLLogout(initOverrides) {
    await this.getSAMLLogoutRaw(initOverrides);
  }
  /**
   * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
   * It performs Single Logout (SLO) callback.
   */
  async getSLORaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/saml/slo`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
   * It performs Single Logout (SLO) callback.
   */
  async getSLO(initOverrides) {
    await this.getSLORaw(initOverrides);
  }
  /**
   * It performs Assertion Consumer Service (ACS).
   */
  async postACSRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["relayState"] != null) {
      queryParameters["RelayState"] = requestParameters["relayState"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/saml/acs`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * It performs Assertion Consumer Service (ACS).
   */
  async postACS(requestParameters = {}, initOverrides) {
    await this.postACSRaw(requestParameters, initOverrides);
  }
  /**
   * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
   * It performs Single Logout (SLO) callback.
   */
  async postSLORaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["sAMLRequest"] != null) {
      queryParameters["SAMLRequest"] = requestParameters["sAMLRequest"];
    }
    if (requestParameters["sAMLResponse"] != null) {
      queryParameters["SAMLResponse"] = requestParameters["sAMLResponse"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/saml/slo`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
   * It performs Single Logout (SLO) callback.
   */
  async postSLO(requestParameters = {}, initOverrides) {
    await this.postSLORaw(requestParameters, initOverrides);
  }
};

// apis/SearchApi.ts
var SearchApi = class extends BaseAPI {
  /**
   * List search sorting options.
   */
  async listSortOptionsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/search/sorting`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListSortOptions200ResponseFromJSON(jsonValue));
  }
  /**
   * List search sorting options.
   */
  async listSortOptions(initOverrides) {
    const response = await this.listSortOptionsRaw(initOverrides);
    return await response.value();
  }
  /**
   */
  async searchRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["query"] != null) {
      queryParameters["query"] = requestParameters["query"];
    }
    if (requestParameters["tag"] != null) {
      queryParameters["tag"] = requestParameters["tag"];
    }
    if (requestParameters["type"] != null) {
      queryParameters["type"] = requestParameters["type"];
    }
    if (requestParameters["dashboardIds"] != null) {
      queryParameters["dashboardIds"] = requestParameters["dashboardIds"].join(COLLECTION_FORMATS["csv"]);
    }
    if (requestParameters["dashboardUIDs"] != null) {
      queryParameters["dashboardUIDs"] = requestParameters["dashboardUIDs"].join(COLLECTION_FORMATS["csv"]);
    }
    if (requestParameters["folderIds"] != null) {
      queryParameters["folderIds"] = requestParameters["folderIds"].join(COLLECTION_FORMATS["csv"]);
    }
    if (requestParameters["folderUIDs"] != null) {
      queryParameters["folderUIDs"] = requestParameters["folderUIDs"].join(COLLECTION_FORMATS["csv"]);
    }
    if (requestParameters["starred"] != null) {
      queryParameters["starred"] = requestParameters["starred"];
    }
    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    if (requestParameters["permission"] != null) {
      queryParameters["permission"] = requestParameters["permission"];
    }
    if (requestParameters["sort"] != null) {
      queryParameters["sort"] = requestParameters["sort"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/search`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(HitFromJSON));
  }
  /**
   */
  async search(requestParameters = {}, initOverrides) {
    const response = await this.searchRaw(requestParameters, initOverrides);
    return await response.value();
  }
};
var SearchTypeEnum = {
  Folder: "dash-folder",
  Db: "dash-db"
};
var SearchPermissionEnum = {
  Edit: "Edit",
  View: "View"
};
var SearchSortEnum = {
  Asc: "alpha-asc",
  Desc: "alpha-desc"
};

// apis/ServiceAccountsApi.ts
var ServiceAccountsApi = class extends BaseAPI {
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:*`  Requires basic authentication and that the authenticated user is a Grafana Admin.
   * Create service account
   */
  async createServiceAccountRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/serviceaccounts`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateServiceAccountFormToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ServiceAccountDTOFromJSON(jsonValue));
  }
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:*`  Requires basic authentication and that the authenticated user is a Grafana Admin.
   * Create service account
   */
  async createServiceAccount(requestParameters = {}, initOverrides) {
    const response = await this.createServiceAccountRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
   * CreateNewToken adds a token to a service account
   */
  async createTokenRaw(requestParameters, initOverrides) {
    if (requestParameters["serviceAccountId"] == null) {
      throw new RequiredError(
        "serviceAccountId",
        'Required parameter "serviceAccountId" was null or undefined when calling createToken().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/serviceaccounts/{serviceAccountId}/tokens`.replace(`{${"serviceAccountId"}}`, encodeURIComponent(String(requestParameters["serviceAccountId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AddServiceAccountTokenCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => NewApiKeyResultFromJSON(jsonValue));
  }
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
   * CreateNewToken adds a token to a service account
   */
  async createToken(requestParameters, initOverrides) {
    const response = await this.createTokenRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:delete` scope: `serviceaccounts:id:1` (single service account)
   * Delete service account
   */
  async deleteServiceAccountRaw(requestParameters, initOverrides) {
    if (requestParameters["serviceAccountId"] == null) {
      throw new RequiredError(
        "serviceAccountId",
        'Required parameter "serviceAccountId" was null or undefined when calling deleteServiceAccount().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/serviceaccounts/{serviceAccountId}`.replace(`{${"serviceAccountId"}}`, encodeURIComponent(String(requestParameters["serviceAccountId"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:delete` scope: `serviceaccounts:id:1` (single service account)
   * Delete service account
   */
  async deleteServiceAccount(requestParameters, initOverrides) {
    const response = await this.deleteServiceAccountRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)  Requires basic authentication and that the authenticated user is a Grafana Admin.
   * DeleteToken deletes service account tokens
   */
  async deleteTokenRaw(requestParameters, initOverrides) {
    if (requestParameters["tokenId"] == null) {
      throw new RequiredError(
        "tokenId",
        'Required parameter "tokenId" was null or undefined when calling deleteToken().'
      );
    }
    if (requestParameters["serviceAccountId"] == null) {
      throw new RequiredError(
        "serviceAccountId",
        'Required parameter "serviceAccountId" was null or undefined when calling deleteToken().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/serviceaccounts/{serviceAccountId}/tokens/{tokenId}`.replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters["tokenId"]))).replace(`{${"serviceAccountId"}}`, encodeURIComponent(String(requestParameters["serviceAccountId"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)  Requires basic authentication and that the authenticated user is a Grafana Admin.
   * DeleteToken deletes service account tokens
   */
  async deleteToken(requestParameters, initOverrides) {
    const response = await this.deleteTokenRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `global:serviceaccounts:id:1` (single service account)  Requires basic authentication and that the authenticated user is a Grafana Admin.
   * Get service account tokens
   */
  async listTokensRaw(requestParameters, initOverrides) {
    if (requestParameters["serviceAccountId"] == null) {
      throw new RequiredError(
        "serviceAccountId",
        'Required parameter "serviceAccountId" was null or undefined when calling listTokens().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/serviceaccounts/{serviceAccountId}/tokens`.replace(`{${"serviceAccountId"}}`, encodeURIComponent(String(requestParameters["serviceAccountId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenDTOFromJSON));
  }
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `global:serviceaccounts:id:1` (single service account)  Requires basic authentication and that the authenticated user is a Grafana Admin.
   * Get service account tokens
   */
  async listTokens(requestParameters, initOverrides) {
    const response = await this.listTokensRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `serviceaccounts:id:1` (single service account)
   * Get single serviceaccount by Id
   */
  async retrieveServiceAccountRaw(requestParameters, initOverrides) {
    if (requestParameters["serviceAccountId"] == null) {
      throw new RequiredError(
        "serviceAccountId",
        'Required parameter "serviceAccountId" was null or undefined when calling retrieveServiceAccount().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/serviceaccounts/{serviceAccountId}`.replace(`{${"serviceAccountId"}}`, encodeURIComponent(String(requestParameters["serviceAccountId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ServiceAccountDTOFromJSON(jsonValue));
  }
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `serviceaccounts:id:1` (single service account)
   * Get single serviceaccount by Id
   */
  async retrieveServiceAccount(requestParameters, initOverrides) {
    const response = await this.retrieveServiceAccountRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `serviceaccounts:*`
   * Search service accounts with paging
   */
  async searchOrgServiceAccountsWithPagingRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["disabled"] != null) {
      queryParameters["Disabled"] = requestParameters["disabled"];
    }
    if (requestParameters["expiredTokens"] != null) {
      queryParameters["expiredTokens"] = requestParameters["expiredTokens"];
    }
    if (requestParameters["query"] != null) {
      queryParameters["query"] = requestParameters["query"];
    }
    if (requestParameters["perpage"] != null) {
      queryParameters["perpage"] = requestParameters["perpage"];
    }
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/serviceaccounts/search`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchOrgServiceAccountsResultFromJSON(jsonValue));
  }
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `serviceaccounts:*`
   * Search service accounts with paging
   */
  async searchOrgServiceAccountsWithPaging(requestParameters = {}, initOverrides) {
    const response = await this.searchOrgServiceAccountsWithPagingRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
   * Update service account
   */
  async updateServiceAccountRaw(requestParameters, initOverrides) {
    if (requestParameters["serviceAccountId"] == null) {
      throw new RequiredError(
        "serviceAccountId",
        'Required parameter "serviceAccountId" was null or undefined when calling updateServiceAccount().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/serviceaccounts/{serviceAccountId}`.replace(`{${"serviceAccountId"}}`, encodeURIComponent(String(requestParameters["serviceAccountId"]))),
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateServiceAccountFormToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UpdateServiceAccount200ResponseFromJSON(jsonValue));
  }
  /**
   * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
   * Update service account
   */
  async updateServiceAccount(requestParameters, initOverrides) {
    const response = await this.updateServiceAccountRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/SignedInUserApi.ts
var SignedInUserApi = class extends BaseAPI {
  /**
   * Changes the password for the user.
   * Change Password.
   */
  async changeUserPasswordRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling changeUserPassword().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user/password`,
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: ChangeUserPasswordCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Changes the password for the user.
   * Change Password.
   */
  async changeUserPassword(requestParameters, initOverrides) {
    const response = await this.changeUserPasswordRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Clear user help flag.
   */
  async clearHelpFlagsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user/helpflags/clear`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ClearHelpFlags200ResponseFromJSON(jsonValue));
  }
  /**
   * Clear user help flag.
   */
  async clearHelpFlags(initOverrides) {
    const response = await this.clearHelpFlagsRaw(initOverrides);
    return await response.value();
  }
  /**
   * Get (current authenticated user)
   */
  async getSignedInUserRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UserProfileDTOFromJSON(jsonValue));
  }
  /**
   * Get (current authenticated user)
   */
  async getSignedInUser(initOverrides) {
    const response = await this.getSignedInUserRaw(initOverrides);
    return await response.value();
  }
  /**
   * Return a list of all organizations of the current user.
   * Organizations of the actual User.
   */
  async getSignedInUserOrgListRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user/orgs`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(UserOrgDTOFromJSON));
  }
  /**
   * Return a list of all organizations of the current user.
   * Organizations of the actual User.
   */
  async getSignedInUserOrgList(initOverrides) {
    const response = await this.getSignedInUserOrgListRaw(initOverrides);
    return await response.value();
  }
  /**
   * Return a list of all teams that the current user is member of.
   * Teams that the actual User is member of.
   */
  async getSignedInUserTeamListRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user/teams`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(TeamDTOFromJSON));
  }
  /**
   * Return a list of all teams that the current user is member of.
   * Teams that the actual User is member of.
   */
  async getSignedInUserTeamList(initOverrides) {
    const response = await this.getSignedInUserTeamListRaw(initOverrides);
    return await response.value();
  }
  /**
   * Return a list of all auth tokens (devices) that the actual user currently have logged in from.
   * Auth tokens of the actual User.
   */
  async getUserAuthTokensRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user/auth-tokens`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(UserTokenFromJSON));
  }
  /**
   * Return a list of all auth tokens (devices) that the actual user currently have logged in from.
   * Auth tokens of the actual User.
   */
  async getUserAuthTokens(initOverrides) {
    const response = await this.getUserAuthTokensRaw(initOverrides);
    return await response.value();
  }
  /**
   * Fetch user quota.
   */
  async getUserQuotasRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user/quotas`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(QuotaDTOFromJSON));
  }
  /**
   * Fetch user quota.
   */
  async getUserQuotas(initOverrides) {
    const response = await this.getUserQuotasRaw(initOverrides);
    return await response.value();
  }
  /**
   * Revokes the given auth token (device) for the actual user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity.
   * Revoke an auth token of the actual User.
   */
  async revokeUserAuthTokenRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling revokeUserAuthToken().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user/revoke-auth-token`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RevokeAuthTokenCmdToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Revokes the given auth token (device) for the actual user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity.
   * Revoke an auth token of the actual User.
   */
  async revokeUserAuthToken(requestParameters, initOverrides) {
    const response = await this.revokeUserAuthTokenRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Set user help flag.
   */
  async setHelpFlagRaw(requestParameters, initOverrides) {
    if (requestParameters["flagId"] == null) {
      throw new RequiredError(
        "flagId",
        'Required parameter "flagId" was null or undefined when calling setHelpFlag().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user/helpflags/{flag_id}`.replace(`{${"flag_id"}}`, encodeURIComponent(String(requestParameters["flagId"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ClearHelpFlags200ResponseFromJSON(jsonValue));
  }
  /**
   * Set user help flag.
   */
  async setHelpFlag(requestParameters, initOverrides) {
    const response = await this.setHelpFlagRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Stars the given Dashboard for the actual user.
   * Star a dashboard.
   * @deprecated
   */
  async starDashboardRaw(requestParameters, initOverrides) {
    if (requestParameters["dashboardId"] == null) {
      throw new RequiredError(
        "dashboardId",
        'Required parameter "dashboardId" was null or undefined when calling starDashboard().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user/stars/dashboard/{dashboard_id}`.replace(`{${"dashboard_id"}}`, encodeURIComponent(String(requestParameters["dashboardId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Stars the given Dashboard for the actual user.
   * Star a dashboard.
   * @deprecated
   */
  async starDashboard(requestParameters, initOverrides) {
    const response = await this.starDashboardRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Stars the given Dashboard for the actual user.
   * Star a dashboard.
   */
  async starDashboardByUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["dashboardUid"] == null) {
      throw new RequiredError(
        "dashboardUid",
        'Required parameter "dashboardUid" was null or undefined when calling starDashboardByUID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user/stars/dashboard/uid/{dashboard_uid}`.replace(`{${"dashboard_uid"}}`, encodeURIComponent(String(requestParameters["dashboardUid"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Stars the given Dashboard for the actual user.
   * Star a dashboard.
   */
  async starDashboardByUID(requestParameters, initOverrides) {
    const response = await this.starDashboardByUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Deletes the starring of the given Dashboard for the actual user.
   * Unstar a dashboard.
   * @deprecated
   */
  async unstarDashboardRaw(requestParameters, initOverrides) {
    if (requestParameters["dashboardId"] == null) {
      throw new RequiredError(
        "dashboardId",
        'Required parameter "dashboardId" was null or undefined when calling unstarDashboard().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user/stars/dashboard/{dashboard_id}`.replace(`{${"dashboard_id"}}`, encodeURIComponent(String(requestParameters["dashboardId"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Deletes the starring of the given Dashboard for the actual user.
   * Unstar a dashboard.
   * @deprecated
   */
  async unstarDashboard(requestParameters, initOverrides) {
    const response = await this.unstarDashboardRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Deletes the starring of the given Dashboard for the actual user.
   * Unstar a dashboard.
   */
  async unstarDashboardByUIDRaw(requestParameters, initOverrides) {
    if (requestParameters["dashboardUid"] == null) {
      throw new RequiredError(
        "dashboardUid",
        'Required parameter "dashboardUid" was null or undefined when calling unstarDashboardByUID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user/stars/dashboard/uid/{dashboard_uid}`.replace(`{${"dashboard_uid"}}`, encodeURIComponent(String(requestParameters["dashboardUid"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Deletes the starring of the given Dashboard for the actual user.
   * Unstar a dashboard.
   */
  async unstarDashboardByUID(requestParameters, initOverrides) {
    const response = await this.unstarDashboardByUIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update signed in User.
   */
  async updateSignedInUserRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateSignedInUser().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user`,
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateUserCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Update signed in User.
   */
  async updateSignedInUser(requestParameters, initOverrides) {
    const response = await this.updateSignedInUserRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Switch user context to the given organization.
   * Switch user context for signed in user.
   */
  async userSetUsingOrgRaw(requestParameters, initOverrides) {
    if (requestParameters["orgId"] == null) {
      throw new RequiredError(
        "orgId",
        'Required parameter "orgId" was null or undefined when calling userSetUsingOrg().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user/using/{org_id}`.replace(`{${"org_id"}}`, encodeURIComponent(String(requestParameters["orgId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Switch user context to the given organization.
   * Switch user context for signed in user.
   */
  async userSetUsingOrg(requestParameters, initOverrides) {
    const response = await this.userSetUsingOrgRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/SigningKeysApi.ts
var SigningKeysApi = class extends BaseAPI {
  /**
   * Required permissions None
   * Get JSON Web Key Set (JWKS) with all the keys that can be used to verify tokens (public keys)
   */
  async retrieveJWKSRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/signing-keys/keys`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => RetrieveJWKS200ResponseFromJSON(jsonValue));
  }
  /**
   * Required permissions None
   * Get JSON Web Key Set (JWKS) with all the keys that can be used to verify tokens (public keys)
   */
  async retrieveJWKS(initOverrides) {
    const response = await this.retrieveJWKSRaw(initOverrides);
    return await response.value();
  }
};

// apis/SnapshotsApi.ts
var SnapshotsApi = class extends BaseAPI {
  /**
   * Snapshot public mode should be enabled or authentication is required.
   * When creating a snapshot using the API, you have to provide the full dashboard payload including the snapshot data. This endpoint is designed for the Grafana UI.
   */
  async createDashboardSnapshotRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createDashboardSnapshot().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/snapshots`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateDashboardSnapshotCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CreateDashboardSnapshot200ResponseFromJSON(jsonValue));
  }
  /**
   * Snapshot public mode should be enabled or authentication is required.
   * When creating a snapshot using the API, you have to provide the full dashboard payload including the snapshot data. This endpoint is designed for the Grafana UI.
   */
  async createDashboardSnapshot(requestParameters, initOverrides) {
    const response = await this.createDashboardSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Delete Snapshot by Key.
   */
  async deleteDashboardSnapshotRaw(requestParameters, initOverrides) {
    if (requestParameters["key"] == null) {
      throw new RequiredError(
        "key",
        'Required parameter "key" was null or undefined when calling deleteDashboardSnapshot().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/snapshots/{key}`.replace(`{${"key"}}`, encodeURIComponent(String(requestParameters["key"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Delete Snapshot by Key.
   */
  async deleteDashboardSnapshot(requestParameters, initOverrides) {
    const response = await this.deleteDashboardSnapshotRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Snapshot public mode should be enabled or authentication is required.
   * Delete Snapshot by deleteKey.
   */
  async deleteDashboardSnapshotByDeleteKeyRaw(requestParameters, initOverrides) {
    if (requestParameters["deleteKey"] == null) {
      throw new RequiredError(
        "deleteKey",
        'Required parameter "deleteKey" was null or undefined when calling deleteDashboardSnapshotByDeleteKey().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/snapshots-delete/{deleteKey}`.replace(`{${"deleteKey"}}`, encodeURIComponent(String(requestParameters["deleteKey"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Snapshot public mode should be enabled or authentication is required.
   * Delete Snapshot by deleteKey.
   */
  async deleteDashboardSnapshotByDeleteKey(requestParameters, initOverrides) {
    const response = await this.deleteDashboardSnapshotByDeleteKeyRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get Snapshot by Key.
   */
  async getDashboardSnapshotRaw(requestParameters, initOverrides) {
    if (requestParameters["key"] == null) {
      throw new RequiredError(
        "key",
        'Required parameter "key" was null or undefined when calling getDashboardSnapshot().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/snapshots/{key}`.replace(`{${"key"}}`, encodeURIComponent(String(requestParameters["key"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Get Snapshot by Key.
   */
  async getDashboardSnapshot(requestParameters, initOverrides) {
    await this.getDashboardSnapshotRaw(requestParameters, initOverrides);
  }
  /**
   * Get snapshot sharing settings.
   */
  async getSharingOptionsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/snapshot/shared-options`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => GetSharingOptions200ResponseFromJSON(jsonValue));
  }
  /**
   * Get snapshot sharing settings.
   */
  async getSharingOptions(initOverrides) {
    const response = await this.getSharingOptionsRaw(initOverrides);
    return await response.value();
  }
  /**
   * List snapshots.
   */
  async searchDashboardSnapshotsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["query"] != null) {
      queryParameters["query"] = requestParameters["query"];
    }
    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/dashboard/snapshots`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(DashboardSnapshotDTOFromJSON));
  }
  /**
   * List snapshots.
   */
  async searchDashboardSnapshots(requestParameters = {}, initOverrides) {
    const response = await this.searchDashboardSnapshotsRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/SsoSettingsApi.ts
var SsoSettingsApi = class extends BaseAPI {
  /**
   * You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`.
   * Get an SSO Settings entry by Key
   */
  async getProviderSettingsRaw(requestParameters, initOverrides) {
    if (requestParameters["key"] == null) {
      throw new RequiredError(
        "key",
        'Required parameter "key" was null or undefined when calling getProviderSettings().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/sso-settings/{key}`.replace(`{${"key"}}`, encodeURIComponent(String(requestParameters["key"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListAllProvidersSettings200ResponseInnerFromJSON(jsonValue));
  }
  /**
   * You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`.
   * Get an SSO Settings entry by Key
   */
  async getProviderSettings(requestParameters, initOverrides) {
    const response = await this.getProviderSettingsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`.
   * List all SSO Settings entries
   */
  async listAllProvidersSettingsRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/sso-settings`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(ListAllProvidersSettings200ResponseInnerFromJSON));
  }
  /**
   * You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`.
   * List all SSO Settings entries
   */
  async listAllProvidersSettings(initOverrides) {
    const response = await this.listAllProvidersSettingsRaw(initOverrides);
    return await response.value();
  }
  /**
   * Removes the SSO Settings for a provider.  You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
   * Remove SSO Settings
   */
  async removeProviderSettingsRaw(requestParameters, initOverrides) {
    if (requestParameters["key"] == null) {
      throw new RequiredError(
        "key",
        'Required parameter "key" was null or undefined when calling removeProviderSettings().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/sso-settings/{key}`.replace(`{${"key"}}`, encodeURIComponent(String(requestParameters["key"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Removes the SSO Settings for a provider.  You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
   * Remove SSO Settings
   */
  async removeProviderSettings(requestParameters, initOverrides) {
    const response = await this.removeProviderSettingsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Inserts or updates the SSO Settings for a provider.  You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
   * Update SSO Settings
   */
  async updateProviderSettingsRaw(requestParameters, initOverrides) {
    if (requestParameters["key"] == null) {
      throw new RequiredError(
        "key",
        'Required parameter "key" was null or undefined when calling updateProviderSettings().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateProviderSettings().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/v1/sso-settings/{key}`.replace(`{${"key"}}`, encodeURIComponent(String(requestParameters["key"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateProviderSettingsRequestToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Inserts or updates the SSO Settings for a provider.  You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
   * Update SSO Settings
   */
  async updateProviderSettings(requestParameters, initOverrides) {
    const response = await this.updateProviderSettingsRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/SyncTeamGroupsApi.ts
var SyncTeamGroupsApi = class extends BaseAPI {
  /**
   * Add External Group.
   */
  async addTeamGroupApiRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling addTeamGroupApi().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling addTeamGroupApi().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/teams/{teamId}/groups`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: TeamGroupMappingToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Add External Group.
   */
  async addTeamGroupApi(requestParameters, initOverrides) {
    const response = await this.addTeamGroupApiRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get External Groups.
   */
  async getTeamGroupsApiRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling getTeamGroupsApi().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/teams/{teamId}/groups`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(TeamGroupDTOFromJSON));
  }
  /**
   * Get External Groups.
   */
  async getTeamGroupsApi(requestParameters, initOverrides) {
    const response = await this.getTeamGroupsApiRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Remove External Group.
   */
  async removeTeamGroupApiQueryRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling removeTeamGroupApiQuery().'
      );
    }
    const queryParameters = {};
    if (requestParameters["groupId"] != null) {
      queryParameters["groupId"] = requestParameters["groupId"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/teams/{teamId}/groups`.replace(`{${"teamId"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Remove External Group.
   */
  async removeTeamGroupApiQuery(requestParameters, initOverrides) {
    const response = await this.removeTeamGroupApiQueryRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/TeamsApi.ts
var TeamsApi = class extends BaseAPI {
  /**
   * Add Team Member.
   */
  async addTeamMemberRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling addTeamMember().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling addTeamMember().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/teams/{team_id}/members`.replace(`{${"team_id"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: AddTeamMemberCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Add Team Member.
   */
  async addTeamMember(requestParameters, initOverrides) {
    const response = await this.addTeamMemberRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Add Team.
   */
  async createTeamRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling createTeam().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/teams`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateTeamCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CreateTeam200ResponseFromJSON(jsonValue));
  }
  /**
   * Add Team.
   */
  async createTeam(requestParameters, initOverrides) {
    const response = await this.createTeamRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Delete Team By ID.
   */
  async deleteTeamByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling deleteTeamByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/teams/{team_id}`.replace(`{${"team_id"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Delete Team By ID.
   */
  async deleteTeamByID(requestParameters, initOverrides) {
    const response = await this.deleteTeamByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get Team By ID.
   */
  async getTeamByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling getTeamByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/teams/{team_id}`.replace(`{${"team_id"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => TeamDTOFromJSON(jsonValue));
  }
  /**
   * Get Team By ID.
   */
  async getTeamByID(requestParameters, initOverrides) {
    const response = await this.getTeamByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get Team Members.
   */
  async getTeamMembersRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling getTeamMembers().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/teams/{team_id}/members`.replace(`{${"team_id"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(TeamMemberDTOFromJSON));
  }
  /**
   * Get Team Members.
   */
  async getTeamMembers(requestParameters, initOverrides) {
    const response = await this.getTeamMembersRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get Team Preferences.
   */
  async getTeamPreferencesRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling getTeamPreferences().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/teams/{team_id}/preferences`.replace(`{${"team_id"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PreferencesFromJSON(jsonValue));
  }
  /**
   * Get Team Preferences.
   */
  async getTeamPreferences(requestParameters, initOverrides) {
    const response = await this.getTeamPreferencesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Remove Member From Team.
   */
  async removeTeamMemberRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling removeTeamMember().'
      );
    }
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling removeTeamMember().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/teams/{team_id}/members/{user_id}`.replace(`{${"team_id"}}`, encodeURIComponent(String(requestParameters["teamId"]))).replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Remove Member From Team.
   */
  async removeTeamMember(requestParameters, initOverrides) {
    const response = await this.removeTeamMemberRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Team Search With Paging.
   */
  async searchTeamsRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    if (requestParameters["perpage"] != null) {
      queryParameters["perpage"] = requestParameters["perpage"];
    }
    if (requestParameters["name"] != null) {
      queryParameters["name"] = requestParameters["name"];
    }
    if (requestParameters["query"] != null) {
      queryParameters["query"] = requestParameters["query"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/teams/search`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchTeamQueryResultFromJSON(jsonValue));
  }
  /**
   * Team Search With Paging.
   */
  async searchTeams(requestParameters = {}, initOverrides) {
    const response = await this.searchTeamsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update Team.
   */
  async updateTeamRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling updateTeam().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateTeam().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/teams/{team_id}`.replace(`{${"team_id"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateTeamCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Update Team.
   */
  async updateTeam(requestParameters, initOverrides) {
    const response = await this.updateTeamRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update Team Member.
   */
  async updateTeamMemberRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling updateTeamMember().'
      );
    }
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling updateTeamMember().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateTeamMember().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/teams/{team_id}/members/{user_id}`.replace(`{${"team_id"}}`, encodeURIComponent(String(requestParameters["teamId"]))).replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateTeamMemberCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Update Team Member.
   */
  async updateTeamMember(requestParameters, initOverrides) {
    const response = await this.updateTeamMemberRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Update Team Preferences.
   */
  async updateTeamPreferencesRaw(requestParameters, initOverrides) {
    if (requestParameters["teamId"] == null) {
      throw new RequiredError(
        "teamId",
        'Required parameter "teamId" was null or undefined when calling updateTeamPreferences().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateTeamPreferences().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/teams/{team_id}/preferences`.replace(`{${"team_id"}}`, encodeURIComponent(String(requestParameters["teamId"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdatePrefsCmdToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Update Team Preferences.
   */
  async updateTeamPreferences(requestParameters, initOverrides) {
    const response = await this.updateTeamPreferencesRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/UserApi.ts
var UserApi = class extends BaseAPI {
  /**
   * Update the email of user given a verification code.
   * Update user email.
   */
  async updateUserEmailRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user/email/update`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Update the email of user given a verification code.
   * Update user email.
   */
  async updateUserEmail(initOverrides) {
    await this.updateUserEmailRaw(initOverrides);
  }
};

// apis/UserPreferencesApi.ts
var UserPreferencesApi = class extends BaseAPI {
  /**
   * Get user preferences.
   */
  async getUserPreferencesRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user/preferences`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PreferencesFromJSON(jsonValue));
  }
  /**
   * Get user preferences.
   */
  async getUserPreferences(initOverrides) {
    const response = await this.getUserPreferencesRaw(initOverrides);
    return await response.value();
  }
  /**
   * Patch user preferences.
   */
  async patchUserPreferencesRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling patchUserPreferences().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user/preferences`,
      method: "PATCH",
      headers: headerParameters,
      query: queryParameters,
      body: PatchPrefsCmdToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Patch user preferences.
   */
  async patchUserPreferences(requestParameters, initOverrides) {
    const response = await this.patchUserPreferencesRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Omitting a key (`theme`, `homeDashboardId`, `timezone`) will cause the current value to be replaced with the system default value.
   * Update user preferences.
   */
  async updateUserPreferencesRaw(requestParameters, initOverrides) {
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateUserPreferences().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/user/preferences`,
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdatePrefsCmdToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Omitting a key (`theme`, `homeDashboardId`, `timezone`) will cause the current value to be replaced with the system default value.
   * Update user preferences.
   */
  async updateUserPreferences(requestParameters, initOverrides) {
    const response = await this.updateUserPreferencesRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// apis/UsersApi.ts
var UsersApi = class extends BaseAPI {
  /**
   * Get user by id.
   */
  async getUserByIDRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling getUserByID().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/users/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UserProfileDTOFromJSON(jsonValue));
  }
  /**
   * Get user by id.
   */
  async getUserByID(requestParameters, initOverrides) {
    const response = await this.getUserByIDRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get user by login or email.
   */
  async getUserByLoginOrEmailRaw(requestParameters, initOverrides) {
    if (requestParameters["loginOrEmail"] == null) {
      throw new RequiredError(
        "loginOrEmail",
        'Required parameter "loginOrEmail" was null or undefined when calling getUserByLoginOrEmail().'
      );
    }
    const queryParameters = {};
    if (requestParameters["loginOrEmail"] != null) {
      queryParameters["loginOrEmail"] = requestParameters["loginOrEmail"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/users/lookup`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => UserProfileDTOFromJSON(jsonValue));
  }
  /**
   * Get user by login or email.
   */
  async getUserByLoginOrEmail(requestParameters, initOverrides) {
    const response = await this.getUserByLoginOrEmailRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get organizations for user identified by id.
   * Get organizations for user.
   */
  async getUserOrgListRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling getUserOrgList().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/users/{user_id}/orgs`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(UserOrgDTOFromJSON));
  }
  /**
   * Get organizations for user identified by id.
   * Get organizations for user.
   */
  async getUserOrgList(requestParameters, initOverrides) {
    const response = await this.getUserOrgListRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get teams for user identified by id.
   * Get teams for user.
   */
  async getUserTeamsRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling getUserTeams().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/users/{user_id}/teams`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(TeamDTOFromJSON));
  }
  /**
   * Get teams for user identified by id.
   * Get teams for user.
   */
  async getUserTeams(requestParameters, initOverrides) {
    const response = await this.getUserTeamsRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Returns all users that the authenticated user has permission to view, admin permission required.
   * Get users.
   */
  async searchUsersRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters["perpage"] != null) {
      queryParameters["perpage"] = requestParameters["perpage"];
    }
    if (requestParameters["page"] != null) {
      queryParameters["page"] = requestParameters["page"];
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/users`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => jsonValue.map(UserSearchHitDTOFromJSON));
  }
  /**
   * Returns all users that the authenticated user has permission to view, admin permission required.
   * Get users.
   */
  async searchUsers(requestParameters = {}, initOverrides) {
    const response = await this.searchUsersRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get users with paging.
   */
  async searchUsersWithPagingRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/users/search`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SearchUserQueryResultFromJSON(jsonValue));
  }
  /**
   * Get users with paging.
   */
  async searchUsersWithPaging(initOverrides) {
    const response = await this.searchUsersWithPagingRaw(initOverrides);
    return await response.value();
  }
  /**
   * Update the user identified by id.
   * Update user.
   */
  async updateUserRaw(requestParameters, initOverrides) {
    if (requestParameters["userId"] == null) {
      throw new RequiredError(
        "userId",
        'Required parameter "userId" was null or undefined when calling updateUser().'
      );
    }
    if (requestParameters["body"] == null) {
      throw new RequiredError(
        "body",
        'Required parameter "body" was null or undefined when calling updateUser().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] = await this.configuration.apiKey("Authorization");
    }
    if (this.configuration && (this.configuration.username !== void 0 || this.configuration.password !== void 0)) {
      headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request({
      path: `/users/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters["userId"]))),
      method: "PUT",
      headers: headerParameters,
      query: queryParameters,
      body: UpdateUserCommandToJSON(requestParameters["body"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => SuccessResponseBodyFromJSON(jsonValue));
  }
  /**
   * Update the user identified by id.
   * Update user.
   */
  async updateUser(requestParameters, initOverrides) {
    const response = await this.updateUserRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

exports.AccessControlApi = AccessControlApi;
exports.AccessControlProvisioningApi = AccessControlProvisioningApi;
exports.ActiveSyncStatusDTOFromJSON = ActiveSyncStatusDTOFromJSON;
exports.ActiveSyncStatusDTOFromJSONTyped = ActiveSyncStatusDTOFromJSONTyped;
exports.ActiveSyncStatusDTOToJSON = ActiveSyncStatusDTOToJSON;
exports.ActiveSyncStatusDTOToJSONTyped = ActiveSyncStatusDTOToJSONTyped;
exports.ActiveUserStatsFromJSON = ActiveUserStatsFromJSON;
exports.ActiveUserStatsFromJSONTyped = ActiveUserStatsFromJSONTyped;
exports.ActiveUserStatsToJSON = ActiveUserStatsToJSON;
exports.ActiveUserStatsToJSONTyped = ActiveUserStatsToJSONTyped;
exports.AddAPIKeyCommandFromJSON = AddAPIKeyCommandFromJSON;
exports.AddAPIKeyCommandFromJSONTyped = AddAPIKeyCommandFromJSONTyped;
exports.AddAPIKeyCommandRoleEnum = AddAPIKeyCommandRoleEnum;
exports.AddAPIKeyCommandToJSON = AddAPIKeyCommandToJSON;
exports.AddAPIKeyCommandToJSONTyped = AddAPIKeyCommandToJSONTyped;
exports.AddDataSource200ResponseFromJSON = AddDataSource200ResponseFromJSON;
exports.AddDataSource200ResponseFromJSONTyped = AddDataSource200ResponseFromJSONTyped;
exports.AddDataSource200ResponseToJSON = AddDataSource200ResponseToJSON;
exports.AddDataSource200ResponseToJSONTyped = AddDataSource200ResponseToJSONTyped;
exports.AddDataSourceCommandFromJSON = AddDataSourceCommandFromJSON;
exports.AddDataSourceCommandFromJSONTyped = AddDataSourceCommandFromJSONTyped;
exports.AddDataSourceCommandToJSON = AddDataSourceCommandToJSON;
exports.AddDataSourceCommandToJSONTyped = AddDataSourceCommandToJSONTyped;
exports.AddInviteFormFromJSON = AddInviteFormFromJSON;
exports.AddInviteFormFromJSONTyped = AddInviteFormFromJSONTyped;
exports.AddInviteFormRoleEnum = AddInviteFormRoleEnum;
exports.AddInviteFormToJSON = AddInviteFormToJSON;
exports.AddInviteFormToJSONTyped = AddInviteFormToJSONTyped;
exports.AddOrgUserCommandFromJSON = AddOrgUserCommandFromJSON;
exports.AddOrgUserCommandFromJSONTyped = AddOrgUserCommandFromJSONTyped;
exports.AddOrgUserCommandRoleEnum = AddOrgUserCommandRoleEnum;
exports.AddOrgUserCommandToJSON = AddOrgUserCommandToJSON;
exports.AddOrgUserCommandToJSONTyped = AddOrgUserCommandToJSONTyped;
exports.AddServiceAccountTokenCommandFromJSON = AddServiceAccountTokenCommandFromJSON;
exports.AddServiceAccountTokenCommandFromJSONTyped = AddServiceAccountTokenCommandFromJSONTyped;
exports.AddServiceAccountTokenCommandToJSON = AddServiceAccountTokenCommandToJSON;
exports.AddServiceAccountTokenCommandToJSONTyped = AddServiceAccountTokenCommandToJSONTyped;
exports.AddTeamMemberCommandFromJSON = AddTeamMemberCommandFromJSON;
exports.AddTeamMemberCommandFromJSONTyped = AddTeamMemberCommandFromJSONTyped;
exports.AddTeamMemberCommandToJSON = AddTeamMemberCommandToJSON;
exports.AddTeamMemberCommandToJSONTyped = AddTeamMemberCommandToJSONTyped;
exports.AddTeamRoleCommandFromJSON = AddTeamRoleCommandFromJSON;
exports.AddTeamRoleCommandFromJSONTyped = AddTeamRoleCommandFromJSONTyped;
exports.AddTeamRoleCommandToJSON = AddTeamRoleCommandToJSON;
exports.AddTeamRoleCommandToJSONTyped = AddTeamRoleCommandToJSONTyped;
exports.AddUserRoleCommandFromJSON = AddUserRoleCommandFromJSON;
exports.AddUserRoleCommandFromJSONTyped = AddUserRoleCommandFromJSONTyped;
exports.AddUserRoleCommandToJSON = AddUserRoleCommandToJSON;
exports.AddUserRoleCommandToJSONTyped = AddUserRoleCommandToJSONTyped;
exports.AddressFromJSON = AddressFromJSON;
exports.AddressFromJSONTyped = AddressFromJSONTyped;
exports.AddressToJSON = AddressToJSON;
exports.AddressToJSONTyped = AddressToJSONTyped;
exports.AdminApi = AdminApi;
exports.AdminCreateUserFormFromJSON = AdminCreateUserFormFromJSON;
exports.AdminCreateUserFormFromJSONTyped = AdminCreateUserFormFromJSONTyped;
exports.AdminCreateUserFormToJSON = AdminCreateUserFormToJSON;
exports.AdminCreateUserFormToJSONTyped = AdminCreateUserFormToJSONTyped;
exports.AdminCreateUserResponseFromJSON = AdminCreateUserResponseFromJSON;
exports.AdminCreateUserResponseFromJSONTyped = AdminCreateUserResponseFromJSONTyped;
exports.AdminCreateUserResponseToJSON = AdminCreateUserResponseToJSON;
exports.AdminCreateUserResponseToJSONTyped = AdminCreateUserResponseToJSONTyped;
exports.AdminLdapApi = AdminLdapApi;
exports.AdminProvisioningApi = AdminProvisioningApi;
exports.AdminStatsFromJSON = AdminStatsFromJSON;
exports.AdminStatsFromJSONTyped = AdminStatsFromJSONTyped;
exports.AdminStatsToJSON = AdminStatsToJSON;
exports.AdminStatsToJSONTyped = AdminStatsToJSONTyped;
exports.AdminUpdateUserPasswordFormFromJSON = AdminUpdateUserPasswordFormFromJSON;
exports.AdminUpdateUserPasswordFormFromJSONTyped = AdminUpdateUserPasswordFormFromJSONTyped;
exports.AdminUpdateUserPasswordFormToJSON = AdminUpdateUserPasswordFormToJSON;
exports.AdminUpdateUserPasswordFormToJSONTyped = AdminUpdateUserPasswordFormToJSONTyped;
exports.AdminUpdateUserPermissionsFormFromJSON = AdminUpdateUserPermissionsFormFromJSON;
exports.AdminUpdateUserPermissionsFormFromJSONTyped = AdminUpdateUserPermissionsFormFromJSONTyped;
exports.AdminUpdateUserPermissionsFormToJSON = AdminUpdateUserPermissionsFormToJSON;
exports.AdminUpdateUserPermissionsFormToJSONTyped = AdminUpdateUserPermissionsFormToJSONTyped;
exports.AdminUsersApi = AdminUsersApi;
exports.AlertDiscoveryFromJSON = AlertDiscoveryFromJSON;
exports.AlertDiscoveryFromJSONTyped = AlertDiscoveryFromJSONTyped;
exports.AlertDiscoveryToJSON = AlertDiscoveryToJSON;
exports.AlertDiscoveryToJSONTyped = AlertDiscoveryToJSONTyped;
exports.AlertFromJSON = AlertFromJSON;
exports.AlertFromJSONTyped = AlertFromJSONTyped;
exports.AlertGroupFromJSON = AlertGroupFromJSON;
exports.AlertGroupFromJSONTyped = AlertGroupFromJSONTyped;
exports.AlertGroupToJSON = AlertGroupToJSON;
exports.AlertGroupToJSONTyped = AlertGroupToJSONTyped;
exports.AlertInstancesResponseFromJSON = AlertInstancesResponseFromJSON;
exports.AlertInstancesResponseFromJSONTyped = AlertInstancesResponseFromJSONTyped;
exports.AlertInstancesResponseToJSON = AlertInstancesResponseToJSON;
exports.AlertInstancesResponseToJSONTyped = AlertInstancesResponseToJSONTyped;
exports.AlertManagerFromJSON = AlertManagerFromJSON;
exports.AlertManagerFromJSONTyped = AlertManagerFromJSONTyped;
exports.AlertManagerToJSON = AlertManagerToJSON;
exports.AlertManagerToJSONTyped = AlertManagerToJSONTyped;
exports.AlertManagersResultFromJSON = AlertManagersResultFromJSON;
exports.AlertManagersResultFromJSONTyped = AlertManagersResultFromJSONTyped;
exports.AlertManagersResultToJSON = AlertManagersResultToJSON;
exports.AlertManagersResultToJSONTyped = AlertManagersResultToJSONTyped;
exports.AlertQueryExportFromJSON = AlertQueryExportFromJSON;
exports.AlertQueryExportFromJSONTyped = AlertQueryExportFromJSONTyped;
exports.AlertQueryExportToJSON = AlertQueryExportToJSON;
exports.AlertQueryExportToJSONTyped = AlertQueryExportToJSONTyped;
exports.AlertQueryFromJSON = AlertQueryFromJSON;
exports.AlertQueryFromJSONTyped = AlertQueryFromJSONTyped;
exports.AlertQueryToJSON = AlertQueryToJSON;
exports.AlertQueryToJSONTyped = AlertQueryToJSONTyped;
exports.AlertResponseFromJSON = AlertResponseFromJSON;
exports.AlertResponseFromJSONTyped = AlertResponseFromJSONTyped;
exports.AlertResponseToJSON = AlertResponseToJSON;
exports.AlertResponseToJSONTyped = AlertResponseToJSONTyped;
exports.AlertRuleExportExecErrStateEnum = AlertRuleExportExecErrStateEnum;
exports.AlertRuleExportFromJSON = AlertRuleExportFromJSON;
exports.AlertRuleExportFromJSONTyped = AlertRuleExportFromJSONTyped;
exports.AlertRuleExportNoDataStateEnum = AlertRuleExportNoDataStateEnum;
exports.AlertRuleExportToJSON = AlertRuleExportToJSON;
exports.AlertRuleExportToJSONTyped = AlertRuleExportToJSONTyped;
exports.AlertRuleGroupExportFromJSON = AlertRuleGroupExportFromJSON;
exports.AlertRuleGroupExportFromJSONTyped = AlertRuleGroupExportFromJSONTyped;
exports.AlertRuleGroupExportToJSON = AlertRuleGroupExportToJSON;
exports.AlertRuleGroupExportToJSONTyped = AlertRuleGroupExportToJSONTyped;
exports.AlertRuleGroupFromJSON = AlertRuleGroupFromJSON;
exports.AlertRuleGroupFromJSONTyped = AlertRuleGroupFromJSONTyped;
exports.AlertRuleGroupMetadataFromJSON = AlertRuleGroupMetadataFromJSON;
exports.AlertRuleGroupMetadataFromJSONTyped = AlertRuleGroupMetadataFromJSONTyped;
exports.AlertRuleGroupMetadataToJSON = AlertRuleGroupMetadataToJSON;
exports.AlertRuleGroupMetadataToJSONTyped = AlertRuleGroupMetadataToJSONTyped;
exports.AlertRuleGroupToJSON = AlertRuleGroupToJSON;
exports.AlertRuleGroupToJSONTyped = AlertRuleGroupToJSONTyped;
exports.AlertRuleNotificationSettingsExportFromJSON = AlertRuleNotificationSettingsExportFromJSON;
exports.AlertRuleNotificationSettingsExportFromJSONTyped = AlertRuleNotificationSettingsExportFromJSONTyped;
exports.AlertRuleNotificationSettingsExportToJSON = AlertRuleNotificationSettingsExportToJSON;
exports.AlertRuleNotificationSettingsExportToJSONTyped = AlertRuleNotificationSettingsExportToJSONTyped;
exports.AlertRuleNotificationSettingsFromJSON = AlertRuleNotificationSettingsFromJSON;
exports.AlertRuleNotificationSettingsFromJSONTyped = AlertRuleNotificationSettingsFromJSONTyped;
exports.AlertRuleNotificationSettingsToJSON = AlertRuleNotificationSettingsToJSON;
exports.AlertRuleNotificationSettingsToJSONTyped = AlertRuleNotificationSettingsToJSONTyped;
exports.AlertStatusFromJSON = AlertStatusFromJSON;
exports.AlertStatusFromJSONTyped = AlertStatusFromJSONTyped;
exports.AlertStatusStateEnum = AlertStatusStateEnum;
exports.AlertStatusToJSON = AlertStatusToJSON;
exports.AlertStatusToJSONTyped = AlertStatusToJSONTyped;
exports.AlertToJSON = AlertToJSON;
exports.AlertToJSONTyped = AlertToJSONTyped;
exports.AlertingFileExportFromJSON = AlertingFileExportFromJSON;
exports.AlertingFileExportFromJSONTyped = AlertingFileExportFromJSONTyped;
exports.AlertingFileExportToJSON = AlertingFileExportToJSON;
exports.AlertingFileExportToJSONTyped = AlertingFileExportToJSONTyped;
exports.AlertingRuleFromJSON = AlertingRuleFromJSON;
exports.AlertingRuleFromJSONTyped = AlertingRuleFromJSONTyped;
exports.AlertingRuleToJSON = AlertingRuleToJSON;
exports.AlertingRuleToJSONTyped = AlertingRuleToJSONTyped;
exports.AlertingStatusAlertmanagersChoiceEnum = AlertingStatusAlertmanagersChoiceEnum;
exports.AlertingStatusFromJSON = AlertingStatusFromJSON;
exports.AlertingStatusFromJSONTyped = AlertingStatusFromJSONTyped;
exports.AlertingStatusToJSON = AlertingStatusToJSON;
exports.AlertingStatusToJSONTyped = AlertingStatusToJSONTyped;
exports.AlertmanagerConfigFromJSON = AlertmanagerConfigFromJSON;
exports.AlertmanagerConfigFromJSONTyped = AlertmanagerConfigFromJSONTyped;
exports.AlertmanagerConfigToJSON = AlertmanagerConfigToJSON;
exports.AlertmanagerConfigToJSONTyped = AlertmanagerConfigToJSONTyped;
exports.AlertmanagerStatusFromJSON = AlertmanagerStatusFromJSON;
exports.AlertmanagerStatusFromJSONTyped = AlertmanagerStatusFromJSONTyped;
exports.AlertmanagerStatusToJSON = AlertmanagerStatusToJSON;
exports.AlertmanagerStatusToJSONTyped = AlertmanagerStatusToJSONTyped;
exports.AnnotationActionsFromJSON = AnnotationActionsFromJSON;
exports.AnnotationActionsFromJSONTyped = AnnotationActionsFromJSONTyped;
exports.AnnotationActionsToJSON = AnnotationActionsToJSON;
exports.AnnotationActionsToJSONTyped = AnnotationActionsToJSONTyped;
exports.AnnotationEventFromJSON = AnnotationEventFromJSON;
exports.AnnotationEventFromJSONTyped = AnnotationEventFromJSONTyped;
exports.AnnotationEventToJSON = AnnotationEventToJSON;
exports.AnnotationEventToJSONTyped = AnnotationEventToJSONTyped;
exports.AnnotationFromJSON = AnnotationFromJSON;
exports.AnnotationFromJSONTyped = AnnotationFromJSONTyped;
exports.AnnotationPanelFilterFromJSON = AnnotationPanelFilterFromJSON;
exports.AnnotationPanelFilterFromJSONTyped = AnnotationPanelFilterFromJSONTyped;
exports.AnnotationPanelFilterToJSON = AnnotationPanelFilterToJSON;
exports.AnnotationPanelFilterToJSONTyped = AnnotationPanelFilterToJSONTyped;
exports.AnnotationPermissionFromJSON = AnnotationPermissionFromJSON;
exports.AnnotationPermissionFromJSONTyped = AnnotationPermissionFromJSONTyped;
exports.AnnotationPermissionToJSON = AnnotationPermissionToJSON;
exports.AnnotationPermissionToJSONTyped = AnnotationPermissionToJSONTyped;
exports.AnnotationQueryFromJSON = AnnotationQueryFromJSON;
exports.AnnotationQueryFromJSONTyped = AnnotationQueryFromJSONTyped;
exports.AnnotationQueryToJSON = AnnotationQueryToJSON;
exports.AnnotationQueryToJSONTyped = AnnotationQueryToJSONTyped;
exports.AnnotationTargetFromJSON = AnnotationTargetFromJSON;
exports.AnnotationTargetFromJSONTyped = AnnotationTargetFromJSONTyped;
exports.AnnotationTargetToJSON = AnnotationTargetToJSON;
exports.AnnotationTargetToJSONTyped = AnnotationTargetToJSONTyped;
exports.AnnotationToJSON = AnnotationToJSON;
exports.AnnotationToJSONTyped = AnnotationToJSONTyped;
exports.AnnotationsApi = AnnotationsApi;
exports.ApiKeyDTOFromJSON = ApiKeyDTOFromJSON;
exports.ApiKeyDTOFromJSONTyped = ApiKeyDTOFromJSONTyped;
exports.ApiKeyDTORoleEnum = ApiKeyDTORoleEnum;
exports.ApiKeyDTOToJSON = ApiKeyDTOToJSON;
exports.ApiKeyDTOToJSONTyped = ApiKeyDTOToJSONTyped;
exports.ApiKeysApi = ApiKeysApi;
exports.ApiRuleNodeFromJSON = ApiRuleNodeFromJSON;
exports.ApiRuleNodeFromJSONTyped = ApiRuleNodeFromJSONTyped;
exports.ApiRuleNodeToJSON = ApiRuleNodeToJSON;
exports.ApiRuleNodeToJSONTyped = ApiRuleNodeToJSONTyped;
exports.AssignmentsFromJSON = AssignmentsFromJSON;
exports.AssignmentsFromJSONTyped = AssignmentsFromJSONTyped;
exports.AssignmentsToJSON = AssignmentsToJSON;
exports.AssignmentsToJSONTyped = AssignmentsToJSONTyped;
exports.AttributeTypeAndValueFromJSON = AttributeTypeAndValueFromJSON;
exports.AttributeTypeAndValueFromJSONTyped = AttributeTypeAndValueFromJSONTyped;
exports.AttributeTypeAndValueToJSON = AttributeTypeAndValueToJSON;
exports.AttributeTypeAndValueToJSONTyped = AttributeTypeAndValueToJSONTyped;
exports.AuthorizationFromJSON = AuthorizationFromJSON;
exports.AuthorizationFromJSONTyped = AuthorizationFromJSONTyped;
exports.AuthorizationToJSON = AuthorizationToJSON;
exports.AuthorizationToJSONTyped = AuthorizationToJSONTyped;
exports.BASE_PATH = BASE_PATH;
exports.BacktestConfigFromJSON = BacktestConfigFromJSON;
exports.BacktestConfigFromJSONTyped = BacktestConfigFromJSONTyped;
exports.BacktestConfigNoDataStateEnum = BacktestConfigNoDataStateEnum;
exports.BacktestConfigToJSON = BacktestConfigToJSON;
exports.BacktestConfigToJSONTyped = BacktestConfigToJSONTyped;
exports.BaseAPI = BaseAPI;
exports.BasicAuthFromJSON = BasicAuthFromJSON;
exports.BasicAuthFromJSONTyped = BasicAuthFromJSONTyped;
exports.BasicAuthToJSON = BasicAuthToJSON;
exports.BasicAuthToJSONTyped = BasicAuthToJSONTyped;
exports.BlobApiResponse = BlobApiResponse;
exports.COLLECTION_FORMATS = COLLECTION_FORMATS;
exports.CalculateDashboardDiffRequestDiffTypeEnum = CalculateDashboardDiffRequestDiffTypeEnum;
exports.CalculateDashboardDiffRequestFromJSON = CalculateDashboardDiffRequestFromJSON;
exports.CalculateDashboardDiffRequestFromJSONTyped = CalculateDashboardDiffRequestFromJSONTyped;
exports.CalculateDashboardDiffRequestToJSON = CalculateDashboardDiffRequestToJSON;
exports.CalculateDashboardDiffRequestToJSONTyped = CalculateDashboardDiffRequestToJSONTyped;
exports.CalculateDiffTargetFromJSON = CalculateDiffTargetFromJSON;
exports.CalculateDiffTargetFromJSONTyped = CalculateDiffTargetFromJSONTyped;
exports.CalculateDiffTargetToJSON = CalculateDiffTargetToJSON;
exports.CalculateDiffTargetToJSONTyped = CalculateDiffTargetToJSONTyped;
exports.CertificateFromJSON = CertificateFromJSON;
exports.CertificateFromJSONTyped = CertificateFromJSONTyped;
exports.CertificateToJSON = CertificateToJSON;
exports.CertificateToJSONTyped = CertificateToJSONTyped;
exports.ChangeUserPasswordCommandFromJSON = ChangeUserPasswordCommandFromJSON;
exports.ChangeUserPasswordCommandFromJSONTyped = ChangeUserPasswordCommandFromJSONTyped;
exports.ChangeUserPasswordCommandToJSON = ChangeUserPasswordCommandToJSON;
exports.ChangeUserPasswordCommandToJSONTyped = ChangeUserPasswordCommandToJSONTyped;
exports.ClearHelpFlags200ResponseFromJSON = ClearHelpFlags200ResponseFromJSON;
exports.ClearHelpFlags200ResponseFromJSONTyped = ClearHelpFlags200ResponseFromJSONTyped;
exports.ClearHelpFlags200ResponseToJSON = ClearHelpFlags200ResponseToJSON;
exports.ClearHelpFlags200ResponseToJSONTyped = ClearHelpFlags200ResponseToJSONTyped;
exports.ClusterStatusFromJSON = ClusterStatusFromJSON;
exports.ClusterStatusFromJSONTyped = ClusterStatusFromJSONTyped;
exports.ClusterStatusStatusEnum = ClusterStatusStatusEnum;
exports.ClusterStatusToJSON = ClusterStatusToJSON;
exports.ClusterStatusToJSONTyped = ClusterStatusToJSONTyped;
exports.ConfigFromJSON = ConfigFromJSON;
exports.ConfigFromJSONTyped = ConfigFromJSONTyped;
exports.ConfigToJSON = ConfigToJSON;
exports.ConfigToJSONTyped = ConfigToJSONTyped;
exports.Configuration = Configuration;
exports.ContactPointExportFromJSON = ContactPointExportFromJSON;
exports.ContactPointExportFromJSONTyped = ContactPointExportFromJSONTyped;
exports.ContactPointExportToJSON = ContactPointExportToJSON;
exports.ContactPointExportToJSONTyped = ContactPointExportToJSONTyped;
exports.CookiePreferencesFromJSON = CookiePreferencesFromJSON;
exports.CookiePreferencesFromJSONTyped = CookiePreferencesFromJSONTyped;
exports.CookiePreferencesToJSON = CookiePreferencesToJSON;
exports.CookiePreferencesToJSONTyped = CookiePreferencesToJSONTyped;
exports.CorrelationConfigFromJSON = CorrelationConfigFromJSON;
exports.CorrelationConfigFromJSONTyped = CorrelationConfigFromJSONTyped;
exports.CorrelationConfigToJSON = CorrelationConfigToJSON;
exports.CorrelationConfigToJSONTyped = CorrelationConfigToJSONTyped;
exports.CorrelationConfigUpdateDTOFromJSON = CorrelationConfigUpdateDTOFromJSON;
exports.CorrelationConfigUpdateDTOFromJSONTyped = CorrelationConfigUpdateDTOFromJSONTyped;
exports.CorrelationConfigUpdateDTOToJSON = CorrelationConfigUpdateDTOToJSON;
exports.CorrelationConfigUpdateDTOToJSONTyped = CorrelationConfigUpdateDTOToJSONTyped;
exports.CorrelationFromJSON = CorrelationFromJSON;
exports.CorrelationFromJSONTyped = CorrelationFromJSONTyped;
exports.CorrelationToJSON = CorrelationToJSON;
exports.CorrelationToJSONTyped = CorrelationToJSONTyped;
exports.CorrelationsApi = CorrelationsApi;
exports.CreateCorrelationCommandFromJSON = CreateCorrelationCommandFromJSON;
exports.CreateCorrelationCommandFromJSONTyped = CreateCorrelationCommandFromJSONTyped;
exports.CreateCorrelationCommandToJSON = CreateCorrelationCommandToJSON;
exports.CreateCorrelationCommandToJSONTyped = CreateCorrelationCommandToJSONTyped;
exports.CreateCorrelationResponseBodyFromJSON = CreateCorrelationResponseBodyFromJSON;
exports.CreateCorrelationResponseBodyFromJSONTyped = CreateCorrelationResponseBodyFromJSONTyped;
exports.CreateCorrelationResponseBodyToJSON = CreateCorrelationResponseBodyToJSON;
exports.CreateCorrelationResponseBodyToJSONTyped = CreateCorrelationResponseBodyToJSONTyped;
exports.CreateDashboardSnapshot200ResponseFromJSON = CreateDashboardSnapshot200ResponseFromJSON;
exports.CreateDashboardSnapshot200ResponseFromJSONTyped = CreateDashboardSnapshot200ResponseFromJSONTyped;
exports.CreateDashboardSnapshot200ResponseToJSON = CreateDashboardSnapshot200ResponseToJSON;
exports.CreateDashboardSnapshot200ResponseToJSONTyped = CreateDashboardSnapshot200ResponseToJSONTyped;
exports.CreateDashboardSnapshotCommandFromJSON = CreateDashboardSnapshotCommandFromJSON;
exports.CreateDashboardSnapshotCommandFromJSONTyped = CreateDashboardSnapshotCommandFromJSONTyped;
exports.CreateDashboardSnapshotCommandToJSON = CreateDashboardSnapshotCommandToJSON;
exports.CreateDashboardSnapshotCommandToJSONTyped = CreateDashboardSnapshotCommandToJSONTyped;
exports.CreateFolderCommandFromJSON = CreateFolderCommandFromJSON;
exports.CreateFolderCommandFromJSONTyped = CreateFolderCommandFromJSONTyped;
exports.CreateFolderCommandToJSON = CreateFolderCommandToJSON;
exports.CreateFolderCommandToJSONTyped = CreateFolderCommandToJSONTyped;
exports.CreateLibraryElementCommandFromJSON = CreateLibraryElementCommandFromJSON;
exports.CreateLibraryElementCommandFromJSONTyped = CreateLibraryElementCommandFromJSONTyped;
exports.CreateLibraryElementCommandKindEnum = CreateLibraryElementCommandKindEnum;
exports.CreateLibraryElementCommandToJSON = CreateLibraryElementCommandToJSON;
exports.CreateLibraryElementCommandToJSONTyped = CreateLibraryElementCommandToJSONTyped;
exports.CreateOrUpdateReportConfigFromJSON = CreateOrUpdateReportConfigFromJSON;
exports.CreateOrUpdateReportConfigFromJSONTyped = CreateOrUpdateReportConfigFromJSONTyped;
exports.CreateOrUpdateReportConfigToJSON = CreateOrUpdateReportConfigToJSON;
exports.CreateOrUpdateReportConfigToJSONTyped = CreateOrUpdateReportConfigToJSONTyped;
exports.CreateOrg200ResponseFromJSON = CreateOrg200ResponseFromJSON;
exports.CreateOrg200ResponseFromJSONTyped = CreateOrg200ResponseFromJSONTyped;
exports.CreateOrg200ResponseToJSON = CreateOrg200ResponseToJSON;
exports.CreateOrg200ResponseToJSONTyped = CreateOrg200ResponseToJSONTyped;
exports.CreateOrgCommandFromJSON = CreateOrgCommandFromJSON;
exports.CreateOrgCommandFromJSONTyped = CreateOrgCommandFromJSONTyped;
exports.CreateOrgCommandToJSON = CreateOrgCommandToJSON;
exports.CreateOrgCommandToJSONTyped = CreateOrgCommandToJSONTyped;
exports.CreatePlaylistCommandFromJSON = CreatePlaylistCommandFromJSON;
exports.CreatePlaylistCommandFromJSONTyped = CreatePlaylistCommandFromJSONTyped;
exports.CreatePlaylistCommandToJSON = CreatePlaylistCommandToJSON;
exports.CreatePlaylistCommandToJSONTyped = CreatePlaylistCommandToJSONTyped;
exports.CreateQueryInQueryHistoryCommandFromJSON = CreateQueryInQueryHistoryCommandFromJSON;
exports.CreateQueryInQueryHistoryCommandFromJSONTyped = CreateQueryInQueryHistoryCommandFromJSONTyped;
exports.CreateQueryInQueryHistoryCommandToJSON = CreateQueryInQueryHistoryCommandToJSON;
exports.CreateQueryInQueryHistoryCommandToJSONTyped = CreateQueryInQueryHistoryCommandToJSONTyped;
exports.CreateReport200ResponseFromJSON = CreateReport200ResponseFromJSON;
exports.CreateReport200ResponseFromJSONTyped = CreateReport200ResponseFromJSONTyped;
exports.CreateReport200ResponseToJSON = CreateReport200ResponseToJSON;
exports.CreateReport200ResponseToJSONTyped = CreateReport200ResponseToJSONTyped;
exports.CreateRoleFormFromJSON = CreateRoleFormFromJSON;
exports.CreateRoleFormFromJSONTyped = CreateRoleFormFromJSONTyped;
exports.CreateRoleFormToJSON = CreateRoleFormToJSON;
exports.CreateRoleFormToJSONTyped = CreateRoleFormToJSONTyped;
exports.CreateServiceAccountFormFromJSON = CreateServiceAccountFormFromJSON;
exports.CreateServiceAccountFormFromJSONTyped = CreateServiceAccountFormFromJSONTyped;
exports.CreateServiceAccountFormRoleEnum = CreateServiceAccountFormRoleEnum;
exports.CreateServiceAccountFormToJSON = CreateServiceAccountFormToJSON;
exports.CreateServiceAccountFormToJSONTyped = CreateServiceAccountFormToJSONTyped;
exports.CreateTeam200ResponseFromJSON = CreateTeam200ResponseFromJSON;
exports.CreateTeam200ResponseFromJSONTyped = CreateTeam200ResponseFromJSONTyped;
exports.CreateTeam200ResponseToJSON = CreateTeam200ResponseToJSON;
exports.CreateTeam200ResponseToJSONTyped = CreateTeam200ResponseToJSONTyped;
exports.CreateTeamCommandFromJSON = CreateTeamCommandFromJSON;
exports.CreateTeamCommandFromJSONTyped = CreateTeamCommandFromJSONTyped;
exports.CreateTeamCommandToJSON = CreateTeamCommandToJSON;
exports.CreateTeamCommandToJSONTyped = CreateTeamCommandToJSONTyped;
exports.DashboardACLInfoDTOFromJSON = DashboardACLInfoDTOFromJSON;
exports.DashboardACLInfoDTOFromJSONTyped = DashboardACLInfoDTOFromJSONTyped;
exports.DashboardACLInfoDTORoleEnum = DashboardACLInfoDTORoleEnum;
exports.DashboardACLInfoDTOToJSON = DashboardACLInfoDTOToJSON;
exports.DashboardACLInfoDTOToJSONTyped = DashboardACLInfoDTOToJSONTyped;
exports.DashboardACLUpdateItemFromJSON = DashboardACLUpdateItemFromJSON;
exports.DashboardACLUpdateItemFromJSONTyped = DashboardACLUpdateItemFromJSONTyped;
exports.DashboardACLUpdateItemRoleEnum = DashboardACLUpdateItemRoleEnum;
exports.DashboardACLUpdateItemToJSON = DashboardACLUpdateItemToJSON;
exports.DashboardACLUpdateItemToJSONTyped = DashboardACLUpdateItemToJSONTyped;
exports.DashboardCreateCommandFromJSON = DashboardCreateCommandFromJSON;
exports.DashboardCreateCommandFromJSONTyped = DashboardCreateCommandFromJSONTyped;
exports.DashboardCreateCommandToJSON = DashboardCreateCommandToJSON;
exports.DashboardCreateCommandToJSONTyped = DashboardCreateCommandToJSONTyped;
exports.DashboardFullWithMetaFromJSON = DashboardFullWithMetaFromJSON;
exports.DashboardFullWithMetaFromJSONTyped = DashboardFullWithMetaFromJSONTyped;
exports.DashboardFullWithMetaToJSON = DashboardFullWithMetaToJSON;
exports.DashboardFullWithMetaToJSONTyped = DashboardFullWithMetaToJSONTyped;
exports.DashboardMetaFromJSON = DashboardMetaFromJSON;
exports.DashboardMetaFromJSONTyped = DashboardMetaFromJSONTyped;
exports.DashboardMetaToJSON = DashboardMetaToJSON;
exports.DashboardMetaToJSONTyped = DashboardMetaToJSONTyped;
exports.DashboardPermissionsApi = DashboardPermissionsApi;
exports.DashboardPublicApi = DashboardPublicApi;
exports.DashboardRedirectFromJSON = DashboardRedirectFromJSON;
exports.DashboardRedirectFromJSONTyped = DashboardRedirectFromJSONTyped;
exports.DashboardRedirectToJSON = DashboardRedirectToJSON;
exports.DashboardRedirectToJSONTyped = DashboardRedirectToJSONTyped;
exports.DashboardSnapshotDTOFromJSON = DashboardSnapshotDTOFromJSON;
exports.DashboardSnapshotDTOFromJSONTyped = DashboardSnapshotDTOFromJSONTyped;
exports.DashboardSnapshotDTOToJSON = DashboardSnapshotDTOToJSON;
exports.DashboardSnapshotDTOToJSONTyped = DashboardSnapshotDTOToJSONTyped;
exports.DashboardTagCloudItemFromJSON = DashboardTagCloudItemFromJSON;
exports.DashboardTagCloudItemFromJSONTyped = DashboardTagCloudItemFromJSONTyped;
exports.DashboardTagCloudItemToJSON = DashboardTagCloudItemToJSON;
exports.DashboardTagCloudItemToJSONTyped = DashboardTagCloudItemToJSONTyped;
exports.DashboardVersionMetaFromJSON = DashboardVersionMetaFromJSON;
exports.DashboardVersionMetaFromJSONTyped = DashboardVersionMetaFromJSONTyped;
exports.DashboardVersionMetaToJSON = DashboardVersionMetaToJSON;
exports.DashboardVersionMetaToJSONTyped = DashboardVersionMetaToJSONTyped;
exports.DashboardVersionsApi = DashboardVersionsApi;
exports.DashboardsApi = DashboardsApi;
exports.DataLinkFromJSON = DataLinkFromJSON;
exports.DataLinkFromJSONTyped = DataLinkFromJSONTyped;
exports.DataLinkToJSON = DataLinkToJSON;
exports.DataLinkToJSONTyped = DataLinkToJSONTyped;
exports.DataResponseFromJSON = DataResponseFromJSON;
exports.DataResponseFromJSONTyped = DataResponseFromJSONTyped;
exports.DataResponseToJSON = DataResponseToJSON;
exports.DataResponseToJSONTyped = DataResponseToJSONTyped;
exports.DataSourceFromJSON = DataSourceFromJSON;
exports.DataSourceFromJSONTyped = DataSourceFromJSONTyped;
exports.DataSourceListItemDTOFromJSON = DataSourceListItemDTOFromJSON;
exports.DataSourceListItemDTOFromJSONTyped = DataSourceListItemDTOFromJSONTyped;
exports.DataSourceListItemDTOToJSON = DataSourceListItemDTOToJSON;
exports.DataSourceListItemDTOToJSONTyped = DataSourceListItemDTOToJSONTyped;
exports.DataSourceRefFromJSON = DataSourceRefFromJSON;
exports.DataSourceRefFromJSONTyped = DataSourceRefFromJSONTyped;
exports.DataSourceRefToJSON = DataSourceRefToJSON;
exports.DataSourceRefToJSONTyped = DataSourceRefToJSONTyped;
exports.DataSourceToJSON = DataSourceToJSON;
exports.DataSourceToJSONTyped = DataSourceToJSONTyped;
exports.DatasourcesApi = DatasourcesApi;
exports.DefaultConfig = DefaultConfig;
exports.DeleteCorrelationResponseBodyFromJSON = DeleteCorrelationResponseBodyFromJSON;
exports.DeleteCorrelationResponseBodyFromJSONTyped = DeleteCorrelationResponseBodyFromJSONTyped;
exports.DeleteCorrelationResponseBodyToJSON = DeleteCorrelationResponseBodyToJSON;
exports.DeleteCorrelationResponseBodyToJSONTyped = DeleteCorrelationResponseBodyToJSONTyped;
exports.DeleteDashboardByUID200ResponseFromJSON = DeleteDashboardByUID200ResponseFromJSON;
exports.DeleteDashboardByUID200ResponseFromJSONTyped = DeleteDashboardByUID200ResponseFromJSONTyped;
exports.DeleteDashboardByUID200ResponseToJSON = DeleteDashboardByUID200ResponseToJSON;
exports.DeleteDashboardByUID200ResponseToJSONTyped = DeleteDashboardByUID200ResponseToJSONTyped;
exports.DeleteDataSourceByName200ResponseFromJSON = DeleteDataSourceByName200ResponseFromJSON;
exports.DeleteDataSourceByName200ResponseFromJSONTyped = DeleteDataSourceByName200ResponseFromJSONTyped;
exports.DeleteDataSourceByName200ResponseToJSON = DeleteDataSourceByName200ResponseToJSON;
exports.DeleteDataSourceByName200ResponseToJSONTyped = DeleteDataSourceByName200ResponseToJSONTyped;
exports.DeleteFolder200ResponseFromJSON = DeleteFolder200ResponseFromJSON;
exports.DeleteFolder200ResponseFromJSONTyped = DeleteFolder200ResponseFromJSONTyped;
exports.DeleteFolder200ResponseToJSON = DeleteFolder200ResponseToJSON;
exports.DeleteFolder200ResponseToJSONTyped = DeleteFolder200ResponseToJSONTyped;
exports.DeleteTokenCommandFromJSON = DeleteTokenCommandFromJSON;
exports.DeleteTokenCommandFromJSONTyped = DeleteTokenCommandFromJSONTyped;
exports.DeleteTokenCommandToJSON = DeleteTokenCommandToJSON;
exports.DeleteTokenCommandToJSONTyped = DeleteTokenCommandToJSONTyped;
exports.DescriptionFromJSON = DescriptionFromJSON;
exports.DescriptionFromJSONTyped = DescriptionFromJSONTyped;
exports.DescriptionToJSON = DescriptionToJSON;
exports.DescriptionToJSONTyped = DescriptionToJSONTyped;
exports.DeviceDTOFromJSON = DeviceDTOFromJSON;
exports.DeviceDTOFromJSONTyped = DeviceDTOFromJSONTyped;
exports.DeviceDTOToJSON = DeviceDTOToJSON;
exports.DeviceDTOToJSONTyped = DeviceDTOToJSONTyped;
exports.DeviceSearchHitDTOFromJSON = DeviceSearchHitDTOFromJSON;
exports.DeviceSearchHitDTOFromJSONTyped = DeviceSearchHitDTOFromJSONTyped;
exports.DeviceSearchHitDTOToJSON = DeviceSearchHitDTOToJSON;
exports.DeviceSearchHitDTOToJSONTyped = DeviceSearchHitDTOToJSONTyped;
exports.DevicesApi = DevicesApi;
exports.DiscordConfigFromJSON = DiscordConfigFromJSON;
exports.DiscordConfigFromJSONTyped = DiscordConfigFromJSONTyped;
exports.DiscordConfigToJSON = DiscordConfigToJSON;
exports.DiscordConfigToJSONTyped = DiscordConfigToJSONTyped;
exports.DiscoveryBaseFromJSON = DiscoveryBaseFromJSON;
exports.DiscoveryBaseFromJSONTyped = DiscoveryBaseFromJSONTyped;
exports.DiscoveryBaseToJSON = DiscoveryBaseToJSON;
exports.DiscoveryBaseToJSONTyped = DiscoveryBaseToJSONTyped;
exports.DsApi = DsApi;
exports.EmailConfigFromJSON = EmailConfigFromJSON;
exports.EmailConfigFromJSONTyped = EmailConfigFromJSONTyped;
exports.EmailConfigToJSON = EmailConfigToJSON;
exports.EmailConfigToJSONTyped = EmailConfigToJSONTyped;
exports.EmailDTOFromJSON = EmailDTOFromJSON;
exports.EmailDTOFromJSONTyped = EmailDTOFromJSONTyped;
exports.EmailDTOToJSON = EmailDTOToJSON;
exports.EmailDTOToJSONTyped = EmailDTOToJSONTyped;
exports.EmbeddedContactPointFromJSON = EmbeddedContactPointFromJSON;
exports.EmbeddedContactPointFromJSONTyped = EmbeddedContactPointFromJSONTyped;
exports.EmbeddedContactPointToJSON = EmbeddedContactPointToJSON;
exports.EmbeddedContactPointToJSONTyped = EmbeddedContactPointToJSONTyped;
exports.EmbeddedContactPointTypeEnum = EmbeddedContactPointTypeEnum;
exports.EnterpriseApi = EnterpriseApi;
exports.EnumFieldConfigFromJSON = EnumFieldConfigFromJSON;
exports.EnumFieldConfigFromJSONTyped = EnumFieldConfigFromJSONTyped;
exports.EnumFieldConfigToJSON = EnumFieldConfigToJSON;
exports.EnumFieldConfigToJSONTyped = EnumFieldConfigToJSONTyped;
exports.ErrorResponseBodyFromJSON = ErrorResponseBodyFromJSON;
exports.ErrorResponseBodyFromJSONTyped = ErrorResponseBodyFromJSONTyped;
exports.ErrorResponseBodyToJSON = ErrorResponseBodyToJSON;
exports.ErrorResponseBodyToJSONTyped = ErrorResponseBodyToJSONTyped;
exports.EvalAlertConditionCommandFromJSON = EvalAlertConditionCommandFromJSON;
exports.EvalAlertConditionCommandFromJSONTyped = EvalAlertConditionCommandFromJSONTyped;
exports.EvalAlertConditionCommandToJSON = EvalAlertConditionCommandToJSON;
exports.EvalAlertConditionCommandToJSONTyped = EvalAlertConditionCommandToJSONTyped;
exports.EvalQueriesPayloadFromJSON = EvalQueriesPayloadFromJSON;
exports.EvalQueriesPayloadFromJSONTyped = EvalQueriesPayloadFromJSONTyped;
exports.EvalQueriesPayloadToJSON = EvalQueriesPayloadToJSON;
exports.EvalQueriesPayloadToJSONTyped = EvalQueriesPayloadToJSONTyped;
exports.ExtendedReceiverFromJSON = ExtendedReceiverFromJSON;
exports.ExtendedReceiverFromJSONTyped = ExtendedReceiverFromJSONTyped;
exports.ExtendedReceiverToJSON = ExtendedReceiverToJSON;
exports.ExtendedReceiverToJSONTyped = ExtendedReceiverToJSONTyped;
exports.ExtensionFromJSON = ExtensionFromJSON;
exports.ExtensionFromJSONTyped = ExtensionFromJSONTyped;
exports.ExtensionToJSON = ExtensionToJSON;
exports.ExtensionToJSONTyped = ExtensionToJSONTyped;
exports.FailedUserFromJSON = FailedUserFromJSON;
exports.FailedUserFromJSONTyped = FailedUserFromJSONTyped;
exports.FailedUserToJSON = FailedUserToJSON;
exports.FailedUserToJSONTyped = FailedUserToJSONTyped;
exports.FetchError = FetchError;
exports.FieldConfigFromJSON = FieldConfigFromJSON;
exports.FieldConfigFromJSONTyped = FieldConfigFromJSONTyped;
exports.FieldConfigToJSON = FieldConfigToJSON;
exports.FieldConfigToJSONTyped = FieldConfigToJSONTyped;
exports.FieldFromJSON = FieldFromJSON;
exports.FieldFromJSONTyped = FieldFromJSONTyped;
exports.FieldToJSON = FieldToJSON;
exports.FieldToJSONTyped = FieldToJSONTyped;
exports.FieldTypeConfigFromJSON = FieldTypeConfigFromJSON;
exports.FieldTypeConfigFromJSONTyped = FieldTypeConfigFromJSONTyped;
exports.FieldTypeConfigToJSON = FieldTypeConfigToJSON;
exports.FieldTypeConfigToJSONTyped = FieldTypeConfigToJSONTyped;
exports.FindTagsResultFromJSON = FindTagsResultFromJSON;
exports.FindTagsResultFromJSONTyped = FindTagsResultFromJSONTyped;
exports.FindTagsResultToJSON = FindTagsResultToJSON;
exports.FindTagsResultToJSONTyped = FindTagsResultToJSONTyped;
exports.FloatHistogramFromJSON = FloatHistogramFromJSON;
exports.FloatHistogramFromJSONTyped = FloatHistogramFromJSONTyped;
exports.FloatHistogramToJSON = FloatHistogramToJSON;
exports.FloatHistogramToJSONTyped = FloatHistogramToJSONTyped;
exports.FolderFromJSON = FolderFromJSON;
exports.FolderFromJSONTyped = FolderFromJSONTyped;
exports.FolderPermissionsApi = FolderPermissionsApi;
exports.FolderSearchHitFromJSON = FolderSearchHitFromJSON;
exports.FolderSearchHitFromJSONTyped = FolderSearchHitFromJSONTyped;
exports.FolderSearchHitToJSON = FolderSearchHitToJSON;
exports.FolderSearchHitToJSONTyped = FolderSearchHitToJSONTyped;
exports.FolderToJSON = FolderToJSON;
exports.FolderToJSONTyped = FolderToJSONTyped;
exports.FoldersApi = FoldersApi;
exports.ForbiddenErrorFromJSON = ForbiddenErrorFromJSON;
exports.ForbiddenErrorFromJSONTyped = ForbiddenErrorFromJSONTyped;
exports.ForbiddenErrorToJSON = ForbiddenErrorToJSON;
exports.ForbiddenErrorToJSONTyped = ForbiddenErrorToJSONTyped;
exports.FrameFromJSON = FrameFromJSON;
exports.FrameFromJSONTyped = FrameFromJSONTyped;
exports.FrameMetaFromJSON = FrameMetaFromJSON;
exports.FrameMetaFromJSONTyped = FrameMetaFromJSONTyped;
exports.FrameMetaToJSON = FrameMetaToJSON;
exports.FrameMetaToJSONTyped = FrameMetaToJSONTyped;
exports.FrameToJSON = FrameToJSON;
exports.FrameToJSONTyped = FrameToJSONTyped;
exports.GenericPublicErrorFromJSON = GenericPublicErrorFromJSON;
exports.GenericPublicErrorFromJSONTyped = GenericPublicErrorFromJSONTyped;
exports.GenericPublicErrorToJSON = GenericPublicErrorToJSON;
exports.GenericPublicErrorToJSONTyped = GenericPublicErrorToJSONTyped;
exports.GetAnnotationTagsResponseFromJSON = GetAnnotationTagsResponseFromJSON;
exports.GetAnnotationTagsResponseFromJSONTyped = GetAnnotationTagsResponseFromJSONTyped;
exports.GetAnnotationTagsResponseToJSON = GetAnnotationTagsResponseToJSON;
exports.GetAnnotationTagsResponseToJSONTyped = GetAnnotationTagsResponseToJSONTyped;
exports.GetAnnotationsTypeEnum = GetAnnotationsTypeEnum;
exports.GetCurrentOrgApi = GetCurrentOrgApi;
exports.GetDataSourceIdByName200ResponseFromJSON = GetDataSourceIdByName200ResponseFromJSON;
exports.GetDataSourceIdByName200ResponseFromJSONTyped = GetDataSourceIdByName200ResponseFromJSONTyped;
exports.GetDataSourceIdByName200ResponseToJSON = GetDataSourceIdByName200ResponseToJSON;
exports.GetDataSourceIdByName200ResponseToJSONTyped = GetDataSourceIdByName200ResponseToJSONTyped;
exports.GetFoldersPermissionEnum = GetFoldersPermissionEnum;
exports.GetHomeDashboardResponseFromJSON = GetHomeDashboardResponseFromJSON;
exports.GetHomeDashboardResponseFromJSONTyped = GetHomeDashboardResponseFromJSONTyped;
exports.GetHomeDashboardResponseToJSON = GetHomeDashboardResponseToJSON;
exports.GetHomeDashboardResponseToJSONTyped = GetHomeDashboardResponseToJSONTyped;
exports.GetLibraryElementsKindEnum = GetLibraryElementsKindEnum;
exports.GetLibraryElementsSortDirectionEnum = GetLibraryElementsSortDirectionEnum;
exports.GetSharingOptions200ResponseFromJSON = GetSharingOptions200ResponseFromJSON;
exports.GetSharingOptions200ResponseFromJSONTyped = GetSharingOptions200ResponseFromJSONTyped;
exports.GetSharingOptions200ResponseToJSON = GetSharingOptions200ResponseToJSON;
exports.GetSharingOptions200ResponseToJSONTyped = GetSharingOptions200ResponseToJSONTyped;
exports.GettableAlertFromJSON = GettableAlertFromJSON;
exports.GettableAlertFromJSONTyped = GettableAlertFromJSONTyped;
exports.GettableAlertToJSON = GettableAlertToJSON;
exports.GettableAlertToJSONTyped = GettableAlertToJSONTyped;
exports.GettableAlertmanagersFromJSON = GettableAlertmanagersFromJSON;
exports.GettableAlertmanagersFromJSONTyped = GettableAlertmanagersFromJSONTyped;
exports.GettableAlertmanagersToJSON = GettableAlertmanagersToJSON;
exports.GettableAlertmanagersToJSONTyped = GettableAlertmanagersToJSONTyped;
exports.GettableApiAlertingConfigFromJSON = GettableApiAlertingConfigFromJSON;
exports.GettableApiAlertingConfigFromJSONTyped = GettableApiAlertingConfigFromJSONTyped;
exports.GettableApiAlertingConfigToJSON = GettableApiAlertingConfigToJSON;
exports.GettableApiAlertingConfigToJSONTyped = GettableApiAlertingConfigToJSONTyped;
exports.GettableApiReceiverFromJSON = GettableApiReceiverFromJSON;
exports.GettableApiReceiverFromJSONTyped = GettableApiReceiverFromJSONTyped;
exports.GettableApiReceiverToJSON = GettableApiReceiverToJSON;
exports.GettableApiReceiverToJSONTyped = GettableApiReceiverToJSONTyped;
exports.GettableExtendedRuleNodeFromJSON = GettableExtendedRuleNodeFromJSON;
exports.GettableExtendedRuleNodeFromJSONTyped = GettableExtendedRuleNodeFromJSONTyped;
exports.GettableExtendedRuleNodeToJSON = GettableExtendedRuleNodeToJSON;
exports.GettableExtendedRuleNodeToJSONTyped = GettableExtendedRuleNodeToJSONTyped;
exports.GettableGrafanaReceiverFromJSON = GettableGrafanaReceiverFromJSON;
exports.GettableGrafanaReceiverFromJSONTyped = GettableGrafanaReceiverFromJSONTyped;
exports.GettableGrafanaReceiverToJSON = GettableGrafanaReceiverToJSON;
exports.GettableGrafanaReceiverToJSONTyped = GettableGrafanaReceiverToJSONTyped;
exports.GettableGrafanaReceiversFromJSON = GettableGrafanaReceiversFromJSON;
exports.GettableGrafanaReceiversFromJSONTyped = GettableGrafanaReceiversFromJSONTyped;
exports.GettableGrafanaReceiversToJSON = GettableGrafanaReceiversToJSON;
exports.GettableGrafanaReceiversToJSONTyped = GettableGrafanaReceiversToJSONTyped;
exports.GettableGrafanaRuleExecErrStateEnum = GettableGrafanaRuleExecErrStateEnum;
exports.GettableGrafanaRuleFromJSON = GettableGrafanaRuleFromJSON;
exports.GettableGrafanaRuleFromJSONTyped = GettableGrafanaRuleFromJSONTyped;
exports.GettableGrafanaRuleNoDataStateEnum = GettableGrafanaRuleNoDataStateEnum;
exports.GettableGrafanaRuleToJSON = GettableGrafanaRuleToJSON;
exports.GettableGrafanaRuleToJSONTyped = GettableGrafanaRuleToJSONTyped;
exports.GettableHistoricUserConfigFromJSON = GettableHistoricUserConfigFromJSON;
exports.GettableHistoricUserConfigFromJSONTyped = GettableHistoricUserConfigFromJSONTyped;
exports.GettableHistoricUserConfigToJSON = GettableHistoricUserConfigToJSON;
exports.GettableHistoricUserConfigToJSONTyped = GettableHistoricUserConfigToJSONTyped;
exports.GettableNGalertConfigAlertmanagersChoiceEnum = GettableNGalertConfigAlertmanagersChoiceEnum;
exports.GettableNGalertConfigFromJSON = GettableNGalertConfigFromJSON;
exports.GettableNGalertConfigFromJSONTyped = GettableNGalertConfigFromJSONTyped;
exports.GettableNGalertConfigToJSON = GettableNGalertConfigToJSON;
exports.GettableNGalertConfigToJSONTyped = GettableNGalertConfigToJSONTyped;
exports.GettableRuleGroupConfigFromJSON = GettableRuleGroupConfigFromJSON;
exports.GettableRuleGroupConfigFromJSONTyped = GettableRuleGroupConfigFromJSONTyped;
exports.GettableRuleGroupConfigToJSON = GettableRuleGroupConfigToJSON;
exports.GettableRuleGroupConfigToJSONTyped = GettableRuleGroupConfigToJSONTyped;
exports.GettableSilenceFromJSON = GettableSilenceFromJSON;
exports.GettableSilenceFromJSONTyped = GettableSilenceFromJSONTyped;
exports.GettableSilenceToJSON = GettableSilenceToJSON;
exports.GettableSilenceToJSONTyped = GettableSilenceToJSONTyped;
exports.GettableStatusFromJSON = GettableStatusFromJSON;
exports.GettableStatusFromJSONTyped = GettableStatusFromJSONTyped;
exports.GettableStatusToJSON = GettableStatusToJSON;
exports.GettableStatusToJSONTyped = GettableStatusToJSONTyped;
exports.GettableTimeIntervalsFromJSON = GettableTimeIntervalsFromJSON;
exports.GettableTimeIntervalsFromJSONTyped = GettableTimeIntervalsFromJSONTyped;
exports.GettableTimeIntervalsToJSON = GettableTimeIntervalsToJSON;
exports.GettableTimeIntervalsToJSONTyped = GettableTimeIntervalsToJSONTyped;
exports.GettableUserConfigFromJSON = GettableUserConfigFromJSON;
exports.GettableUserConfigFromJSONTyped = GettableUserConfigFromJSONTyped;
exports.GettableUserConfigToJSON = GettableUserConfigToJSON;
exports.GettableUserConfigToJSONTyped = GettableUserConfigToJSONTyped;
exports.GlobalConfigFromJSON = GlobalConfigFromJSON;
exports.GlobalConfigFromJSONTyped = GlobalConfigFromJSONTyped;
exports.GlobalConfigToJSON = GlobalConfigToJSON;
exports.GlobalConfigToJSONTyped = GlobalConfigToJSONTyped;
exports.HTTPClientConfigFromJSON = HTTPClientConfigFromJSON;
exports.HTTPClientConfigFromJSONTyped = HTTPClientConfigFromJSONTyped;
exports.HTTPClientConfigToJSON = HTTPClientConfigToJSON;
exports.HTTPClientConfigToJSONTyped = HTTPClientConfigToJSONTyped;
exports.HitFromJSON = HitFromJSON;
exports.HitFromJSONTyped = HitFromJSONTyped;
exports.HitToJSON = HitToJSON;
exports.HitToJSONTyped = HitToJSONTyped;
exports.HostPortFromJSON = HostPortFromJSON;
exports.HostPortFromJSONTyped = HostPortFromJSONTyped;
exports.HostPortToJSON = HostPortToJSON;
exports.HostPortToJSONTyped = HostPortToJSONTyped;
exports.IPNetFromJSON = IPNetFromJSON;
exports.IPNetFromJSONTyped = IPNetFromJSONTyped;
exports.IPNetToJSON = IPNetToJSON;
exports.IPNetToJSONTyped = IPNetToJSONTyped;
exports.ImportDashboardInputFromJSON = ImportDashboardInputFromJSON;
exports.ImportDashboardInputFromJSONTyped = ImportDashboardInputFromJSONTyped;
exports.ImportDashboardInputToJSON = ImportDashboardInputToJSON;
exports.ImportDashboardInputToJSONTyped = ImportDashboardInputToJSONTyped;
exports.ImportDashboardRequestFromJSON = ImportDashboardRequestFromJSON;
exports.ImportDashboardRequestFromJSONTyped = ImportDashboardRequestFromJSONTyped;
exports.ImportDashboardRequestToJSON = ImportDashboardRequestToJSON;
exports.ImportDashboardRequestToJSONTyped = ImportDashboardRequestToJSONTyped;
exports.ImportDashboardResponseFromJSON = ImportDashboardResponseFromJSON;
exports.ImportDashboardResponseFromJSONTyped = ImportDashboardResponseFromJSONTyped;
exports.ImportDashboardResponseToJSON = ImportDashboardResponseToJSON;
exports.ImportDashboardResponseToJSONTyped = ImportDashboardResponseToJSONTyped;
exports.InhibitRuleFromJSON = InhibitRuleFromJSON;
exports.InhibitRuleFromJSONTyped = InhibitRuleFromJSONTyped;
exports.InhibitRuleToJSON = InhibitRuleToJSON;
exports.InhibitRuleToJSONTyped = InhibitRuleToJSONTyped;
exports.IntegrationFromJSON = IntegrationFromJSON;
exports.IntegrationFromJSONTyped = IntegrationFromJSONTyped;
exports.IntegrationToJSON = IntegrationToJSON;
exports.IntegrationToJSONTyped = IntegrationToJSONTyped;
exports.InternalDataLinkFromJSON = InternalDataLinkFromJSON;
exports.InternalDataLinkFromJSONTyped = InternalDataLinkFromJSONTyped;
exports.InternalDataLinkToJSON = InternalDataLinkToJSON;
exports.InternalDataLinkToJSONTyped = InternalDataLinkToJSONTyped;
exports.JSONApiResponse = JSONApiResponse;
exports.JSONWebKeyFromJSON = JSONWebKeyFromJSON;
exports.JSONWebKeyFromJSONTyped = JSONWebKeyFromJSONTyped;
exports.JSONWebKeyToJSON = JSONWebKeyToJSON;
exports.JSONWebKeyToJSONTyped = JSONWebKeyToJSONTyped;
exports.LabelFromJSON = LabelFromJSON;
exports.LabelFromJSONTyped = LabelFromJSONTyped;
exports.LabelToJSON = LabelToJSON;
exports.LabelToJSONTyped = LabelToJSONTyped;
exports.LdapDebugApi = LdapDebugApi;
exports.LibraryElementArrayResponseFromJSON = LibraryElementArrayResponseFromJSON;
exports.LibraryElementArrayResponseFromJSONTyped = LibraryElementArrayResponseFromJSONTyped;
exports.LibraryElementArrayResponseToJSON = LibraryElementArrayResponseToJSON;
exports.LibraryElementArrayResponseToJSONTyped = LibraryElementArrayResponseToJSONTyped;
exports.LibraryElementConnectionDTOFromJSON = LibraryElementConnectionDTOFromJSON;
exports.LibraryElementConnectionDTOFromJSONTyped = LibraryElementConnectionDTOFromJSONTyped;
exports.LibraryElementConnectionDTOToJSON = LibraryElementConnectionDTOToJSON;
exports.LibraryElementConnectionDTOToJSONTyped = LibraryElementConnectionDTOToJSONTyped;
exports.LibraryElementConnectionsResponseFromJSON = LibraryElementConnectionsResponseFromJSON;
exports.LibraryElementConnectionsResponseFromJSONTyped = LibraryElementConnectionsResponseFromJSONTyped;
exports.LibraryElementConnectionsResponseToJSON = LibraryElementConnectionsResponseToJSON;
exports.LibraryElementConnectionsResponseToJSONTyped = LibraryElementConnectionsResponseToJSONTyped;
exports.LibraryElementDTOFromJSON = LibraryElementDTOFromJSON;
exports.LibraryElementDTOFromJSONTyped = LibraryElementDTOFromJSONTyped;
exports.LibraryElementDTOMetaFromJSON = LibraryElementDTOMetaFromJSON;
exports.LibraryElementDTOMetaFromJSONTyped = LibraryElementDTOMetaFromJSONTyped;
exports.LibraryElementDTOMetaToJSON = LibraryElementDTOMetaToJSON;
exports.LibraryElementDTOMetaToJSONTyped = LibraryElementDTOMetaToJSONTyped;
exports.LibraryElementDTOMetaUserFromJSON = LibraryElementDTOMetaUserFromJSON;
exports.LibraryElementDTOMetaUserFromJSONTyped = LibraryElementDTOMetaUserFromJSONTyped;
exports.LibraryElementDTOMetaUserToJSON = LibraryElementDTOMetaUserToJSON;
exports.LibraryElementDTOMetaUserToJSONTyped = LibraryElementDTOMetaUserToJSONTyped;
exports.LibraryElementDTOToJSON = LibraryElementDTOToJSON;
exports.LibraryElementDTOToJSONTyped = LibraryElementDTOToJSONTyped;
exports.LibraryElementResponseFromJSON = LibraryElementResponseFromJSON;
exports.LibraryElementResponseFromJSONTyped = LibraryElementResponseFromJSONTyped;
exports.LibraryElementResponseToJSON = LibraryElementResponseToJSON;
exports.LibraryElementResponseToJSONTyped = LibraryElementResponseToJSONTyped;
exports.LibraryElementSearchResponseFromJSON = LibraryElementSearchResponseFromJSON;
exports.LibraryElementSearchResponseFromJSONTyped = LibraryElementSearchResponseFromJSONTyped;
exports.LibraryElementSearchResponseToJSON = LibraryElementSearchResponseToJSON;
exports.LibraryElementSearchResponseToJSONTyped = LibraryElementSearchResponseToJSONTyped;
exports.LibraryElementSearchResultFromJSON = LibraryElementSearchResultFromJSON;
exports.LibraryElementSearchResultFromJSONTyped = LibraryElementSearchResultFromJSONTyped;
exports.LibraryElementSearchResultToJSON = LibraryElementSearchResultToJSON;
exports.LibraryElementSearchResultToJSONTyped = LibraryElementSearchResultToJSONTyped;
exports.LibraryElementsApi = LibraryElementsApi;
exports.LicensingApi = LicensingApi;
exports.LinkTransformationConfigFromJSON = LinkTransformationConfigFromJSON;
exports.LinkTransformationConfigFromJSONTyped = LinkTransformationConfigFromJSONTyped;
exports.LinkTransformationConfigToJSON = LinkTransformationConfigToJSON;
exports.LinkTransformationConfigToJSONTyped = LinkTransformationConfigToJSONTyped;
exports.ListAllProvidersSettings200ResponseInnerFromJSON = ListAllProvidersSettings200ResponseInnerFromJSON;
exports.ListAllProvidersSettings200ResponseInnerFromJSONTyped = ListAllProvidersSettings200ResponseInnerFromJSONTyped;
exports.ListAllProvidersSettings200ResponseInnerToJSON = ListAllProvidersSettings200ResponseInnerToJSON;
exports.ListAllProvidersSettings200ResponseInnerToJSONTyped = ListAllProvidersSettings200ResponseInnerToJSONTyped;
exports.ListSortOptions200ResponseFromJSON = ListSortOptions200ResponseFromJSON;
exports.ListSortOptions200ResponseFromJSONTyped = ListSortOptions200ResponseFromJSONTyped;
exports.ListSortOptions200ResponseToJSON = ListSortOptions200ResponseToJSON;
exports.ListSortOptions200ResponseToJSONTyped = ListSortOptions200ResponseToJSONTyped;
exports.MSTeamsConfigFromJSON = MSTeamsConfigFromJSON;
exports.MSTeamsConfigFromJSONTyped = MSTeamsConfigFromJSONTyped;
exports.MSTeamsConfigToJSON = MSTeamsConfigToJSON;
exports.MSTeamsConfigToJSONTyped = MSTeamsConfigToJSONTyped;
exports.MassDeleteAnnotationsCmdFromJSON = MassDeleteAnnotationsCmdFromJSON;
exports.MassDeleteAnnotationsCmdFromJSONTyped = MassDeleteAnnotationsCmdFromJSONTyped;
exports.MassDeleteAnnotationsCmdToJSON = MassDeleteAnnotationsCmdToJSON;
exports.MassDeleteAnnotationsCmdToJSONTyped = MassDeleteAnnotationsCmdToJSONTyped;
exports.MatcherFromJSON = MatcherFromJSON;
exports.MatcherFromJSONTyped = MatcherFromJSONTyped;
exports.MatcherToJSON = MatcherToJSON;
exports.MatcherToJSONTyped = MatcherToJSONTyped;
exports.MetricRequestFromJSON = MetricRequestFromJSON;
exports.MetricRequestFromJSONTyped = MetricRequestFromJSONTyped;
exports.MetricRequestToJSON = MetricRequestToJSON;
exports.MetricRequestToJSONTyped = MetricRequestToJSONTyped;
exports.MoveFolderCommandFromJSON = MoveFolderCommandFromJSON;
exports.MoveFolderCommandFromJSONTyped = MoveFolderCommandFromJSONTyped;
exports.MoveFolderCommandToJSON = MoveFolderCommandToJSON;
exports.MoveFolderCommandToJSONTyped = MoveFolderCommandToJSONTyped;
exports.MuteTimeIntervalExportFromJSON = MuteTimeIntervalExportFromJSON;
exports.MuteTimeIntervalExportFromJSONTyped = MuteTimeIntervalExportFromJSONTyped;
exports.MuteTimeIntervalExportToJSON = MuteTimeIntervalExportToJSON;
exports.MuteTimeIntervalExportToJSONTyped = MuteTimeIntervalExportToJSONTyped;
exports.MuteTimeIntervalFromJSON = MuteTimeIntervalFromJSON;
exports.MuteTimeIntervalFromJSONTyped = MuteTimeIntervalFromJSONTyped;
exports.MuteTimeIntervalToJSON = MuteTimeIntervalToJSON;
exports.MuteTimeIntervalToJSONTyped = MuteTimeIntervalToJSONTyped;
exports.NameFromJSON = NameFromJSON;
exports.NameFromJSONTyped = NameFromJSONTyped;
exports.NameToJSON = NameToJSON;
exports.NameToJSONTyped = NameToJSONTyped;
exports.NewApiKeyResultFromJSON = NewApiKeyResultFromJSON;
exports.NewApiKeyResultFromJSONTyped = NewApiKeyResultFromJSONTyped;
exports.NewApiKeyResultToJSON = NewApiKeyResultToJSON;
exports.NewApiKeyResultToJSONTyped = NewApiKeyResultToJSONTyped;
exports.NoticeFromJSON = NoticeFromJSON;
exports.NoticeFromJSONTyped = NoticeFromJSONTyped;
exports.NoticeToJSON = NoticeToJSON;
exports.NoticeToJSONTyped = NoticeToJSONTyped;
exports.NotificationPolicyExportFromJSON = NotificationPolicyExportFromJSON;
exports.NotificationPolicyExportFromJSONTyped = NotificationPolicyExportFromJSONTyped;
exports.NotificationPolicyExportToJSON = NotificationPolicyExportToJSON;
exports.NotificationPolicyExportToJSONTyped = NotificationPolicyExportToJSONTyped;
exports.NotificationTemplateContentFromJSON = NotificationTemplateContentFromJSON;
exports.NotificationTemplateContentFromJSONTyped = NotificationTemplateContentFromJSONTyped;
exports.NotificationTemplateContentToJSON = NotificationTemplateContentToJSON;
exports.NotificationTemplateContentToJSONTyped = NotificationTemplateContentToJSONTyped;
exports.NotificationTemplateFromJSON = NotificationTemplateFromJSON;
exports.NotificationTemplateFromJSONTyped = NotificationTemplateFromJSONTyped;
exports.NotificationTemplateToJSON = NotificationTemplateToJSON;
exports.NotificationTemplateToJSONTyped = NotificationTemplateToJSONTyped;
exports.NotifierConfigFromJSON = NotifierConfigFromJSON;
exports.NotifierConfigFromJSONTyped = NotifierConfigFromJSONTyped;
exports.NotifierConfigToJSON = NotifierConfigToJSON;
exports.NotifierConfigToJSONTyped = NotifierConfigToJSONTyped;
exports.OAuth2FromJSON = OAuth2FromJSON;
exports.OAuth2FromJSONTyped = OAuth2FromJSONTyped;
exports.OAuth2ToJSON = OAuth2ToJSON;
exports.OAuth2ToJSONTyped = OAuth2ToJSONTyped;
exports.OpsGenieConfigFromJSON = OpsGenieConfigFromJSON;
exports.OpsGenieConfigFromJSONTyped = OpsGenieConfigFromJSONTyped;
exports.OpsGenieConfigResponderFromJSON = OpsGenieConfigResponderFromJSON;
exports.OpsGenieConfigResponderFromJSONTyped = OpsGenieConfigResponderFromJSONTyped;
exports.OpsGenieConfigResponderToJSON = OpsGenieConfigResponderToJSON;
exports.OpsGenieConfigResponderToJSONTyped = OpsGenieConfigResponderToJSONTyped;
exports.OpsGenieConfigToJSON = OpsGenieConfigToJSON;
exports.OpsGenieConfigToJSONTyped = OpsGenieConfigToJSONTyped;
exports.OrgApi = OrgApi;
exports.OrgDTOFromJSON = OrgDTOFromJSON;
exports.OrgDTOFromJSONTyped = OrgDTOFromJSONTyped;
exports.OrgDTOToJSON = OrgDTOToJSON;
exports.OrgDTOToJSONTyped = OrgDTOToJSONTyped;
exports.OrgDetailsDTOFromJSON = OrgDetailsDTOFromJSON;
exports.OrgDetailsDTOFromJSONTyped = OrgDetailsDTOFromJSONTyped;
exports.OrgDetailsDTOToJSON = OrgDetailsDTOToJSON;
exports.OrgDetailsDTOToJSONTyped = OrgDetailsDTOToJSONTyped;
exports.OrgInvitesApi = OrgInvitesApi;
exports.OrgPreferencesApi = OrgPreferencesApi;
exports.OrgUserDTOFromJSON = OrgUserDTOFromJSON;
exports.OrgUserDTOFromJSONTyped = OrgUserDTOFromJSONTyped;
exports.OrgUserDTOToJSON = OrgUserDTOToJSON;
exports.OrgUserDTOToJSONTyped = OrgUserDTOToJSONTyped;
exports.OrgsApi = OrgsApi;
exports.PagerdutyConfigFromJSON = PagerdutyConfigFromJSON;
exports.PagerdutyConfigFromJSONTyped = PagerdutyConfigFromJSONTyped;
exports.PagerdutyConfigToJSON = PagerdutyConfigToJSON;
exports.PagerdutyConfigToJSONTyped = PagerdutyConfigToJSONTyped;
exports.PagerdutyImageFromJSON = PagerdutyImageFromJSON;
exports.PagerdutyImageFromJSONTyped = PagerdutyImageFromJSONTyped;
exports.PagerdutyImageToJSON = PagerdutyImageToJSON;
exports.PagerdutyImageToJSONTyped = PagerdutyImageToJSONTyped;
exports.PagerdutyLinkFromJSON = PagerdutyLinkFromJSON;
exports.PagerdutyLinkFromJSONTyped = PagerdutyLinkFromJSONTyped;
exports.PagerdutyLinkToJSON = PagerdutyLinkToJSON;
exports.PagerdutyLinkToJSONTyped = PagerdutyLinkToJSONTyped;
exports.PatchAnnotationsCmdFromJSON = PatchAnnotationsCmdFromJSON;
exports.PatchAnnotationsCmdFromJSONTyped = PatchAnnotationsCmdFromJSONTyped;
exports.PatchAnnotationsCmdToJSON = PatchAnnotationsCmdToJSON;
exports.PatchAnnotationsCmdToJSONTyped = PatchAnnotationsCmdToJSONTyped;
exports.PatchLibraryElementCommandFromJSON = PatchLibraryElementCommandFromJSON;
exports.PatchLibraryElementCommandFromJSONTyped = PatchLibraryElementCommandFromJSONTyped;
exports.PatchLibraryElementCommandKindEnum = PatchLibraryElementCommandKindEnum;
exports.PatchLibraryElementCommandToJSON = PatchLibraryElementCommandToJSON;
exports.PatchLibraryElementCommandToJSONTyped = PatchLibraryElementCommandToJSONTyped;
exports.PatchPrefsCmdFromJSON = PatchPrefsCmdFromJSON;
exports.PatchPrefsCmdFromJSONTyped = PatchPrefsCmdFromJSONTyped;
exports.PatchPrefsCmdThemeEnum = PatchPrefsCmdThemeEnum;
exports.PatchPrefsCmdTimezoneEnum = PatchPrefsCmdTimezoneEnum;
exports.PatchPrefsCmdToJSON = PatchPrefsCmdToJSON;
exports.PatchPrefsCmdToJSONTyped = PatchPrefsCmdToJSONTyped;
exports.PatchQueryCommentInQueryHistoryCommandFromJSON = PatchQueryCommentInQueryHistoryCommandFromJSON;
exports.PatchQueryCommentInQueryHistoryCommandFromJSONTyped = PatchQueryCommentInQueryHistoryCommandFromJSONTyped;
exports.PatchQueryCommentInQueryHistoryCommandToJSON = PatchQueryCommentInQueryHistoryCommandToJSON;
exports.PatchQueryCommentInQueryHistoryCommandToJSONTyped = PatchQueryCommentInQueryHistoryCommandToJSONTyped;
exports.PeerStatusFromJSON = PeerStatusFromJSON;
exports.PeerStatusFromJSONTyped = PeerStatusFromJSONTyped;
exports.PeerStatusToJSON = PeerStatusToJSON;
exports.PeerStatusToJSONTyped = PeerStatusToJSONTyped;
exports.PermissionFromJSON = PermissionFromJSON;
exports.PermissionFromJSONTyped = PermissionFromJSONTyped;
exports.PermissionToJSON = PermissionToJSON;
exports.PermissionToJSONTyped = PermissionToJSONTyped;
exports.PlaylistDTOFromJSON = PlaylistDTOFromJSON;
exports.PlaylistDTOFromJSONTyped = PlaylistDTOFromJSONTyped;
exports.PlaylistDTOToJSON = PlaylistDTOToJSON;
exports.PlaylistDTOToJSONTyped = PlaylistDTOToJSONTyped;
exports.PlaylistDashboardFromJSON = PlaylistDashboardFromJSON;
exports.PlaylistDashboardFromJSONTyped = PlaylistDashboardFromJSONTyped;
exports.PlaylistDashboardToJSON = PlaylistDashboardToJSON;
exports.PlaylistDashboardToJSONTyped = PlaylistDashboardToJSONTyped;
exports.PlaylistFromJSON = PlaylistFromJSON;
exports.PlaylistFromJSONTyped = PlaylistFromJSONTyped;
exports.PlaylistItemDTOFromJSON = PlaylistItemDTOFromJSON;
exports.PlaylistItemDTOFromJSONTyped = PlaylistItemDTOFromJSONTyped;
exports.PlaylistItemDTOToJSON = PlaylistItemDTOToJSON;
exports.PlaylistItemDTOToJSONTyped = PlaylistItemDTOToJSONTyped;
exports.PlaylistItemFromJSON = PlaylistItemFromJSON;
exports.PlaylistItemFromJSONTyped = PlaylistItemFromJSONTyped;
exports.PlaylistItemToJSON = PlaylistItemToJSON;
exports.PlaylistItemToJSONTyped = PlaylistItemToJSONTyped;
exports.PlaylistToJSON = PlaylistToJSON;
exports.PlaylistToJSONTyped = PlaylistToJSONTyped;
exports.PlaylistsApi = PlaylistsApi;
exports.PostAnnotation200ResponseFromJSON = PostAnnotation200ResponseFromJSON;
exports.PostAnnotation200ResponseFromJSONTyped = PostAnnotation200ResponseFromJSONTyped;
exports.PostAnnotation200ResponseToJSON = PostAnnotation200ResponseToJSON;
exports.PostAnnotation200ResponseToJSONTyped = PostAnnotation200ResponseToJSONTyped;
exports.PostAnnotationsCmdFromJSON = PostAnnotationsCmdFromJSON;
exports.PostAnnotationsCmdFromJSONTyped = PostAnnotationsCmdFromJSONTyped;
exports.PostAnnotationsCmdToJSON = PostAnnotationsCmdToJSON;
exports.PostAnnotationsCmdToJSONTyped = PostAnnotationsCmdToJSONTyped;
exports.PostDashboard200ResponseFromJSON = PostDashboard200ResponseFromJSON;
exports.PostDashboard200ResponseFromJSONTyped = PostDashboard200ResponseFromJSONTyped;
exports.PostDashboard200ResponseToJSON = PostDashboard200ResponseToJSON;
exports.PostDashboard200ResponseToJSONTyped = PostDashboard200ResponseToJSONTyped;
exports.PostGraphiteAnnotationsCmdFromJSON = PostGraphiteAnnotationsCmdFromJSON;
exports.PostGraphiteAnnotationsCmdFromJSONTyped = PostGraphiteAnnotationsCmdFromJSONTyped;
exports.PostGraphiteAnnotationsCmdToJSON = PostGraphiteAnnotationsCmdToJSON;
exports.PostGraphiteAnnotationsCmdToJSONTyped = PostGraphiteAnnotationsCmdToJSONTyped;
exports.PostSilencesOKBodyFromJSON = PostSilencesOKBodyFromJSON;
exports.PostSilencesOKBodyFromJSONTyped = PostSilencesOKBodyFromJSONTyped;
exports.PostSilencesOKBodyToJSON = PostSilencesOKBodyToJSON;
exports.PostSilencesOKBodyToJSONTyped = PostSilencesOKBodyToJSONTyped;
exports.PostableAlertFromJSON = PostableAlertFromJSON;
exports.PostableAlertFromJSONTyped = PostableAlertFromJSONTyped;
exports.PostableAlertToJSON = PostableAlertToJSON;
exports.PostableAlertToJSONTyped = PostableAlertToJSONTyped;
exports.PostableApiAlertingConfigFromJSON = PostableApiAlertingConfigFromJSON;
exports.PostableApiAlertingConfigFromJSONTyped = PostableApiAlertingConfigFromJSONTyped;
exports.PostableApiAlertingConfigToJSON = PostableApiAlertingConfigToJSON;
exports.PostableApiAlertingConfigToJSONTyped = PostableApiAlertingConfigToJSONTyped;
exports.PostableApiReceiverFromJSON = PostableApiReceiverFromJSON;
exports.PostableApiReceiverFromJSONTyped = PostableApiReceiverFromJSONTyped;
exports.PostableApiReceiverToJSON = PostableApiReceiverToJSON;
exports.PostableApiReceiverToJSONTyped = PostableApiReceiverToJSONTyped;
exports.PostableExtendedRuleNodeExtendedFromJSON = PostableExtendedRuleNodeExtendedFromJSON;
exports.PostableExtendedRuleNodeExtendedFromJSONTyped = PostableExtendedRuleNodeExtendedFromJSONTyped;
exports.PostableExtendedRuleNodeExtendedToJSON = PostableExtendedRuleNodeExtendedToJSON;
exports.PostableExtendedRuleNodeExtendedToJSONTyped = PostableExtendedRuleNodeExtendedToJSONTyped;
exports.PostableExtendedRuleNodeFromJSON = PostableExtendedRuleNodeFromJSON;
exports.PostableExtendedRuleNodeFromJSONTyped = PostableExtendedRuleNodeFromJSONTyped;
exports.PostableExtendedRuleNodeToJSON = PostableExtendedRuleNodeToJSON;
exports.PostableExtendedRuleNodeToJSONTyped = PostableExtendedRuleNodeToJSONTyped;
exports.PostableGrafanaReceiverFromJSON = PostableGrafanaReceiverFromJSON;
exports.PostableGrafanaReceiverFromJSONTyped = PostableGrafanaReceiverFromJSONTyped;
exports.PostableGrafanaReceiverToJSON = PostableGrafanaReceiverToJSON;
exports.PostableGrafanaReceiverToJSONTyped = PostableGrafanaReceiverToJSONTyped;
exports.PostableGrafanaReceiversFromJSON = PostableGrafanaReceiversFromJSON;
exports.PostableGrafanaReceiversFromJSONTyped = PostableGrafanaReceiversFromJSONTyped;
exports.PostableGrafanaReceiversToJSON = PostableGrafanaReceiversToJSON;
exports.PostableGrafanaReceiversToJSONTyped = PostableGrafanaReceiversToJSONTyped;
exports.PostableGrafanaRuleExecErrStateEnum = PostableGrafanaRuleExecErrStateEnum;
exports.PostableGrafanaRuleFromJSON = PostableGrafanaRuleFromJSON;
exports.PostableGrafanaRuleFromJSONTyped = PostableGrafanaRuleFromJSONTyped;
exports.PostableGrafanaRuleNoDataStateEnum = PostableGrafanaRuleNoDataStateEnum;
exports.PostableGrafanaRuleToJSON = PostableGrafanaRuleToJSON;
exports.PostableGrafanaRuleToJSONTyped = PostableGrafanaRuleToJSONTyped;
exports.PostableNGalertConfigAlertmanagersChoiceEnum = PostableNGalertConfigAlertmanagersChoiceEnum;
exports.PostableNGalertConfigFromJSON = PostableNGalertConfigFromJSON;
exports.PostableNGalertConfigFromJSONTyped = PostableNGalertConfigFromJSONTyped;
exports.PostableNGalertConfigToJSON = PostableNGalertConfigToJSON;
exports.PostableNGalertConfigToJSONTyped = PostableNGalertConfigToJSONTyped;
exports.PostableRuleGroupConfigFromJSON = PostableRuleGroupConfigFromJSON;
exports.PostableRuleGroupConfigFromJSONTyped = PostableRuleGroupConfigFromJSONTyped;
exports.PostableRuleGroupConfigToJSON = PostableRuleGroupConfigToJSON;
exports.PostableRuleGroupConfigToJSONTyped = PostableRuleGroupConfigToJSONTyped;
exports.PostableSilenceFromJSON = PostableSilenceFromJSON;
exports.PostableSilenceFromJSONTyped = PostableSilenceFromJSONTyped;
exports.PostableSilenceToJSON = PostableSilenceToJSON;
exports.PostableSilenceToJSONTyped = PostableSilenceToJSONTyped;
exports.PostableTimeIntervalsFromJSON = PostableTimeIntervalsFromJSON;
exports.PostableTimeIntervalsFromJSONTyped = PostableTimeIntervalsFromJSONTyped;
exports.PostableTimeIntervalsToJSON = PostableTimeIntervalsToJSON;
exports.PostableTimeIntervalsToJSONTyped = PostableTimeIntervalsToJSONTyped;
exports.PostableUserConfigFromJSON = PostableUserConfigFromJSON;
exports.PostableUserConfigFromJSONTyped = PostableUserConfigFromJSONTyped;
exports.PostableUserConfigToJSON = PostableUserConfigToJSON;
exports.PostableUserConfigToJSONTyped = PostableUserConfigToJSONTyped;
exports.PreferencesFromJSON = PreferencesFromJSON;
exports.PreferencesFromJSONTyped = PreferencesFromJSONTyped;
exports.PreferencesToJSON = PreferencesToJSON;
exports.PreferencesToJSONTyped = PreferencesToJSONTyped;
exports.PrometheusRemoteWriteTargetJSONFromJSON = PrometheusRemoteWriteTargetJSONFromJSON;
exports.PrometheusRemoteWriteTargetJSONFromJSONTyped = PrometheusRemoteWriteTargetJSONFromJSONTyped;
exports.PrometheusRemoteWriteTargetJSONToJSON = PrometheusRemoteWriteTargetJSONToJSON;
exports.PrometheusRemoteWriteTargetJSONToJSONTyped = PrometheusRemoteWriteTargetJSONToJSONTyped;
exports.ProvisionedAlertRuleExecErrStateEnum = ProvisionedAlertRuleExecErrStateEnum;
exports.ProvisionedAlertRuleFromJSON = ProvisionedAlertRuleFromJSON;
exports.ProvisionedAlertRuleFromJSONTyped = ProvisionedAlertRuleFromJSONTyped;
exports.ProvisionedAlertRuleNoDataStateEnum = ProvisionedAlertRuleNoDataStateEnum;
exports.ProvisionedAlertRuleToJSON = ProvisionedAlertRuleToJSON;
exports.ProvisionedAlertRuleToJSONTyped = ProvisionedAlertRuleToJSONTyped;
exports.ProvisioningApi = ProvisioningApi;
exports.ProxyConfigFromJSON = ProxyConfigFromJSON;
exports.ProxyConfigFromJSONTyped = ProxyConfigFromJSONTyped;
exports.ProxyConfigToJSON = ProxyConfigToJSON;
exports.ProxyConfigToJSONTyped = ProxyConfigToJSONTyped;
exports.PublicDashboardDTOFromJSON = PublicDashboardDTOFromJSON;
exports.PublicDashboardDTOFromJSONTyped = PublicDashboardDTOFromJSONTyped;
exports.PublicDashboardDTOToJSON = PublicDashboardDTOToJSON;
exports.PublicDashboardDTOToJSONTyped = PublicDashboardDTOToJSONTyped;
exports.PublicDashboardFromJSON = PublicDashboardFromJSON;
exports.PublicDashboardFromJSONTyped = PublicDashboardFromJSONTyped;
exports.PublicDashboardListResponseFromJSON = PublicDashboardListResponseFromJSON;
exports.PublicDashboardListResponseFromJSONTyped = PublicDashboardListResponseFromJSONTyped;
exports.PublicDashboardListResponseToJSON = PublicDashboardListResponseToJSON;
exports.PublicDashboardListResponseToJSONTyped = PublicDashboardListResponseToJSONTyped;
exports.PublicDashboardListResponseWithPaginationFromJSON = PublicDashboardListResponseWithPaginationFromJSON;
exports.PublicDashboardListResponseWithPaginationFromJSONTyped = PublicDashboardListResponseWithPaginationFromJSONTyped;
exports.PublicDashboardListResponseWithPaginationToJSON = PublicDashboardListResponseWithPaginationToJSON;
exports.PublicDashboardListResponseWithPaginationToJSONTyped = PublicDashboardListResponseWithPaginationToJSONTyped;
exports.PublicDashboardToJSON = PublicDashboardToJSON;
exports.PublicDashboardToJSONTyped = PublicDashboardToJSONTyped;
exports.PublicErrorFromJSON = PublicErrorFromJSON;
exports.PublicErrorFromJSONTyped = PublicErrorFromJSONTyped;
exports.PublicErrorToJSON = PublicErrorToJSON;
exports.PublicErrorToJSONTyped = PublicErrorToJSONTyped;
exports.PushoverConfigFromJSON = PushoverConfigFromJSON;
exports.PushoverConfigFromJSONTyped = PushoverConfigFromJSONTyped;
exports.PushoverConfigToJSON = PushoverConfigToJSON;
exports.PushoverConfigToJSONTyped = PushoverConfigToJSONTyped;
exports.QueryDataResponseFromJSON = QueryDataResponseFromJSON;
exports.QueryDataResponseFromJSONTyped = QueryDataResponseFromJSONTyped;
exports.QueryDataResponseToJSON = QueryDataResponseToJSON;
exports.QueryDataResponseToJSONTyped = QueryDataResponseToJSONTyped;
exports.QueryHistoryApi = QueryHistoryApi;
exports.QueryHistoryDTOFromJSON = QueryHistoryDTOFromJSON;
exports.QueryHistoryDTOFromJSONTyped = QueryHistoryDTOFromJSONTyped;
exports.QueryHistoryDTOToJSON = QueryHistoryDTOToJSON;
exports.QueryHistoryDTOToJSONTyped = QueryHistoryDTOToJSONTyped;
exports.QueryHistoryDeleteQueryResponseFromJSON = QueryHistoryDeleteQueryResponseFromJSON;
exports.QueryHistoryDeleteQueryResponseFromJSONTyped = QueryHistoryDeleteQueryResponseFromJSONTyped;
exports.QueryHistoryDeleteQueryResponseToJSON = QueryHistoryDeleteQueryResponseToJSON;
exports.QueryHistoryDeleteQueryResponseToJSONTyped = QueryHistoryDeleteQueryResponseToJSONTyped;
exports.QueryHistoryPreferenceFromJSON = QueryHistoryPreferenceFromJSON;
exports.QueryHistoryPreferenceFromJSONTyped = QueryHistoryPreferenceFromJSONTyped;
exports.QueryHistoryPreferenceToJSON = QueryHistoryPreferenceToJSON;
exports.QueryHistoryPreferenceToJSONTyped = QueryHistoryPreferenceToJSONTyped;
exports.QueryHistoryResponseFromJSON = QueryHistoryResponseFromJSON;
exports.QueryHistoryResponseFromJSONTyped = QueryHistoryResponseFromJSONTyped;
exports.QueryHistoryResponseToJSON = QueryHistoryResponseToJSON;
exports.QueryHistoryResponseToJSONTyped = QueryHistoryResponseToJSONTyped;
exports.QueryHistorySearchResponseFromJSON = QueryHistorySearchResponseFromJSON;
exports.QueryHistorySearchResponseFromJSONTyped = QueryHistorySearchResponseFromJSONTyped;
exports.QueryHistorySearchResponseToJSON = QueryHistorySearchResponseToJSON;
exports.QueryHistorySearchResponseToJSONTyped = QueryHistorySearchResponseToJSONTyped;
exports.QueryHistorySearchResultFromJSON = QueryHistorySearchResultFromJSON;
exports.QueryHistorySearchResultFromJSONTyped = QueryHistorySearchResultFromJSONTyped;
exports.QueryHistorySearchResultToJSON = QueryHistorySearchResultToJSON;
exports.QueryHistorySearchResultToJSONTyped = QueryHistorySearchResultToJSONTyped;
exports.QueryStatFromJSON = QueryStatFromJSON;
exports.QueryStatFromJSONTyped = QueryStatFromJSONTyped;
exports.QueryStatToJSON = QueryStatToJSON;
exports.QueryStatToJSONTyped = QueryStatToJSONTyped;
exports.QuotaDTOFromJSON = QuotaDTOFromJSON;
exports.QuotaDTOFromJSONTyped = QuotaDTOFromJSONTyped;
exports.QuotaDTOToJSON = QuotaDTOToJSON;
exports.QuotaDTOToJSONTyped = QuotaDTOToJSONTyped;
exports.ReceiverExportFromJSON = ReceiverExportFromJSON;
exports.ReceiverExportFromJSONTyped = ReceiverExportFromJSONTyped;
exports.ReceiverExportToJSON = ReceiverExportToJSON;
exports.ReceiverExportToJSONTyped = ReceiverExportToJSONTyped;
exports.ReceiverFromJSON = ReceiverFromJSON;
exports.ReceiverFromJSONTyped = ReceiverFromJSONTyped;
exports.ReceiverToJSON = ReceiverToJSON;
exports.ReceiverToJSONTyped = ReceiverToJSONTyped;
exports.RecordingRuleJSONFromJSON = RecordingRuleJSONFromJSON;
exports.RecordingRuleJSONFromJSONTyped = RecordingRuleJSONFromJSONTyped;
exports.RecordingRuleJSONToJSON = RecordingRuleJSONToJSON;
exports.RecordingRuleJSONToJSONTyped = RecordingRuleJSONToJSONTyped;
exports.RecordingRulesApi = RecordingRulesApi;
exports.RelativeTimeRangeExportFromJSON = RelativeTimeRangeExportFromJSON;
exports.RelativeTimeRangeExportFromJSONTyped = RelativeTimeRangeExportFromJSONTyped;
exports.RelativeTimeRangeExportToJSON = RelativeTimeRangeExportToJSON;
exports.RelativeTimeRangeExportToJSONTyped = RelativeTimeRangeExportToJSONTyped;
exports.RelativeTimeRangeFromJSON = RelativeTimeRangeFromJSON;
exports.RelativeTimeRangeFromJSONTyped = RelativeTimeRangeFromJSONTyped;
exports.RelativeTimeRangeToJSON = RelativeTimeRangeToJSON;
exports.RelativeTimeRangeToJSONTyped = RelativeTimeRangeToJSONTyped;
exports.ReportBrandingOptionsFromJSON = ReportBrandingOptionsFromJSON;
exports.ReportBrandingOptionsFromJSONTyped = ReportBrandingOptionsFromJSONTyped;
exports.ReportBrandingOptionsToJSON = ReportBrandingOptionsToJSON;
exports.ReportBrandingOptionsToJSONTyped = ReportBrandingOptionsToJSONTyped;
exports.ReportDashboardFromJSON = ReportDashboardFromJSON;
exports.ReportDashboardFromJSONTyped = ReportDashboardFromJSONTyped;
exports.ReportDashboardIDFromJSON = ReportDashboardIDFromJSON;
exports.ReportDashboardIDFromJSONTyped = ReportDashboardIDFromJSONTyped;
exports.ReportDashboardIDToJSON = ReportDashboardIDToJSON;
exports.ReportDashboardIDToJSONTyped = ReportDashboardIDToJSONTyped;
exports.ReportDashboardToJSON = ReportDashboardToJSON;
exports.ReportDashboardToJSONTyped = ReportDashboardToJSONTyped;
exports.ReportEmailFromJSON = ReportEmailFromJSON;
exports.ReportEmailFromJSONTyped = ReportEmailFromJSONTyped;
exports.ReportEmailToJSON = ReportEmailToJSON;
exports.ReportEmailToJSONTyped = ReportEmailToJSONTyped;
exports.ReportFromJSON = ReportFromJSON;
exports.ReportFromJSONTyped = ReportFromJSONTyped;
exports.ReportOptionsFromJSON = ReportOptionsFromJSON;
exports.ReportOptionsFromJSONTyped = ReportOptionsFromJSONTyped;
exports.ReportOptionsToJSON = ReportOptionsToJSON;
exports.ReportOptionsToJSONTyped = ReportOptionsToJSONTyped;
exports.ReportScheduleFromJSON = ReportScheduleFromJSON;
exports.ReportScheduleFromJSONTyped = ReportScheduleFromJSONTyped;
exports.ReportScheduleToJSON = ReportScheduleToJSON;
exports.ReportScheduleToJSONTyped = ReportScheduleToJSONTyped;
exports.ReportSettingsFromJSON = ReportSettingsFromJSON;
exports.ReportSettingsFromJSONTyped = ReportSettingsFromJSONTyped;
exports.ReportSettingsToJSON = ReportSettingsToJSON;
exports.ReportSettingsToJSONTyped = ReportSettingsToJSONTyped;
exports.ReportTimeRangeFromJSON = ReportTimeRangeFromJSON;
exports.ReportTimeRangeFromJSONTyped = ReportTimeRangeFromJSONTyped;
exports.ReportTimeRangeToJSON = ReportTimeRangeToJSON;
exports.ReportTimeRangeToJSONTyped = ReportTimeRangeToJSONTyped;
exports.ReportToJSON = ReportToJSON;
exports.ReportToJSONTyped = ReportToJSONTyped;
exports.ReportsApi = ReportsApi;
exports.RequiredError = RequiredError;
exports.ResourcePermissionDTOFromJSON = ResourcePermissionDTOFromJSON;
exports.ResourcePermissionDTOFromJSONTyped = ResourcePermissionDTOFromJSONTyped;
exports.ResourcePermissionDTOToJSON = ResourcePermissionDTOToJSON;
exports.ResourcePermissionDTOToJSONTyped = ResourcePermissionDTOToJSONTyped;
exports.ResponseDetailsFromJSON = ResponseDetailsFromJSON;
exports.ResponseDetailsFromJSONTyped = ResponseDetailsFromJSONTyped;
exports.ResponseDetailsToJSON = ResponseDetailsToJSON;
exports.ResponseDetailsToJSONTyped = ResponseDetailsToJSONTyped;
exports.ResponseError = ResponseError;
exports.RestoreDashboardVersionCommandFromJSON = RestoreDashboardVersionCommandFromJSON;
exports.RestoreDashboardVersionCommandFromJSONTyped = RestoreDashboardVersionCommandFromJSONTyped;
exports.RestoreDashboardVersionCommandToJSON = RestoreDashboardVersionCommandToJSON;
exports.RestoreDashboardVersionCommandToJSONTyped = RestoreDashboardVersionCommandToJSONTyped;
exports.RetrieveJWKS200ResponseFromJSON = RetrieveJWKS200ResponseFromJSON;
exports.RetrieveJWKS200ResponseFromJSONTyped = RetrieveJWKS200ResponseFromJSONTyped;
exports.RetrieveJWKS200ResponseToJSON = RetrieveJWKS200ResponseToJSON;
exports.RetrieveJWKS200ResponseToJSONTyped = RetrieveJWKS200ResponseToJSONTyped;
exports.RevokeAuthTokenCmdFromJSON = RevokeAuthTokenCmdFromJSON;
exports.RevokeAuthTokenCmdFromJSONTyped = RevokeAuthTokenCmdFromJSONTyped;
exports.RevokeAuthTokenCmdToJSON = RevokeAuthTokenCmdToJSON;
exports.RevokeAuthTokenCmdToJSONTyped = RevokeAuthTokenCmdToJSONTyped;
exports.RoleAssignmentsDTOFromJSON = RoleAssignmentsDTOFromJSON;
exports.RoleAssignmentsDTOFromJSONTyped = RoleAssignmentsDTOFromJSONTyped;
exports.RoleAssignmentsDTOToJSON = RoleAssignmentsDTOToJSON;
exports.RoleAssignmentsDTOToJSONTyped = RoleAssignmentsDTOToJSONTyped;
exports.RoleDTOFromJSON = RoleDTOFromJSON;
exports.RoleDTOFromJSONTyped = RoleDTOFromJSONTyped;
exports.RoleDTOToJSON = RoleDTOToJSON;
exports.RoleDTOToJSONTyped = RoleDTOToJSONTyped;
exports.RolesSearchQueryFromJSON = RolesSearchQueryFromJSON;
exports.RolesSearchQueryFromJSONTyped = RolesSearchQueryFromJSONTyped;
exports.RolesSearchQueryToJSON = RolesSearchQueryToJSON;
exports.RolesSearchQueryToJSONTyped = RolesSearchQueryToJSONTyped;
exports.RouteExportFromJSON = RouteExportFromJSON;
exports.RouteExportFromJSONTyped = RouteExportFromJSONTyped;
exports.RouteExportMuteTimingFormatEnum = RouteExportMuteTimingFormatEnum;
exports.RouteExportMuteTimingsFormatEnum = RouteExportMuteTimingsFormatEnum;
exports.RouteExportToJSON = RouteExportToJSON;
exports.RouteExportToJSONTyped = RouteExportToJSONTyped;
exports.RouteFromJSON = RouteFromJSON;
exports.RouteFromJSONTyped = RouteFromJSONTyped;
exports.RouteGetAlertRuleExportFormatEnum = RouteGetAlertRuleExportFormatEnum;
exports.RouteGetAlertRuleGroupExportFormatEnum = RouteGetAlertRuleGroupExportFormatEnum;
exports.RouteGetAlertRulesExportFormatEnum = RouteGetAlertRulesExportFormatEnum;
exports.RouteGetContactpointsExportFormatEnum = RouteGetContactpointsExportFormatEnum;
exports.RouteToJSON = RouteToJSON;
exports.RouteToJSONTyped = RouteToJSONTyped;
exports.RuleDiscoveryFromJSON = RuleDiscoveryFromJSON;
exports.RuleDiscoveryFromJSONTyped = RuleDiscoveryFromJSONTyped;
exports.RuleDiscoveryToJSON = RuleDiscoveryToJSON;
exports.RuleDiscoveryToJSONTyped = RuleDiscoveryToJSONTyped;
exports.RuleFromJSON = RuleFromJSON;
exports.RuleFromJSONTyped = RuleFromJSONTyped;
exports.RuleGroupConfigResponseFromJSON = RuleGroupConfigResponseFromJSON;
exports.RuleGroupConfigResponseFromJSONTyped = RuleGroupConfigResponseFromJSONTyped;
exports.RuleGroupConfigResponseToJSON = RuleGroupConfigResponseToJSON;
exports.RuleGroupConfigResponseToJSONTyped = RuleGroupConfigResponseToJSONTyped;
exports.RuleGroupFromJSON = RuleGroupFromJSON;
exports.RuleGroupFromJSONTyped = RuleGroupFromJSONTyped;
exports.RuleGroupToJSON = RuleGroupToJSON;
exports.RuleGroupToJSONTyped = RuleGroupToJSONTyped;
exports.RuleResponseFromJSON = RuleResponseFromJSON;
exports.RuleResponseFromJSONTyped = RuleResponseFromJSONTyped;
exports.RuleResponseToJSON = RuleResponseToJSON;
exports.RuleResponseToJSONTyped = RuleResponseToJSONTyped;
exports.RuleToJSON = RuleToJSON;
exports.RuleToJSONTyped = RuleToJSONTyped;
exports.SNSConfigFromJSON = SNSConfigFromJSON;
exports.SNSConfigFromJSONTyped = SNSConfigFromJSONTyped;
exports.SNSConfigToJSON = SNSConfigToJSON;
exports.SNSConfigToJSONTyped = SNSConfigToJSONTyped;
exports.SamlApi = SamlApi;
exports.SampleFromJSON = SampleFromJSON;
exports.SampleFromJSONTyped = SampleFromJSONTyped;
exports.SampleToJSON = SampleToJSON;
exports.SampleToJSONTyped = SampleToJSONTyped;
exports.SaveDashboardCommandFromJSON = SaveDashboardCommandFromJSON;
exports.SaveDashboardCommandFromJSONTyped = SaveDashboardCommandFromJSONTyped;
exports.SaveDashboardCommandToJSON = SaveDashboardCommandToJSON;
exports.SaveDashboardCommandToJSONTyped = SaveDashboardCommandToJSONTyped;
exports.SearchApi = SearchApi;
exports.SearchDeviceQueryResultFromJSON = SearchDeviceQueryResultFromJSON;
exports.SearchDeviceQueryResultFromJSONTyped = SearchDeviceQueryResultFromJSONTyped;
exports.SearchDeviceQueryResultToJSON = SearchDeviceQueryResultToJSON;
exports.SearchDeviceQueryResultToJSONTyped = SearchDeviceQueryResultToJSONTyped;
exports.SearchOrgServiceAccountsResultFromJSON = SearchOrgServiceAccountsResultFromJSON;
exports.SearchOrgServiceAccountsResultFromJSONTyped = SearchOrgServiceAccountsResultFromJSONTyped;
exports.SearchOrgServiceAccountsResultToJSON = SearchOrgServiceAccountsResultToJSON;
exports.SearchOrgServiceAccountsResultToJSONTyped = SearchOrgServiceAccountsResultToJSONTyped;
exports.SearchOrgUsersQueryResultFromJSON = SearchOrgUsersQueryResultFromJSON;
exports.SearchOrgUsersQueryResultFromJSONTyped = SearchOrgUsersQueryResultFromJSONTyped;
exports.SearchOrgUsersQueryResultToJSON = SearchOrgUsersQueryResultToJSON;
exports.SearchOrgUsersQueryResultToJSONTyped = SearchOrgUsersQueryResultToJSONTyped;
exports.SearchPermissionEnum = SearchPermissionEnum;
exports.SearchQueriesSortEnum = SearchQueriesSortEnum;
exports.SearchResultFromJSON = SearchResultFromJSON;
exports.SearchResultFromJSONTyped = SearchResultFromJSONTyped;
exports.SearchResultItemFromJSON = SearchResultItemFromJSON;
exports.SearchResultItemFromJSONTyped = SearchResultItemFromJSONTyped;
exports.SearchResultItemToJSON = SearchResultItemToJSON;
exports.SearchResultItemToJSONTyped = SearchResultItemToJSONTyped;
exports.SearchResultToJSON = SearchResultToJSON;
exports.SearchResultToJSONTyped = SearchResultToJSONTyped;
exports.SearchSortEnum = SearchSortEnum;
exports.SearchTeamQueryResultFromJSON = SearchTeamQueryResultFromJSON;
exports.SearchTeamQueryResultFromJSONTyped = SearchTeamQueryResultFromJSONTyped;
exports.SearchTeamQueryResultToJSON = SearchTeamQueryResultToJSON;
exports.SearchTeamQueryResultToJSONTyped = SearchTeamQueryResultToJSONTyped;
exports.SearchTypeEnum = SearchTypeEnum;
exports.SearchUserQueryResultFromJSON = SearchUserQueryResultFromJSON;
exports.SearchUserQueryResultFromJSONTyped = SearchUserQueryResultFromJSONTyped;
exports.SearchUserQueryResultToJSON = SearchUserQueryResultToJSON;
exports.SearchUserQueryResultToJSONTyped = SearchUserQueryResultToJSONTyped;
exports.ServiceAccountDTOFromJSON = ServiceAccountDTOFromJSON;
exports.ServiceAccountDTOFromJSONTyped = ServiceAccountDTOFromJSONTyped;
exports.ServiceAccountDTOToJSON = ServiceAccountDTOToJSON;
exports.ServiceAccountDTOToJSONTyped = ServiceAccountDTOToJSONTyped;
exports.ServiceAccountProfileDTOFromJSON = ServiceAccountProfileDTOFromJSON;
exports.ServiceAccountProfileDTOFromJSONTyped = ServiceAccountProfileDTOFromJSONTyped;
exports.ServiceAccountProfileDTOToJSON = ServiceAccountProfileDTOToJSON;
exports.ServiceAccountProfileDTOToJSONTyped = ServiceAccountProfileDTOToJSONTyped;
exports.ServiceAccountsApi = ServiceAccountsApi;
exports.SetPermissionCommandFromJSON = SetPermissionCommandFromJSON;
exports.SetPermissionCommandFromJSONTyped = SetPermissionCommandFromJSONTyped;
exports.SetPermissionCommandToJSON = SetPermissionCommandToJSON;
exports.SetPermissionCommandToJSONTyped = SetPermissionCommandToJSONTyped;
exports.SetPermissionsCommandFromJSON = SetPermissionsCommandFromJSON;
exports.SetPermissionsCommandFromJSONTyped = SetPermissionsCommandFromJSONTyped;
exports.SetPermissionsCommandToJSON = SetPermissionsCommandToJSON;
exports.SetPermissionsCommandToJSONTyped = SetPermissionsCommandToJSONTyped;
exports.SetResourcePermissionCommandFromJSON = SetResourcePermissionCommandFromJSON;
exports.SetResourcePermissionCommandFromJSONTyped = SetResourcePermissionCommandFromJSONTyped;
exports.SetResourcePermissionCommandToJSON = SetResourcePermissionCommandToJSON;
exports.SetResourcePermissionCommandToJSONTyped = SetResourcePermissionCommandToJSONTyped;
exports.SetRoleAssignmentsCommandFromJSON = SetRoleAssignmentsCommandFromJSON;
exports.SetRoleAssignmentsCommandFromJSONTyped = SetRoleAssignmentsCommandFromJSONTyped;
exports.SetRoleAssignmentsCommandToJSON = SetRoleAssignmentsCommandToJSON;
exports.SetRoleAssignmentsCommandToJSONTyped = SetRoleAssignmentsCommandToJSONTyped;
exports.SetUserRolesCommandFromJSON = SetUserRolesCommandFromJSON;
exports.SetUserRolesCommandFromJSONTyped = SetUserRolesCommandFromJSONTyped;
exports.SetUserRolesCommandToJSON = SetUserRolesCommandToJSON;
exports.SetUserRolesCommandToJSONTyped = SetUserRolesCommandToJSONTyped;
exports.SigV4ConfigFromJSON = SigV4ConfigFromJSON;
exports.SigV4ConfigFromJSONTyped = SigV4ConfigFromJSONTyped;
exports.SigV4ConfigToJSON = SigV4ConfigToJSON;
exports.SigV4ConfigToJSONTyped = SigV4ConfigToJSONTyped;
exports.SignedInUserApi = SignedInUserApi;
exports.SigningKeysApi = SigningKeysApi;
exports.SilenceFromJSON = SilenceFromJSON;
exports.SilenceFromJSONTyped = SilenceFromJSONTyped;
exports.SilenceStatusFromJSON = SilenceStatusFromJSON;
exports.SilenceStatusFromJSONTyped = SilenceStatusFromJSONTyped;
exports.SilenceStatusStateEnum = SilenceStatusStateEnum;
exports.SilenceStatusToJSON = SilenceStatusToJSON;
exports.SilenceStatusToJSONTyped = SilenceStatusToJSONTyped;
exports.SilenceToJSON = SilenceToJSON;
exports.SilenceToJSONTyped = SilenceToJSONTyped;
exports.SlackActionFromJSON = SlackActionFromJSON;
exports.SlackActionFromJSONTyped = SlackActionFromJSONTyped;
exports.SlackActionToJSON = SlackActionToJSON;
exports.SlackActionToJSONTyped = SlackActionToJSONTyped;
exports.SlackConfigFromJSON = SlackConfigFromJSON;
exports.SlackConfigFromJSONTyped = SlackConfigFromJSONTyped;
exports.SlackConfigToJSON = SlackConfigToJSON;
exports.SlackConfigToJSONTyped = SlackConfigToJSONTyped;
exports.SlackConfirmationFieldFromJSON = SlackConfirmationFieldFromJSON;
exports.SlackConfirmationFieldFromJSONTyped = SlackConfirmationFieldFromJSONTyped;
exports.SlackConfirmationFieldToJSON = SlackConfirmationFieldToJSON;
exports.SlackConfirmationFieldToJSONTyped = SlackConfirmationFieldToJSONTyped;
exports.SlackFieldFromJSON = SlackFieldFromJSON;
exports.SlackFieldFromJSONTyped = SlackFieldFromJSONTyped;
exports.SlackFieldToJSON = SlackFieldToJSON;
exports.SlackFieldToJSONTyped = SlackFieldToJSONTyped;
exports.SnapshotsApi = SnapshotsApi;
exports.SpanFromJSON = SpanFromJSON;
exports.SpanFromJSONTyped = SpanFromJSONTyped;
exports.SpanToJSON = SpanToJSON;
exports.SpanToJSONTyped = SpanToJSONTyped;
exports.SsoSettingsApi = SsoSettingsApi;
exports.SuccessResponseBodyFromJSON = SuccessResponseBodyFromJSON;
exports.SuccessResponseBodyFromJSONTyped = SuccessResponseBodyFromJSONTyped;
exports.SuccessResponseBodyToJSON = SuccessResponseBodyToJSON;
exports.SuccessResponseBodyToJSONTyped = SuccessResponseBodyToJSONTyped;
exports.SyncResultFromJSON = SyncResultFromJSON;
exports.SyncResultFromJSONTyped = SyncResultFromJSONTyped;
exports.SyncResultToJSON = SyncResultToJSON;
exports.SyncResultToJSONTyped = SyncResultToJSONTyped;
exports.SyncTeamGroupsApi = SyncTeamGroupsApi;
exports.TLSConfigFromJSON = TLSConfigFromJSON;
exports.TLSConfigFromJSONTyped = TLSConfigFromJSONTyped;
exports.TLSConfigToJSON = TLSConfigToJSON;
exports.TLSConfigToJSONTyped = TLSConfigToJSONTyped;
exports.TagsDTOFromJSON = TagsDTOFromJSON;
exports.TagsDTOFromJSONTyped = TagsDTOFromJSONTyped;
exports.TagsDTOToJSON = TagsDTOToJSON;
exports.TagsDTOToJSONTyped = TagsDTOToJSONTyped;
exports.TeamDTOFromJSON = TeamDTOFromJSON;
exports.TeamDTOFromJSONTyped = TeamDTOFromJSONTyped;
exports.TeamDTOToJSON = TeamDTOToJSON;
exports.TeamDTOToJSONTyped = TeamDTOToJSONTyped;
exports.TeamGroupDTOFromJSON = TeamGroupDTOFromJSON;
exports.TeamGroupDTOFromJSONTyped = TeamGroupDTOFromJSONTyped;
exports.TeamGroupDTOToJSON = TeamGroupDTOToJSON;
exports.TeamGroupDTOToJSONTyped = TeamGroupDTOToJSONTyped;
exports.TeamGroupMappingFromJSON = TeamGroupMappingFromJSON;
exports.TeamGroupMappingFromJSONTyped = TeamGroupMappingFromJSONTyped;
exports.TeamGroupMappingToJSON = TeamGroupMappingToJSON;
exports.TeamGroupMappingToJSONTyped = TeamGroupMappingToJSONTyped;
exports.TeamMemberDTOFromJSON = TeamMemberDTOFromJSON;
exports.TeamMemberDTOFromJSONTyped = TeamMemberDTOFromJSONTyped;
exports.TeamMemberDTOToJSON = TeamMemberDTOToJSON;
exports.TeamMemberDTOToJSONTyped = TeamMemberDTOToJSONTyped;
exports.TeamsApi = TeamsApi;
exports.TelegramConfigFromJSON = TelegramConfigFromJSON;
exports.TelegramConfigFromJSONTyped = TelegramConfigFromJSONTyped;
exports.TelegramConfigToJSON = TelegramConfigToJSON;
exports.TelegramConfigToJSONTyped = TelegramConfigToJSONTyped;
exports.TempUserDTOFromJSON = TempUserDTOFromJSON;
exports.TempUserDTOFromJSONTyped = TempUserDTOFromJSONTyped;
exports.TempUserDTORoleEnum = TempUserDTORoleEnum;
exports.TempUserDTOToJSON = TempUserDTOToJSON;
exports.TempUserDTOToJSONTyped = TempUserDTOToJSONTyped;
exports.TestReceiverConfigResultFromJSON = TestReceiverConfigResultFromJSON;
exports.TestReceiverConfigResultFromJSONTyped = TestReceiverConfigResultFromJSONTyped;
exports.TestReceiverConfigResultToJSON = TestReceiverConfigResultToJSON;
exports.TestReceiverConfigResultToJSONTyped = TestReceiverConfigResultToJSONTyped;
exports.TestReceiverResultFromJSON = TestReceiverResultFromJSON;
exports.TestReceiverResultFromJSONTyped = TestReceiverResultFromJSONTyped;
exports.TestReceiverResultToJSON = TestReceiverResultToJSON;
exports.TestReceiverResultToJSONTyped = TestReceiverResultToJSONTyped;
exports.TestReceiversConfigAlertParamsFromJSON = TestReceiversConfigAlertParamsFromJSON;
exports.TestReceiversConfigAlertParamsFromJSONTyped = TestReceiversConfigAlertParamsFromJSONTyped;
exports.TestReceiversConfigAlertParamsToJSON = TestReceiversConfigAlertParamsToJSON;
exports.TestReceiversConfigAlertParamsToJSONTyped = TestReceiversConfigAlertParamsToJSONTyped;
exports.TestReceiversConfigBodyParamsFromJSON = TestReceiversConfigBodyParamsFromJSON;
exports.TestReceiversConfigBodyParamsFromJSONTyped = TestReceiversConfigBodyParamsFromJSONTyped;
exports.TestReceiversConfigBodyParamsToJSON = TestReceiversConfigBodyParamsToJSON;
exports.TestReceiversConfigBodyParamsToJSONTyped = TestReceiversConfigBodyParamsToJSONTyped;
exports.TestReceiversResultFromJSON = TestReceiversResultFromJSON;
exports.TestReceiversResultFromJSONTyped = TestReceiversResultFromJSONTyped;
exports.TestReceiversResultToJSON = TestReceiversResultToJSON;
exports.TestReceiversResultToJSONTyped = TestReceiversResultToJSONTyped;
exports.TestRulePayloadFromJSON = TestRulePayloadFromJSON;
exports.TestRulePayloadFromJSONTyped = TestRulePayloadFromJSONTyped;
exports.TestRulePayloadToJSON = TestRulePayloadToJSON;
exports.TestRulePayloadToJSONTyped = TestRulePayloadToJSONTyped;
exports.TestRuleResponseFromJSON = TestRuleResponseFromJSON;
exports.TestRuleResponseFromJSONTyped = TestRuleResponseFromJSONTyped;
exports.TestRuleResponseToJSON = TestRuleResponseToJSON;
exports.TestRuleResponseToJSONTyped = TestRuleResponseToJSONTyped;
exports.TestTemplatesConfigBodyParamsFromJSON = TestTemplatesConfigBodyParamsFromJSON;
exports.TestTemplatesConfigBodyParamsFromJSONTyped = TestTemplatesConfigBodyParamsFromJSONTyped;
exports.TestTemplatesConfigBodyParamsToJSON = TestTemplatesConfigBodyParamsToJSON;
exports.TestTemplatesConfigBodyParamsToJSONTyped = TestTemplatesConfigBodyParamsToJSONTyped;
exports.TestTemplatesErrorResultFromJSON = TestTemplatesErrorResultFromJSON;
exports.TestTemplatesErrorResultFromJSONTyped = TestTemplatesErrorResultFromJSONTyped;
exports.TestTemplatesErrorResultKindEnum = TestTemplatesErrorResultKindEnum;
exports.TestTemplatesErrorResultToJSON = TestTemplatesErrorResultToJSON;
exports.TestTemplatesErrorResultToJSONTyped = TestTemplatesErrorResultToJSONTyped;
exports.TestTemplatesResultFromJSON = TestTemplatesResultFromJSON;
exports.TestTemplatesResultFromJSONTyped = TestTemplatesResultFromJSONTyped;
exports.TestTemplatesResultToJSON = TestTemplatesResultToJSON;
exports.TestTemplatesResultToJSONTyped = TestTemplatesResultToJSONTyped;
exports.TestTemplatesResultsFromJSON = TestTemplatesResultsFromJSON;
exports.TestTemplatesResultsFromJSONTyped = TestTemplatesResultsFromJSONTyped;
exports.TestTemplatesResultsToJSON = TestTemplatesResultsToJSON;
exports.TestTemplatesResultsToJSONTyped = TestTemplatesResultsToJSONTyped;
exports.TextApiResponse = TextApiResponse;
exports.ThresholdFromJSON = ThresholdFromJSON;
exports.ThresholdFromJSONTyped = ThresholdFromJSONTyped;
exports.ThresholdToJSON = ThresholdToJSON;
exports.ThresholdToJSONTyped = ThresholdToJSONTyped;
exports.ThresholdsConfigFromJSON = ThresholdsConfigFromJSON;
exports.ThresholdsConfigFromJSONTyped = ThresholdsConfigFromJSONTyped;
exports.ThresholdsConfigToJSON = ThresholdsConfigToJSON;
exports.ThresholdsConfigToJSONTyped = ThresholdsConfigToJSONTyped;
exports.TimeIntervalFromJSON = TimeIntervalFromJSON;
exports.TimeIntervalFromJSONTyped = TimeIntervalFromJSONTyped;
exports.TimeIntervalItemFromJSON = TimeIntervalItemFromJSON;
exports.TimeIntervalItemFromJSONTyped = TimeIntervalItemFromJSONTyped;
exports.TimeIntervalItemToJSON = TimeIntervalItemToJSON;
exports.TimeIntervalItemToJSONTyped = TimeIntervalItemToJSONTyped;
exports.TimeIntervalTimeRangeFromJSON = TimeIntervalTimeRangeFromJSON;
exports.TimeIntervalTimeRangeFromJSONTyped = TimeIntervalTimeRangeFromJSONTyped;
exports.TimeIntervalTimeRangeToJSON = TimeIntervalTimeRangeToJSON;
exports.TimeIntervalTimeRangeToJSONTyped = TimeIntervalTimeRangeToJSONTyped;
exports.TimeIntervalToJSON = TimeIntervalToJSON;
exports.TimeIntervalToJSONTyped = TimeIntervalToJSONTyped;
exports.TimeRangeFromJSON = TimeRangeFromJSON;
exports.TimeRangeFromJSONTyped = TimeRangeFromJSONTyped;
exports.TimeRangeToJSON = TimeRangeToJSON;
exports.TimeRangeToJSONTyped = TimeRangeToJSONTyped;
exports.TokenDTOFromJSON = TokenDTOFromJSON;
exports.TokenDTOFromJSONTyped = TokenDTOFromJSONTyped;
exports.TokenDTOToJSON = TokenDTOToJSON;
exports.TokenDTOToJSONTyped = TokenDTOToJSONTyped;
exports.TokenFromJSON = TokenFromJSON;
exports.TokenFromJSONTyped = TokenFromJSONTyped;
exports.TokenToJSON = TokenToJSON;
exports.TokenToJSONTyped = TokenToJSONTyped;
exports.TransformationFromJSON = TransformationFromJSON;
exports.TransformationFromJSONTyped = TransformationFromJSONTyped;
exports.TransformationToJSON = TransformationToJSON;
exports.TransformationToJSONTyped = TransformationToJSONTyped;
exports.TransformationTypeEnum = TransformationTypeEnum;
exports.TypeMetaFromJSON = TypeMetaFromJSON;
exports.TypeMetaFromJSONTyped = TypeMetaFromJSONTyped;
exports.TypeMetaToJSON = TypeMetaToJSON;
exports.TypeMetaToJSONTyped = TypeMetaToJSONTyped;
exports.URLFromJSON = URLFromJSON;
exports.URLFromJSONTyped = URLFromJSONTyped;
exports.URLToJSON = URLToJSON;
exports.URLToJSONTyped = URLToJSONTyped;
exports.UnstructuredFromJSON = UnstructuredFromJSON;
exports.UnstructuredFromJSONTyped = UnstructuredFromJSONTyped;
exports.UnstructuredToJSON = UnstructuredToJSON;
exports.UnstructuredToJSONTyped = UnstructuredToJSONTyped;
exports.UpdateAnnotationsCmdFromJSON = UpdateAnnotationsCmdFromJSON;
exports.UpdateAnnotationsCmdFromJSONTyped = UpdateAnnotationsCmdFromJSONTyped;
exports.UpdateAnnotationsCmdToJSON = UpdateAnnotationsCmdToJSON;
exports.UpdateAnnotationsCmdToJSONTyped = UpdateAnnotationsCmdToJSONTyped;
exports.UpdateCorrelationCommandFromJSON = UpdateCorrelationCommandFromJSON;
exports.UpdateCorrelationCommandFromJSONTyped = UpdateCorrelationCommandFromJSONTyped;
exports.UpdateCorrelationCommandToJSON = UpdateCorrelationCommandToJSON;
exports.UpdateCorrelationCommandToJSONTyped = UpdateCorrelationCommandToJSONTyped;
exports.UpdateCorrelationResponseBodyFromJSON = UpdateCorrelationResponseBodyFromJSON;
exports.UpdateCorrelationResponseBodyFromJSONTyped = UpdateCorrelationResponseBodyFromJSONTyped;
exports.UpdateCorrelationResponseBodyToJSON = UpdateCorrelationResponseBodyToJSON;
exports.UpdateCorrelationResponseBodyToJSONTyped = UpdateCorrelationResponseBodyToJSONTyped;
exports.UpdateDashboardACLCommandFromJSON = UpdateDashboardACLCommandFromJSON;
exports.UpdateDashboardACLCommandFromJSONTyped = UpdateDashboardACLCommandFromJSONTyped;
exports.UpdateDashboardACLCommandToJSON = UpdateDashboardACLCommandToJSON;
exports.UpdateDashboardACLCommandToJSONTyped = UpdateDashboardACLCommandToJSONTyped;
exports.UpdateDataSourceCommandFromJSON = UpdateDataSourceCommandFromJSON;
exports.UpdateDataSourceCommandFromJSONTyped = UpdateDataSourceCommandFromJSONTyped;
exports.UpdateDataSourceCommandToJSON = UpdateDataSourceCommandToJSON;
exports.UpdateDataSourceCommandToJSONTyped = UpdateDataSourceCommandToJSONTyped;
exports.UpdateFolderCommandFromJSON = UpdateFolderCommandFromJSON;
exports.UpdateFolderCommandFromJSONTyped = UpdateFolderCommandFromJSONTyped;
exports.UpdateFolderCommandToJSON = UpdateFolderCommandToJSON;
exports.UpdateFolderCommandToJSONTyped = UpdateFolderCommandToJSONTyped;
exports.UpdateOrgAddressFormFromJSON = UpdateOrgAddressFormFromJSON;
exports.UpdateOrgAddressFormFromJSONTyped = UpdateOrgAddressFormFromJSONTyped;
exports.UpdateOrgAddressFormToJSON = UpdateOrgAddressFormToJSON;
exports.UpdateOrgAddressFormToJSONTyped = UpdateOrgAddressFormToJSONTyped;
exports.UpdateOrgFormFromJSON = UpdateOrgFormFromJSON;
exports.UpdateOrgFormFromJSONTyped = UpdateOrgFormFromJSONTyped;
exports.UpdateOrgFormToJSON = UpdateOrgFormToJSON;
exports.UpdateOrgFormToJSONTyped = UpdateOrgFormToJSONTyped;
exports.UpdateOrgUserCommandFromJSON = UpdateOrgUserCommandFromJSON;
exports.UpdateOrgUserCommandFromJSONTyped = UpdateOrgUserCommandFromJSONTyped;
exports.UpdateOrgUserCommandRoleEnum = UpdateOrgUserCommandRoleEnum;
exports.UpdateOrgUserCommandToJSON = UpdateOrgUserCommandToJSON;
exports.UpdateOrgUserCommandToJSONTyped = UpdateOrgUserCommandToJSONTyped;
exports.UpdatePlaylistCommandFromJSON = UpdatePlaylistCommandFromJSON;
exports.UpdatePlaylistCommandFromJSONTyped = UpdatePlaylistCommandFromJSONTyped;
exports.UpdatePlaylistCommandToJSON = UpdatePlaylistCommandToJSON;
exports.UpdatePlaylistCommandToJSONTyped = UpdatePlaylistCommandToJSONTyped;
exports.UpdatePrefsCmdFromJSON = UpdatePrefsCmdFromJSON;
exports.UpdatePrefsCmdFromJSONTyped = UpdatePrefsCmdFromJSONTyped;
exports.UpdatePrefsCmdThemeEnum = UpdatePrefsCmdThemeEnum;
exports.UpdatePrefsCmdTimezoneEnum = UpdatePrefsCmdTimezoneEnum;
exports.UpdatePrefsCmdToJSON = UpdatePrefsCmdToJSON;
exports.UpdatePrefsCmdToJSONTyped = UpdatePrefsCmdToJSONTyped;
exports.UpdateProviderSettingsRequestFromJSON = UpdateProviderSettingsRequestFromJSON;
exports.UpdateProviderSettingsRequestFromJSONTyped = UpdateProviderSettingsRequestFromJSONTyped;
exports.UpdateProviderSettingsRequestToJSON = UpdateProviderSettingsRequestToJSON;
exports.UpdateProviderSettingsRequestToJSONTyped = UpdateProviderSettingsRequestToJSONTyped;
exports.UpdateQuotaCmdFromJSON = UpdateQuotaCmdFromJSON;
exports.UpdateQuotaCmdFromJSONTyped = UpdateQuotaCmdFromJSONTyped;
exports.UpdateQuotaCmdToJSON = UpdateQuotaCmdToJSON;
exports.UpdateQuotaCmdToJSONTyped = UpdateQuotaCmdToJSONTyped;
exports.UpdateRoleCommandFromJSON = UpdateRoleCommandFromJSON;
exports.UpdateRoleCommandFromJSONTyped = UpdateRoleCommandFromJSONTyped;
exports.UpdateRoleCommandToJSON = UpdateRoleCommandToJSON;
exports.UpdateRoleCommandToJSONTyped = UpdateRoleCommandToJSONTyped;
exports.UpdateRuleGroupResponseFromJSON = UpdateRuleGroupResponseFromJSON;
exports.UpdateRuleGroupResponseFromJSONTyped = UpdateRuleGroupResponseFromJSONTyped;
exports.UpdateRuleGroupResponseToJSON = UpdateRuleGroupResponseToJSON;
exports.UpdateRuleGroupResponseToJSONTyped = UpdateRuleGroupResponseToJSONTyped;
exports.UpdateServiceAccount200ResponseFromJSON = UpdateServiceAccount200ResponseFromJSON;
exports.UpdateServiceAccount200ResponseFromJSONTyped = UpdateServiceAccount200ResponseFromJSONTyped;
exports.UpdateServiceAccount200ResponseToJSON = UpdateServiceAccount200ResponseToJSON;
exports.UpdateServiceAccount200ResponseToJSONTyped = UpdateServiceAccount200ResponseToJSONTyped;
exports.UpdateServiceAccountFormFromJSON = UpdateServiceAccountFormFromJSON;
exports.UpdateServiceAccountFormFromJSONTyped = UpdateServiceAccountFormFromJSONTyped;
exports.UpdateServiceAccountFormRoleEnum = UpdateServiceAccountFormRoleEnum;
exports.UpdateServiceAccountFormToJSON = UpdateServiceAccountFormToJSON;
exports.UpdateServiceAccountFormToJSONTyped = UpdateServiceAccountFormToJSONTyped;
exports.UpdateTeamCommandFromJSON = UpdateTeamCommandFromJSON;
exports.UpdateTeamCommandFromJSONTyped = UpdateTeamCommandFromJSONTyped;
exports.UpdateTeamCommandToJSON = UpdateTeamCommandToJSON;
exports.UpdateTeamCommandToJSONTyped = UpdateTeamCommandToJSONTyped;
exports.UpdateTeamMemberCommandFromJSON = UpdateTeamMemberCommandFromJSON;
exports.UpdateTeamMemberCommandFromJSONTyped = UpdateTeamMemberCommandFromJSONTyped;
exports.UpdateTeamMemberCommandToJSON = UpdateTeamMemberCommandToJSON;
exports.UpdateTeamMemberCommandToJSONTyped = UpdateTeamMemberCommandToJSONTyped;
exports.UpdateUserCommandFromJSON = UpdateUserCommandFromJSON;
exports.UpdateUserCommandFromJSONTyped = UpdateUserCommandFromJSONTyped;
exports.UpdateUserCommandToJSON = UpdateUserCommandToJSON;
exports.UpdateUserCommandToJSONTyped = UpdateUserCommandToJSONTyped;
exports.UserApi = UserApi;
exports.UserLookupDTOFromJSON = UserLookupDTOFromJSON;
exports.UserLookupDTOFromJSONTyped = UserLookupDTOFromJSONTyped;
exports.UserLookupDTOToJSON = UserLookupDTOToJSON;
exports.UserLookupDTOToJSONTyped = UserLookupDTOToJSONTyped;
exports.UserOrgDTOFromJSON = UserOrgDTOFromJSON;
exports.UserOrgDTOFromJSONTyped = UserOrgDTOFromJSONTyped;
exports.UserOrgDTORoleEnum = UserOrgDTORoleEnum;
exports.UserOrgDTOToJSON = UserOrgDTOToJSON;
exports.UserOrgDTOToJSONTyped = UserOrgDTOToJSONTyped;
exports.UserPreferencesApi = UserPreferencesApi;
exports.UserProfileDTOFromJSON = UserProfileDTOFromJSON;
exports.UserProfileDTOFromJSONTyped = UserProfileDTOFromJSONTyped;
exports.UserProfileDTOToJSON = UserProfileDTOToJSON;
exports.UserProfileDTOToJSONTyped = UserProfileDTOToJSONTyped;
exports.UserSearchHitDTOFromJSON = UserSearchHitDTOFromJSON;
exports.UserSearchHitDTOFromJSONTyped = UserSearchHitDTOFromJSONTyped;
exports.UserSearchHitDTOToJSON = UserSearchHitDTOToJSON;
exports.UserSearchHitDTOToJSONTyped = UserSearchHitDTOToJSONTyped;
exports.UserTokenFromJSON = UserTokenFromJSON;
exports.UserTokenFromJSONTyped = UserTokenFromJSONTyped;
exports.UserTokenToJSON = UserTokenToJSON;
exports.UserTokenToJSONTyped = UserTokenToJSONTyped;
exports.UsersApi = UsersApi;
exports.ValidationErrorFromJSON = ValidationErrorFromJSON;
exports.ValidationErrorFromJSONTyped = ValidationErrorFromJSONTyped;
exports.ValidationErrorToJSON = ValidationErrorToJSON;
exports.ValidationErrorToJSONTyped = ValidationErrorToJSONTyped;
exports.VersionInfoFromJSON = VersionInfoFromJSON;
exports.VersionInfoFromJSONTyped = VersionInfoFromJSONTyped;
exports.VersionInfoToJSON = VersionInfoToJSON;
exports.VersionInfoToJSONTyped = VersionInfoToJSONTyped;
exports.VictorOpsConfigFromJSON = VictorOpsConfigFromJSON;
exports.VictorOpsConfigFromJSONTyped = VictorOpsConfigFromJSONTyped;
exports.VictorOpsConfigToJSON = VictorOpsConfigToJSON;
exports.VictorOpsConfigToJSONTyped = VictorOpsConfigToJSONTyped;
exports.VoidApiResponse = VoidApiResponse;
exports.WebexConfigFromJSON = WebexConfigFromJSON;
exports.WebexConfigFromJSONTyped = WebexConfigFromJSONTyped;
exports.WebexConfigToJSON = WebexConfigToJSON;
exports.WebexConfigToJSONTyped = WebexConfigToJSONTyped;
exports.WebhookConfigFromJSON = WebhookConfigFromJSON;
exports.WebhookConfigFromJSONTyped = WebhookConfigFromJSONTyped;
exports.WebhookConfigToJSON = WebhookConfigToJSON;
exports.WebhookConfigToJSONTyped = WebhookConfigToJSONTyped;
exports.WechatConfigFromJSON = WechatConfigFromJSON;
exports.WechatConfigFromJSONTyped = WechatConfigFromJSONTyped;
exports.WechatConfigToJSON = WechatConfigToJSON;
exports.WechatConfigToJSONTyped = WechatConfigToJSONTyped;
exports.canConsumeForm = canConsumeForm;
exports.exists = exists;
exports.instanceOfActiveSyncStatusDTO = instanceOfActiveSyncStatusDTO;
exports.instanceOfActiveUserStats = instanceOfActiveUserStats;
exports.instanceOfAddAPIKeyCommand = instanceOfAddAPIKeyCommand;
exports.instanceOfAddDataSource200Response = instanceOfAddDataSource200Response;
exports.instanceOfAddDataSourceCommand = instanceOfAddDataSourceCommand;
exports.instanceOfAddInviteForm = instanceOfAddInviteForm;
exports.instanceOfAddOrgUserCommand = instanceOfAddOrgUserCommand;
exports.instanceOfAddServiceAccountTokenCommand = instanceOfAddServiceAccountTokenCommand;
exports.instanceOfAddTeamMemberCommand = instanceOfAddTeamMemberCommand;
exports.instanceOfAddTeamRoleCommand = instanceOfAddTeamRoleCommand;
exports.instanceOfAddUserRoleCommand = instanceOfAddUserRoleCommand;
exports.instanceOfAddress = instanceOfAddress;
exports.instanceOfAdminCreateUserForm = instanceOfAdminCreateUserForm;
exports.instanceOfAdminCreateUserResponse = instanceOfAdminCreateUserResponse;
exports.instanceOfAdminStats = instanceOfAdminStats;
exports.instanceOfAdminUpdateUserPasswordForm = instanceOfAdminUpdateUserPasswordForm;
exports.instanceOfAdminUpdateUserPermissionsForm = instanceOfAdminUpdateUserPermissionsForm;
exports.instanceOfAlert = instanceOfAlert;
exports.instanceOfAlertDiscovery = instanceOfAlertDiscovery;
exports.instanceOfAlertGroup = instanceOfAlertGroup;
exports.instanceOfAlertInstancesResponse = instanceOfAlertInstancesResponse;
exports.instanceOfAlertManager = instanceOfAlertManager;
exports.instanceOfAlertManagersResult = instanceOfAlertManagersResult;
exports.instanceOfAlertQuery = instanceOfAlertQuery;
exports.instanceOfAlertQueryExport = instanceOfAlertQueryExport;
exports.instanceOfAlertResponse = instanceOfAlertResponse;
exports.instanceOfAlertRuleExport = instanceOfAlertRuleExport;
exports.instanceOfAlertRuleGroup = instanceOfAlertRuleGroup;
exports.instanceOfAlertRuleGroupExport = instanceOfAlertRuleGroupExport;
exports.instanceOfAlertRuleGroupMetadata = instanceOfAlertRuleGroupMetadata;
exports.instanceOfAlertRuleNotificationSettings = instanceOfAlertRuleNotificationSettings;
exports.instanceOfAlertRuleNotificationSettingsExport = instanceOfAlertRuleNotificationSettingsExport;
exports.instanceOfAlertStatus = instanceOfAlertStatus;
exports.instanceOfAlertingFileExport = instanceOfAlertingFileExport;
exports.instanceOfAlertingRule = instanceOfAlertingRule;
exports.instanceOfAlertingStatus = instanceOfAlertingStatus;
exports.instanceOfAlertmanagerConfig = instanceOfAlertmanagerConfig;
exports.instanceOfAlertmanagerStatus = instanceOfAlertmanagerStatus;
exports.instanceOfAnnotation = instanceOfAnnotation;
exports.instanceOfAnnotationActions = instanceOfAnnotationActions;
exports.instanceOfAnnotationEvent = instanceOfAnnotationEvent;
exports.instanceOfAnnotationPanelFilter = instanceOfAnnotationPanelFilter;
exports.instanceOfAnnotationPermission = instanceOfAnnotationPermission;
exports.instanceOfAnnotationQuery = instanceOfAnnotationQuery;
exports.instanceOfAnnotationTarget = instanceOfAnnotationTarget;
exports.instanceOfApiKeyDTO = instanceOfApiKeyDTO;
exports.instanceOfApiRuleNode = instanceOfApiRuleNode;
exports.instanceOfAssignments = instanceOfAssignments;
exports.instanceOfAttributeTypeAndValue = instanceOfAttributeTypeAndValue;
exports.instanceOfAuthorization = instanceOfAuthorization;
exports.instanceOfBacktestConfig = instanceOfBacktestConfig;
exports.instanceOfBasicAuth = instanceOfBasicAuth;
exports.instanceOfCalculateDashboardDiffRequest = instanceOfCalculateDashboardDiffRequest;
exports.instanceOfCalculateDiffTarget = instanceOfCalculateDiffTarget;
exports.instanceOfCertificate = instanceOfCertificate;
exports.instanceOfChangeUserPasswordCommand = instanceOfChangeUserPasswordCommand;
exports.instanceOfClearHelpFlags200Response = instanceOfClearHelpFlags200Response;
exports.instanceOfClusterStatus = instanceOfClusterStatus;
exports.instanceOfConfig = instanceOfConfig;
exports.instanceOfContactPointExport = instanceOfContactPointExport;
exports.instanceOfCookiePreferences = instanceOfCookiePreferences;
exports.instanceOfCorrelation = instanceOfCorrelation;
exports.instanceOfCorrelationConfig = instanceOfCorrelationConfig;
exports.instanceOfCorrelationConfigUpdateDTO = instanceOfCorrelationConfigUpdateDTO;
exports.instanceOfCreateCorrelationCommand = instanceOfCreateCorrelationCommand;
exports.instanceOfCreateCorrelationResponseBody = instanceOfCreateCorrelationResponseBody;
exports.instanceOfCreateDashboardSnapshot200Response = instanceOfCreateDashboardSnapshot200Response;
exports.instanceOfCreateDashboardSnapshotCommand = instanceOfCreateDashboardSnapshotCommand;
exports.instanceOfCreateFolderCommand = instanceOfCreateFolderCommand;
exports.instanceOfCreateLibraryElementCommand = instanceOfCreateLibraryElementCommand;
exports.instanceOfCreateOrUpdateReportConfig = instanceOfCreateOrUpdateReportConfig;
exports.instanceOfCreateOrg200Response = instanceOfCreateOrg200Response;
exports.instanceOfCreateOrgCommand = instanceOfCreateOrgCommand;
exports.instanceOfCreatePlaylistCommand = instanceOfCreatePlaylistCommand;
exports.instanceOfCreateQueryInQueryHistoryCommand = instanceOfCreateQueryInQueryHistoryCommand;
exports.instanceOfCreateReport200Response = instanceOfCreateReport200Response;
exports.instanceOfCreateRoleForm = instanceOfCreateRoleForm;
exports.instanceOfCreateServiceAccountForm = instanceOfCreateServiceAccountForm;
exports.instanceOfCreateTeam200Response = instanceOfCreateTeam200Response;
exports.instanceOfCreateTeamCommand = instanceOfCreateTeamCommand;
exports.instanceOfDashboardACLInfoDTO = instanceOfDashboardACLInfoDTO;
exports.instanceOfDashboardACLUpdateItem = instanceOfDashboardACLUpdateItem;
exports.instanceOfDashboardCreateCommand = instanceOfDashboardCreateCommand;
exports.instanceOfDashboardFullWithMeta = instanceOfDashboardFullWithMeta;
exports.instanceOfDashboardMeta = instanceOfDashboardMeta;
exports.instanceOfDashboardRedirect = instanceOfDashboardRedirect;
exports.instanceOfDashboardSnapshotDTO = instanceOfDashboardSnapshotDTO;
exports.instanceOfDashboardTagCloudItem = instanceOfDashboardTagCloudItem;
exports.instanceOfDashboardVersionMeta = instanceOfDashboardVersionMeta;
exports.instanceOfDataLink = instanceOfDataLink;
exports.instanceOfDataResponse = instanceOfDataResponse;
exports.instanceOfDataSource = instanceOfDataSource;
exports.instanceOfDataSourceListItemDTO = instanceOfDataSourceListItemDTO;
exports.instanceOfDataSourceRef = instanceOfDataSourceRef;
exports.instanceOfDeleteCorrelationResponseBody = instanceOfDeleteCorrelationResponseBody;
exports.instanceOfDeleteDashboardByUID200Response = instanceOfDeleteDashboardByUID200Response;
exports.instanceOfDeleteDataSourceByName200Response = instanceOfDeleteDataSourceByName200Response;
exports.instanceOfDeleteFolder200Response = instanceOfDeleteFolder200Response;
exports.instanceOfDeleteTokenCommand = instanceOfDeleteTokenCommand;
exports.instanceOfDescription = instanceOfDescription;
exports.instanceOfDeviceDTO = instanceOfDeviceDTO;
exports.instanceOfDeviceSearchHitDTO = instanceOfDeviceSearchHitDTO;
exports.instanceOfDiscordConfig = instanceOfDiscordConfig;
exports.instanceOfDiscoveryBase = instanceOfDiscoveryBase;
exports.instanceOfEmailConfig = instanceOfEmailConfig;
exports.instanceOfEmailDTO = instanceOfEmailDTO;
exports.instanceOfEmbeddedContactPoint = instanceOfEmbeddedContactPoint;
exports.instanceOfEnumFieldConfig = instanceOfEnumFieldConfig;
exports.instanceOfErrorResponseBody = instanceOfErrorResponseBody;
exports.instanceOfEvalAlertConditionCommand = instanceOfEvalAlertConditionCommand;
exports.instanceOfEvalQueriesPayload = instanceOfEvalQueriesPayload;
exports.instanceOfExtendedReceiver = instanceOfExtendedReceiver;
exports.instanceOfExtension = instanceOfExtension;
exports.instanceOfFailedUser = instanceOfFailedUser;
exports.instanceOfField = instanceOfField;
exports.instanceOfFieldConfig = instanceOfFieldConfig;
exports.instanceOfFieldTypeConfig = instanceOfFieldTypeConfig;
exports.instanceOfFindTagsResult = instanceOfFindTagsResult;
exports.instanceOfFloatHistogram = instanceOfFloatHistogram;
exports.instanceOfFolder = instanceOfFolder;
exports.instanceOfFolderSearchHit = instanceOfFolderSearchHit;
exports.instanceOfForbiddenError = instanceOfForbiddenError;
exports.instanceOfFrame = instanceOfFrame;
exports.instanceOfFrameMeta = instanceOfFrameMeta;
exports.instanceOfGenericPublicError = instanceOfGenericPublicError;
exports.instanceOfGetAnnotationTagsResponse = instanceOfGetAnnotationTagsResponse;
exports.instanceOfGetDataSourceIdByName200Response = instanceOfGetDataSourceIdByName200Response;
exports.instanceOfGetHomeDashboardResponse = instanceOfGetHomeDashboardResponse;
exports.instanceOfGetSharingOptions200Response = instanceOfGetSharingOptions200Response;
exports.instanceOfGettableAlert = instanceOfGettableAlert;
exports.instanceOfGettableAlertmanagers = instanceOfGettableAlertmanagers;
exports.instanceOfGettableApiAlertingConfig = instanceOfGettableApiAlertingConfig;
exports.instanceOfGettableApiReceiver = instanceOfGettableApiReceiver;
exports.instanceOfGettableExtendedRuleNode = instanceOfGettableExtendedRuleNode;
exports.instanceOfGettableGrafanaReceiver = instanceOfGettableGrafanaReceiver;
exports.instanceOfGettableGrafanaReceivers = instanceOfGettableGrafanaReceivers;
exports.instanceOfGettableGrafanaRule = instanceOfGettableGrafanaRule;
exports.instanceOfGettableHistoricUserConfig = instanceOfGettableHistoricUserConfig;
exports.instanceOfGettableNGalertConfig = instanceOfGettableNGalertConfig;
exports.instanceOfGettableRuleGroupConfig = instanceOfGettableRuleGroupConfig;
exports.instanceOfGettableSilence = instanceOfGettableSilence;
exports.instanceOfGettableStatus = instanceOfGettableStatus;
exports.instanceOfGettableTimeIntervals = instanceOfGettableTimeIntervals;
exports.instanceOfGettableUserConfig = instanceOfGettableUserConfig;
exports.instanceOfGlobalConfig = instanceOfGlobalConfig;
exports.instanceOfHTTPClientConfig = instanceOfHTTPClientConfig;
exports.instanceOfHit = instanceOfHit;
exports.instanceOfHostPort = instanceOfHostPort;
exports.instanceOfIPNet = instanceOfIPNet;
exports.instanceOfImportDashboardInput = instanceOfImportDashboardInput;
exports.instanceOfImportDashboardRequest = instanceOfImportDashboardRequest;
exports.instanceOfImportDashboardResponse = instanceOfImportDashboardResponse;
exports.instanceOfInhibitRule = instanceOfInhibitRule;
exports.instanceOfIntegration = instanceOfIntegration;
exports.instanceOfInternalDataLink = instanceOfInternalDataLink;
exports.instanceOfJSONWebKey = instanceOfJSONWebKey;
exports.instanceOfLabel = instanceOfLabel;
exports.instanceOfLibraryElementArrayResponse = instanceOfLibraryElementArrayResponse;
exports.instanceOfLibraryElementConnectionDTO = instanceOfLibraryElementConnectionDTO;
exports.instanceOfLibraryElementConnectionsResponse = instanceOfLibraryElementConnectionsResponse;
exports.instanceOfLibraryElementDTO = instanceOfLibraryElementDTO;
exports.instanceOfLibraryElementDTOMeta = instanceOfLibraryElementDTOMeta;
exports.instanceOfLibraryElementDTOMetaUser = instanceOfLibraryElementDTOMetaUser;
exports.instanceOfLibraryElementResponse = instanceOfLibraryElementResponse;
exports.instanceOfLibraryElementSearchResponse = instanceOfLibraryElementSearchResponse;
exports.instanceOfLibraryElementSearchResult = instanceOfLibraryElementSearchResult;
exports.instanceOfLinkTransformationConfig = instanceOfLinkTransformationConfig;
exports.instanceOfListAllProvidersSettings200ResponseInner = instanceOfListAllProvidersSettings200ResponseInner;
exports.instanceOfListSortOptions200Response = instanceOfListSortOptions200Response;
exports.instanceOfMSTeamsConfig = instanceOfMSTeamsConfig;
exports.instanceOfMassDeleteAnnotationsCmd = instanceOfMassDeleteAnnotationsCmd;
exports.instanceOfMatcher = instanceOfMatcher;
exports.instanceOfMetricRequest = instanceOfMetricRequest;
exports.instanceOfMoveFolderCommand = instanceOfMoveFolderCommand;
exports.instanceOfMuteTimeInterval = instanceOfMuteTimeInterval;
exports.instanceOfMuteTimeIntervalExport = instanceOfMuteTimeIntervalExport;
exports.instanceOfName = instanceOfName;
exports.instanceOfNewApiKeyResult = instanceOfNewApiKeyResult;
exports.instanceOfNotice = instanceOfNotice;
exports.instanceOfNotificationPolicyExport = instanceOfNotificationPolicyExport;
exports.instanceOfNotificationTemplate = instanceOfNotificationTemplate;
exports.instanceOfNotificationTemplateContent = instanceOfNotificationTemplateContent;
exports.instanceOfNotifierConfig = instanceOfNotifierConfig;
exports.instanceOfOAuth2 = instanceOfOAuth2;
exports.instanceOfOpsGenieConfig = instanceOfOpsGenieConfig;
exports.instanceOfOpsGenieConfigResponder = instanceOfOpsGenieConfigResponder;
exports.instanceOfOrgDTO = instanceOfOrgDTO;
exports.instanceOfOrgDetailsDTO = instanceOfOrgDetailsDTO;
exports.instanceOfOrgUserDTO = instanceOfOrgUserDTO;
exports.instanceOfPagerdutyConfig = instanceOfPagerdutyConfig;
exports.instanceOfPagerdutyImage = instanceOfPagerdutyImage;
exports.instanceOfPagerdutyLink = instanceOfPagerdutyLink;
exports.instanceOfPatchAnnotationsCmd = instanceOfPatchAnnotationsCmd;
exports.instanceOfPatchLibraryElementCommand = instanceOfPatchLibraryElementCommand;
exports.instanceOfPatchPrefsCmd = instanceOfPatchPrefsCmd;
exports.instanceOfPatchQueryCommentInQueryHistoryCommand = instanceOfPatchQueryCommentInQueryHistoryCommand;
exports.instanceOfPeerStatus = instanceOfPeerStatus;
exports.instanceOfPermission = instanceOfPermission;
exports.instanceOfPlaylist = instanceOfPlaylist;
exports.instanceOfPlaylistDTO = instanceOfPlaylistDTO;
exports.instanceOfPlaylistDashboard = instanceOfPlaylistDashboard;
exports.instanceOfPlaylistItem = instanceOfPlaylistItem;
exports.instanceOfPlaylistItemDTO = instanceOfPlaylistItemDTO;
exports.instanceOfPostAnnotation200Response = instanceOfPostAnnotation200Response;
exports.instanceOfPostAnnotationsCmd = instanceOfPostAnnotationsCmd;
exports.instanceOfPostDashboard200Response = instanceOfPostDashboard200Response;
exports.instanceOfPostGraphiteAnnotationsCmd = instanceOfPostGraphiteAnnotationsCmd;
exports.instanceOfPostSilencesOKBody = instanceOfPostSilencesOKBody;
exports.instanceOfPostableAlert = instanceOfPostableAlert;
exports.instanceOfPostableApiAlertingConfig = instanceOfPostableApiAlertingConfig;
exports.instanceOfPostableApiReceiver = instanceOfPostableApiReceiver;
exports.instanceOfPostableExtendedRuleNode = instanceOfPostableExtendedRuleNode;
exports.instanceOfPostableExtendedRuleNodeExtended = instanceOfPostableExtendedRuleNodeExtended;
exports.instanceOfPostableGrafanaReceiver = instanceOfPostableGrafanaReceiver;
exports.instanceOfPostableGrafanaReceivers = instanceOfPostableGrafanaReceivers;
exports.instanceOfPostableGrafanaRule = instanceOfPostableGrafanaRule;
exports.instanceOfPostableNGalertConfig = instanceOfPostableNGalertConfig;
exports.instanceOfPostableRuleGroupConfig = instanceOfPostableRuleGroupConfig;
exports.instanceOfPostableSilence = instanceOfPostableSilence;
exports.instanceOfPostableTimeIntervals = instanceOfPostableTimeIntervals;
exports.instanceOfPostableUserConfig = instanceOfPostableUserConfig;
exports.instanceOfPreferences = instanceOfPreferences;
exports.instanceOfPrometheusRemoteWriteTargetJSON = instanceOfPrometheusRemoteWriteTargetJSON;
exports.instanceOfProvisionedAlertRule = instanceOfProvisionedAlertRule;
exports.instanceOfProxyConfig = instanceOfProxyConfig;
exports.instanceOfPublicDashboard = instanceOfPublicDashboard;
exports.instanceOfPublicDashboardDTO = instanceOfPublicDashboardDTO;
exports.instanceOfPublicDashboardListResponse = instanceOfPublicDashboardListResponse;
exports.instanceOfPublicDashboardListResponseWithPagination = instanceOfPublicDashboardListResponseWithPagination;
exports.instanceOfPublicError = instanceOfPublicError;
exports.instanceOfPushoverConfig = instanceOfPushoverConfig;
exports.instanceOfQueryDataResponse = instanceOfQueryDataResponse;
exports.instanceOfQueryHistoryDTO = instanceOfQueryHistoryDTO;
exports.instanceOfQueryHistoryDeleteQueryResponse = instanceOfQueryHistoryDeleteQueryResponse;
exports.instanceOfQueryHistoryPreference = instanceOfQueryHistoryPreference;
exports.instanceOfQueryHistoryResponse = instanceOfQueryHistoryResponse;
exports.instanceOfQueryHistorySearchResponse = instanceOfQueryHistorySearchResponse;
exports.instanceOfQueryHistorySearchResult = instanceOfQueryHistorySearchResult;
exports.instanceOfQueryStat = instanceOfQueryStat;
exports.instanceOfQuotaDTO = instanceOfQuotaDTO;
exports.instanceOfReceiver = instanceOfReceiver;
exports.instanceOfReceiverExport = instanceOfReceiverExport;
exports.instanceOfRecordingRuleJSON = instanceOfRecordingRuleJSON;
exports.instanceOfRelativeTimeRange = instanceOfRelativeTimeRange;
exports.instanceOfRelativeTimeRangeExport = instanceOfRelativeTimeRangeExport;
exports.instanceOfReport = instanceOfReport;
exports.instanceOfReportBrandingOptions = instanceOfReportBrandingOptions;
exports.instanceOfReportDashboard = instanceOfReportDashboard;
exports.instanceOfReportDashboardID = instanceOfReportDashboardID;
exports.instanceOfReportEmail = instanceOfReportEmail;
exports.instanceOfReportOptions = instanceOfReportOptions;
exports.instanceOfReportSchedule = instanceOfReportSchedule;
exports.instanceOfReportSettings = instanceOfReportSettings;
exports.instanceOfReportTimeRange = instanceOfReportTimeRange;
exports.instanceOfResourcePermissionDTO = instanceOfResourcePermissionDTO;
exports.instanceOfResponseDetails = instanceOfResponseDetails;
exports.instanceOfRestoreDashboardVersionCommand = instanceOfRestoreDashboardVersionCommand;
exports.instanceOfRetrieveJWKS200Response = instanceOfRetrieveJWKS200Response;
exports.instanceOfRevokeAuthTokenCmd = instanceOfRevokeAuthTokenCmd;
exports.instanceOfRoleAssignmentsDTO = instanceOfRoleAssignmentsDTO;
exports.instanceOfRoleDTO = instanceOfRoleDTO;
exports.instanceOfRolesSearchQuery = instanceOfRolesSearchQuery;
exports.instanceOfRoute = instanceOfRoute;
exports.instanceOfRouteExport = instanceOfRouteExport;
exports.instanceOfRule = instanceOfRule;
exports.instanceOfRuleDiscovery = instanceOfRuleDiscovery;
exports.instanceOfRuleGroup = instanceOfRuleGroup;
exports.instanceOfRuleGroupConfigResponse = instanceOfRuleGroupConfigResponse;
exports.instanceOfRuleResponse = instanceOfRuleResponse;
exports.instanceOfSNSConfig = instanceOfSNSConfig;
exports.instanceOfSample = instanceOfSample;
exports.instanceOfSaveDashboardCommand = instanceOfSaveDashboardCommand;
exports.instanceOfSearchDeviceQueryResult = instanceOfSearchDeviceQueryResult;
exports.instanceOfSearchOrgServiceAccountsResult = instanceOfSearchOrgServiceAccountsResult;
exports.instanceOfSearchOrgUsersQueryResult = instanceOfSearchOrgUsersQueryResult;
exports.instanceOfSearchResult = instanceOfSearchResult;
exports.instanceOfSearchResultItem = instanceOfSearchResultItem;
exports.instanceOfSearchTeamQueryResult = instanceOfSearchTeamQueryResult;
exports.instanceOfSearchUserQueryResult = instanceOfSearchUserQueryResult;
exports.instanceOfServiceAccountDTO = instanceOfServiceAccountDTO;
exports.instanceOfServiceAccountProfileDTO = instanceOfServiceAccountProfileDTO;
exports.instanceOfSetPermissionCommand = instanceOfSetPermissionCommand;
exports.instanceOfSetPermissionsCommand = instanceOfSetPermissionsCommand;
exports.instanceOfSetResourcePermissionCommand = instanceOfSetResourcePermissionCommand;
exports.instanceOfSetRoleAssignmentsCommand = instanceOfSetRoleAssignmentsCommand;
exports.instanceOfSetUserRolesCommand = instanceOfSetUserRolesCommand;
exports.instanceOfSigV4Config = instanceOfSigV4Config;
exports.instanceOfSilence = instanceOfSilence;
exports.instanceOfSilenceStatus = instanceOfSilenceStatus;
exports.instanceOfSlackAction = instanceOfSlackAction;
exports.instanceOfSlackConfig = instanceOfSlackConfig;
exports.instanceOfSlackConfirmationField = instanceOfSlackConfirmationField;
exports.instanceOfSlackField = instanceOfSlackField;
exports.instanceOfSpan = instanceOfSpan;
exports.instanceOfSuccessResponseBody = instanceOfSuccessResponseBody;
exports.instanceOfSyncResult = instanceOfSyncResult;
exports.instanceOfTLSConfig = instanceOfTLSConfig;
exports.instanceOfTagsDTO = instanceOfTagsDTO;
exports.instanceOfTeamDTO = instanceOfTeamDTO;
exports.instanceOfTeamGroupDTO = instanceOfTeamGroupDTO;
exports.instanceOfTeamGroupMapping = instanceOfTeamGroupMapping;
exports.instanceOfTeamMemberDTO = instanceOfTeamMemberDTO;
exports.instanceOfTelegramConfig = instanceOfTelegramConfig;
exports.instanceOfTempUserDTO = instanceOfTempUserDTO;
exports.instanceOfTestReceiverConfigResult = instanceOfTestReceiverConfigResult;
exports.instanceOfTestReceiverResult = instanceOfTestReceiverResult;
exports.instanceOfTestReceiversConfigAlertParams = instanceOfTestReceiversConfigAlertParams;
exports.instanceOfTestReceiversConfigBodyParams = instanceOfTestReceiversConfigBodyParams;
exports.instanceOfTestReceiversResult = instanceOfTestReceiversResult;
exports.instanceOfTestRulePayload = instanceOfTestRulePayload;
exports.instanceOfTestRuleResponse = instanceOfTestRuleResponse;
exports.instanceOfTestTemplatesConfigBodyParams = instanceOfTestTemplatesConfigBodyParams;
exports.instanceOfTestTemplatesErrorResult = instanceOfTestTemplatesErrorResult;
exports.instanceOfTestTemplatesResult = instanceOfTestTemplatesResult;
exports.instanceOfTestTemplatesResults = instanceOfTestTemplatesResults;
exports.instanceOfThreshold = instanceOfThreshold;
exports.instanceOfThresholdsConfig = instanceOfThresholdsConfig;
exports.instanceOfTimeInterval = instanceOfTimeInterval;
exports.instanceOfTimeIntervalItem = instanceOfTimeIntervalItem;
exports.instanceOfTimeIntervalTimeRange = instanceOfTimeIntervalTimeRange;
exports.instanceOfTimeRange = instanceOfTimeRange;
exports.instanceOfToken = instanceOfToken;
exports.instanceOfTokenDTO = instanceOfTokenDTO;
exports.instanceOfTransformation = instanceOfTransformation;
exports.instanceOfTypeMeta = instanceOfTypeMeta;
exports.instanceOfURL = instanceOfURL;
exports.instanceOfUnstructured = instanceOfUnstructured;
exports.instanceOfUpdateAnnotationsCmd = instanceOfUpdateAnnotationsCmd;
exports.instanceOfUpdateCorrelationCommand = instanceOfUpdateCorrelationCommand;
exports.instanceOfUpdateCorrelationResponseBody = instanceOfUpdateCorrelationResponseBody;
exports.instanceOfUpdateDashboardACLCommand = instanceOfUpdateDashboardACLCommand;
exports.instanceOfUpdateDataSourceCommand = instanceOfUpdateDataSourceCommand;
exports.instanceOfUpdateFolderCommand = instanceOfUpdateFolderCommand;
exports.instanceOfUpdateOrgAddressForm = instanceOfUpdateOrgAddressForm;
exports.instanceOfUpdateOrgForm = instanceOfUpdateOrgForm;
exports.instanceOfUpdateOrgUserCommand = instanceOfUpdateOrgUserCommand;
exports.instanceOfUpdatePlaylistCommand = instanceOfUpdatePlaylistCommand;
exports.instanceOfUpdatePrefsCmd = instanceOfUpdatePrefsCmd;
exports.instanceOfUpdateProviderSettingsRequest = instanceOfUpdateProviderSettingsRequest;
exports.instanceOfUpdateQuotaCmd = instanceOfUpdateQuotaCmd;
exports.instanceOfUpdateRoleCommand = instanceOfUpdateRoleCommand;
exports.instanceOfUpdateRuleGroupResponse = instanceOfUpdateRuleGroupResponse;
exports.instanceOfUpdateServiceAccount200Response = instanceOfUpdateServiceAccount200Response;
exports.instanceOfUpdateServiceAccountForm = instanceOfUpdateServiceAccountForm;
exports.instanceOfUpdateTeamCommand = instanceOfUpdateTeamCommand;
exports.instanceOfUpdateTeamMemberCommand = instanceOfUpdateTeamMemberCommand;
exports.instanceOfUpdateUserCommand = instanceOfUpdateUserCommand;
exports.instanceOfUserLookupDTO = instanceOfUserLookupDTO;
exports.instanceOfUserOrgDTO = instanceOfUserOrgDTO;
exports.instanceOfUserProfileDTO = instanceOfUserProfileDTO;
exports.instanceOfUserSearchHitDTO = instanceOfUserSearchHitDTO;
exports.instanceOfUserToken = instanceOfUserToken;
exports.instanceOfValidationError = instanceOfValidationError;
exports.instanceOfVersionInfo = instanceOfVersionInfo;
exports.instanceOfVictorOpsConfig = instanceOfVictorOpsConfig;
exports.instanceOfWebexConfig = instanceOfWebexConfig;
exports.instanceOfWebhookConfig = instanceOfWebhookConfig;
exports.instanceOfWechatConfig = instanceOfWechatConfig;
exports.mapValues = mapValues;
exports.querystring = querystring;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map