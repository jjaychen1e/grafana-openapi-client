/* tslint:disable */
/* eslint-disable */
/**
 * Grafana HTTP API.
 * The Grafana backend exposes an HTTP API, the same API is used by the frontend to do everything from saving dashboards, creating users and updating data sources.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: hello@grafana.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime.js';
import type { AttributeTypeAndValue } from './AttributeTypeAndValue.js';
import {
    AttributeTypeAndValueFromJSON,
    AttributeTypeAndValueFromJSONTyped,
    AttributeTypeAndValueToJSON,
    AttributeTypeAndValueToJSONTyped,
} from './AttributeTypeAndValue.js';

/**
 * Name represents an X.509 distinguished name. This only includes the common
 * elements of a DN. Note that Name is only an approximation of the X.509
 * structure. If an accurate representation is needed, asn1.Unmarshal the raw
 * subject or issuer as an [RDNSequence].
 * @export
 * @interface Name
 */
export interface Name {
    /**
     * 
     * @type {Array<string>}
     * @memberof Name
     */
    country?: Array<string>;
    /**
     * ExtraNames contains attributes to be copied, raw, into any marshaled
     * distinguished names. Values override any attributes with the same OID.
     * The ExtraNames field is not populated when parsing, see Names.
     * @type {Array<AttributeTypeAndValue>}
     * @memberof Name
     */
    extraNames?: Array<AttributeTypeAndValue>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Name
     */
    locality?: Array<string>;
    /**
     * Names contains all parsed attributes. When parsing distinguished names,
     * this can be used to extract non-standard attributes that are not parsed
     * by this package. When marshaling to RDNSequences, the Names field is
     * ignored, see ExtraNames.
     * @type {Array<AttributeTypeAndValue>}
     * @memberof Name
     */
    names?: Array<AttributeTypeAndValue>;
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    serialNumber?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Name
     */
    streetAddress?: Array<string>;
}

/**
 * Check if a given object implements the Name interface.
 */
export function instanceOfName(value: object): value is Name {
    return true;
}

export function NameFromJSON(json: any): Name {
    return NameFromJSONTyped(json, false);
}

export function NameFromJSONTyped(json: any, ignoreDiscriminator: boolean): Name {
    if (json == null) {
        return json;
    }
    return {
        
        'country': json['Country'] == null ? undefined : json['Country'],
        'extraNames': json['ExtraNames'] == null ? undefined : ((json['ExtraNames'] as Array<any>).map(AttributeTypeAndValueFromJSON)),
        'locality': json['Locality'] == null ? undefined : json['Locality'],
        'names': json['Names'] == null ? undefined : ((json['Names'] as Array<any>).map(AttributeTypeAndValueFromJSON)),
        'serialNumber': json['SerialNumber'] == null ? undefined : json['SerialNumber'],
        'streetAddress': json['StreetAddress'] == null ? undefined : json['StreetAddress'],
    };
}

export function NameToJSON(json: any): Name {
    return NameToJSONTyped(json, false);
}

export function NameToJSONTyped(value?: Name | null, ignoreDiscriminator: boolean = false): any {
    if (value == null) {
        return value;
    }

    return {
        
        'Country': value['country'],
        'ExtraNames': value['extraNames'] == null ? undefined : ((value['extraNames'] as Array<any>).map(AttributeTypeAndValueToJSON)),
        'Locality': value['locality'],
        'Names': value['names'] == null ? undefined : ((value['names'] as Array<any>).map(AttributeTypeAndValueToJSON)),
        'SerialNumber': value['serialNumber'],
        'StreetAddress': value['streetAddress'],
    };
}

